<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>我最喜欢的 Go 构建选项</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Gaurav Kamathe 这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。 学习一门新的编程语言最令人欣慰的部分之一，就 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2022/04/wo-zui-xi-huan-de-go-gou-jian-xuan-xiang.html" rel="bookmark"
           title="Permalink to 我最喜欢的 Go 构建选项">我最喜欢的 Go 构建选项</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2022-04-30T17:21:00+02:00">
                Published: Sat 30 April 2022
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Gaurav Kamathe</p>
<blockquote>
<p>这些方便的 Go 构建选项可以帮助你更好地理解 Go 的编译过程。</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/202204/30/172121exam5k8vx45kzk7p.jpg"></p>
<p>学习一门新的编程语言最令人欣慰的部分之一，就是最终运行了一个可执行文件，并获得预期的输出。当我开始学习 Go 这门编程语言时，我先是阅读一些示例程序来熟悉语法，然后是尝试写一些小的测试程序。随着时间的推移，这种方法帮助我熟悉了编译和构建程序的过程。</p>
<p>Go 的构建选项提供了更好地控制构建过程的方法。它们还可以提供额外的信息，帮助把这个过程分成更小的部分。在这篇文章中，我将演示我所使用的一些选项。注意：我使用的“<ruby> 构建 <rt>  build </rt></ruby>”和“<ruby> 编译 <rt>  compile </rt></ruby>”这两个词是同一个意思。</p>
<h3>开始使用 Go</h3>
<p>我使用的 Go 版本是 1.16.7。但是，这里给出的命令应该也能在最新的版本上运行。如果你没有安装 Go，你可以从 <a href="https://go.dev/doc/install">Go 官网</a> 上下载它，并按照说明进行安装。你可以通过打开一个命令提示符，并键入下面的命令来验证你所安装的版本：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>version
</code></pre></div>

<p>你应该会得到类似下面这样的输出，具体取决于你安装的版本：</p>
<div class="highlight"><pre><span></span><code><span class="k">go</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="n">go1</span><span class="mf">.16.7</span><span class="w"> </span><span class="n">linux</span><span class="o">/</span><span class="n">amd64</span>
</code></pre></div>

<h3>基本的 Go 程序的编译和执行方法</h3>
<p>我将从一个在屏幕上简单打印 “Hello World” 的 Go 程序示例开始，就像下面这样：</p>
<div class="highlight"><pre><span></span><code><span class="err">$</span> <span class="n">cat</span> <span class="n">hello</span><span class="o">.</span><span class="n">go</span>
<span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="s2">&quot;fmt&quot;</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">fmt</span><span class="o">.</span><span class="n">Println</span><span class="p">(</span><span class="s2">&quot;Hello World&quot;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>在讨论更高级的选项之前，我将解释如何编译这个 Go 示例程序。我使用了 <code>build</code> 命令，后面跟着 Go 程序的源文件名，本例中是 <code>hello.go</code>，就像下面这样：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>hello.go
</code></pre></div>

<p>如果一切工作正常，你应该看到在你的当前目录下创建了一个名为 <code>hello</code> 的可执行文件。你可以通过使用 <code>file</code> 命令验证它是 ELF 二进制可执行格式（在 Linux 平台上）。你也可以直接执行它，你会看到它输出 “Hello World”。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>ls
hello<span class="w">  </span>hello.go

$<span class="w"> </span>file<span class="w"> </span>./hello
./hello:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>executable,<span class="w"> </span>x86-64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>statically<span class="w"> </span>linked,<span class="w"> </span>not<span class="w"> </span>stripped

$<span class="w"> </span>./hello
Hello<span class="w"> </span>World
</code></pre></div>

<p>Go 提供了一个方便的 <code>run</code> 命令，以便你只是想看看程序是否能正常工作，并获得预期的输出，而不想生成一个最终的二进制文件。请记住，即使你在当前目录中没有看到可执行文件，Go 仍然会在某个地方编译并生成可执行文件并运行它，然后把它从系统中删除。我将在本文后面的章节中解释。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>run<span class="w"> </span>hello.go
Hello<span class="w"> </span>World

$<span class="w"> </span>ls
hello.go
</code></pre></div>

<h3>更多细节</h3>
<p>上面的命令就像一阵风一样，一下子就运行完了我的程序。然而，如果你想知道 Go 在编译这些程序的过程中做了什么，Go 提供了一个 <code>-x</code> 选项，它可以打印出 Go 为产生这个可执行文件所做的一切。</p>
<p>简单看一下你就会发现，Go 在 <code>/tmp</code> 内创建了一个临时工作目录，并生成了可执行文件，然后把它移到了 Go 源程序所在的当前目录。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>-x<span class="w"> </span>hello.go

<span class="nv">WORK</span><span class="o">=</span>/tmp/go-build1944767317
mkdir<span class="w"> </span>-p<span class="w"> </span><span class="nv">$WORK</span>/b001/

<span class="s">&lt;&lt; snip &gt;&gt;</span>

<span class="s">mkdir -p $WORK/b001/exe/</span>
<span class="s">cd .</span>
<span class="s">/us</span>r/lib/golang/pkg/tool/linux_amd64/link<span class="w"> </span>-o<span class="w"> </span><span class="nv">$WORK</span><span class="w"> </span><span class="se">\</span>
/b001/exe/a.out<span class="w"> </span>-importcfg<span class="w"> </span><span class="nv">$WORK</span>/b001<span class="w"> </span><span class="se">\</span>
/importcfg.link<span class="w"> </span>-buildmode<span class="o">=</span>exe<span class="w"> </span>-buildid<span class="o">=</span>K26hEYzgDkqJjx2Hf-wz/<span class="se">\</span>
nDueg0kBjIygx25rYwbK/W-eJaGIOdPEWgwC6o546<span class="w"> </span><span class="se">\</span>
/K26hEYzgDkqJjx2Hf-wz<span class="w"> </span>-extld<span class="o">=</span>gcc<span class="w"> </span>/root/.cache/go-build<span class="w"> </span>/cc<span class="w"> </span><span class="se">\</span>
/cc72cb2f4fbb61229885fc434995964a7a4d6e10692a23cc0ada6707c5d3435b-d
/usr/lib/golang/pkg/tool/linux_amd64/buildid<span class="w"> </span>-w<span class="w"> </span><span class="nv">$WORK</span><span class="w"> </span><span class="se">\</span>
/b001/exe/a.out<span class="w"> </span><span class="c1"># internal</span>
mv<span class="w"> </span><span class="nv">$WORK</span>/b001/exe/a.out<span class="w"> </span>hello
rm<span class="w"> </span>-r<span class="w"> </span><span class="nv">$WORK</span>/b001/
</code></pre></div>

<p>这有助于解决在程序运行后却在当前目录下没有生成可执行文件的谜团。使用 <code>-x</code> 显示可执行文件确实在 <code>/tmp</code> 工作目录下创建并被执行了。然而，与 <code>build</code> 命令不同的是，可执行文件并没有移动到当前目录，这使得看起来没有可执行文件被创建。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>run<span class="w"> </span>-x<span class="w"> </span>hello.go


mkdir<span class="w"> </span>-p<span class="w"> </span><span class="nv">$WORK</span>/b001/exe/
<span class="nb">cd</span><span class="w"> </span>.
/usr/lib/golang/pkg/tool/linux_amd64/link<span class="w"> </span>-o<span class="w"> </span><span class="nv">$WORK</span>/b001<span class="w"> </span><span class="se">\</span>
/exe/hello<span class="w"> </span>-importcfg<span class="w"> </span><span class="nv">$WORK</span>/b001/importcfg.link<span class="w"> </span>-s<span class="w"> </span>-w<span class="w"> </span>-buildmode<span class="o">=</span>exe<span class="w"> </span>-buildid<span class="o">=</span>hK3wnAP20DapUDeuvAAS/E_TzkbzwXz6tM5dEC8Mx<span class="w"> </span><span class="se">\</span>
/7HYBzuaDGVdaZwSMEWAa/hK3wnAP20DapUDeuvAAS<span class="w"> </span>-extld<span class="o">=</span>gcc<span class="w"> </span><span class="se">\</span>
/root/.cache/go-build/75/<span class="w"> </span><span class="se">\</span>
7531fcf5e48444eed677bfc5cda1276a52b73c62ebac3aa99da3c4094fa57dc3-d
<span class="nv">$WORK</span>/b001/exe/hello
Hello<span class="w"> </span>World
</code></pre></div>

<h3>模仿编译而不产生可执行文件</h3>
<p>假设你不想编译程序并产生一个实际的二进制文件，但你确实想看到这个过程中的所有步骤。你可以通过使用 <code>-n</code> 这个构建选项来做到这一点，该选项会打印出通常的执行步骤，而不会实际创建二进制文件。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>-n<span class="w"> </span>hello.go
</code></pre></div>

<h3>保存临时目录</h3>
<p>很多工作都发生在 <code>/tmp</code> 工作目录中，一旦可执行文件被创建和运行，它就会被删除。但是如果你想看看哪些文件是在编译过程中创建的呢？Go 提供了一个 <code>-work</code> 选项，它可以在编译程序时使用。<code>-work</code> 选项除了运行程序外，还打印了工作目录的路径，但它并不会在这之后删除工作目录，所以你可以切换到该目录，检查在编译过程中创建的所有文件。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>run<span class="w"> </span>-work<span class="w"> </span>hello.go
<span class="nv">WORK</span><span class="o">=</span>/tmp/go-build3209320645
Hello<span class="w"> </span>World

$<span class="w"> </span>find<span class="w"> </span>/tmp/go-build3209320645
/tmp/go-build3209320645
/tmp/go-build3209320645/b001
/tmp/go-build3209320645/b001/importcfg.link
/tmp/go-build3209320645/b001/exe
/tmp/go-build3209320645/b001/exe/hello

$<span class="w"> </span>/tmp/go-build3209320645/b001/exe/hello
Hello<span class="w"> </span>World
</code></pre></div>

<h3>其他编译选项</h3>
<p>如果说，你想手动编译程序，而不是使用 Go 的 <code>build</code> 和 <code>run</code> 这两个方便的命令，最后得到一个可以直接由你的操作系统（这里指 Linux）运行的可执行文件。那么，你该怎么做呢？这个过程可以分为两部分：编译和链接。你可以使用 <code>tool</code> 选项来看看它是如何工作的。</p>
<p>首先，使用 <code>tool compile</code> 命令产生结果的 <code>ar</code> 归档文件，它包含了 <code>.o</code> 中间文件。接下来，对这个 <code>hello.o</code> 文件执行 <code>tool link</code> 命令，产生最终的可执行文件，然后你就可以运行它了。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>tool<span class="w"> </span>compile<span class="w"> </span>hello.go

$<span class="w"> </span>file<span class="w"> </span>hello.o
hello.o:<span class="w"> </span>current<span class="w"> </span>ar<span class="w"> </span>archive

$<span class="w"> </span>ar<span class="w"> </span>t<span class="w"> </span>hello.o
__.PKGDEF
_go_.o

$<span class="w"> </span>go<span class="w"> </span>tool<span class="w"> </span>link<span class="w"> </span>-o<span class="w"> </span>hello<span class="w"> </span>hello.o

$<span class="w"> </span>file<span class="w"> </span>hello
hello:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>executable,<span class="w"> </span>x86-64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>statically<span class="w"> </span>linked,<span class="w"> </span>not<span class="w"> </span>stripped

$<span class="w"> </span>./hello
Hello<span class="w"> </span>World
</code></pre></div>

<p>如果你想进一步查看基于 <code>hello.o</code> 文件产生可执行文件的链接过程，你可以使用 <code>-v</code> 选项，它会搜索每个 Go 可执行文件中包含的 <code>runtime.a</code> 文件。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>tool<span class="w"> </span>link<span class="w"> </span>-v<span class="w"> </span>-o<span class="w"> </span>hello<span class="w"> </span>hello.o
<span class="nv">HEADER</span><span class="w"> </span><span class="o">=</span><span class="w"> </span>-H5<span class="w"> </span>-T0x401000<span class="w"> </span>-R0x1000
searching<span class="w"> </span><span class="k">for</span><span class="w"> </span>runtime.a<span class="w"> </span><span class="k">in</span><span class="w"> </span>/usr/lib/golang/pkg/linux_amd64/runtime.a
<span class="m">82052</span><span class="w"> </span>symbols,<span class="w"> </span><span class="m">18774</span><span class="w"> </span>reachable
<span class="w">        </span><span class="m">1</span><span class="w"> </span>package<span class="w"> </span>symbols,<span class="w"> </span><span class="m">1106</span><span class="w"> </span>hashed<span class="w"> </span>symbols,<span class="w"> </span><span class="m">77185</span><span class="w"> </span>non-package<span class="w"> </span>symbols,<span class="w"> </span><span class="m">3760</span><span class="w"> </span>external<span class="w"> </span>symbols
<span class="m">81968</span><span class="w"> </span>liveness<span class="w"> </span>data
</code></pre></div>

<h3>交叉编译选项</h3>
<p>现在我已经解释了 Go 程序的编译过程，接下来，我将演示 Go 如何通过在实际的 <code>build</code> 命令之前提供 <code>GOOS</code> 和 <code>GOARCH</code> 这两个环境变量，来允许你构建针对不同硬件架构和操作系统的可执行文件。</p>
<p>这有什么用呢？举个例子，你会发现为 ARM（arch64）架构制作的可执行文件不能在英特尔（x86_64）架构上运行，而且会产生一个 Exec 格式错误。</p>
<p>下面的这些选项使得生成跨平台的二进制文件变得小菜一碟：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nv">GOOS</span><span class="o">=</span>linux<span class="w"> </span><span class="nv">GOARCH</span><span class="o">=</span>arm64<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>hello.go

$<span class="w"> </span>file<span class="w"> </span>./hello
./hello:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>executable,<span class="w"> </span>ARM<span class="w"> </span>aarch64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>statically<span class="w"> </span>linked,<span class="w"> </span>not<span class="w"> </span>stripped

$<span class="w"> </span>./hello
bash:<span class="w"> </span>./hello:<span class="w"> </span>cannot<span class="w"> </span>execute<span class="w"> </span>binary<span class="w"> </span>file:<span class="w"> </span>Exec<span class="w"> </span>format<span class="w"> </span>error

$<span class="w"> </span>uname<span class="w"> </span>-m
x86_64
</code></pre></div>

<p>你可以阅读我之前的博文，以更多了解我在 <a href="https://opensource.com/article/21/1/go-cross-compiling">使用 Go 进行交叉编译</a> 方面的经验。</p>
<h3>查看底层汇编指令</h3>
<p>源代码并不会直接转换为可执行文件，尽管它生成了一种中间汇编格式，然后最终被组装为可执行文件。在 Go 中，这被映射为一种中间汇编格式，而不是底层硬件汇编指令。</p>
<p>要查看这个中间汇编格式，请在使用 <code>build</code> 命令时，提供 <code>-gcflags</code> 选项，后面跟着 <code>-S</code>。这个命令将会显示使用到的汇编指令：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>-gcflags<span class="o">=</span><span class="s2">&quot;-S&quot;</span><span class="w"> </span>hello.go
<span class="c1"># command-line-arguments</span>
<span class="s2">&quot;&quot;</span>.main<span class="w"> </span>STEXT<span class="w"> </span><span class="nv">size</span><span class="o">=</span><span class="m">138</span><span class="w"> </span><span class="nv">args</span><span class="o">=</span>0x0<span class="w"> </span><span class="nv">locals</span><span class="o">=</span>0x58<span class="w"> </span><span class="nv">funcid</span><span class="o">=</span>0x0
<span class="w">        </span>0x0000<span class="w"> </span><span class="m">00000</span><span class="w"> </span><span class="o">(</span>/test/hello.go:5<span class="o">)</span><span class="w"> </span>TEXT<span class="w">    </span><span class="s2">&quot;&quot;</span>.main<span class="o">(</span>SB<span class="o">)</span>,<span class="w"> </span>ABIInternal,<span class="w"> </span><span class="nv">$88</span>-0
<span class="w">        </span>0x0000<span class="w"> </span><span class="m">00000</span><span class="w"> </span><span class="o">(</span>/test/hello.go:5<span class="o">)</span><span class="w"> </span>MOVQ<span class="w">    </span><span class="o">(</span>TLS<span class="o">)</span>,<span class="w"> </span>CX
<span class="w">        </span>0x0009<span class="w"> </span><span class="m">00009</span><span class="w"> </span><span class="o">(</span>/test/hello.go:5<span class="o">)</span><span class="w"> </span>CMPQ<span class="w">    </span>SP,<span class="w"> </span><span class="m">16</span><span class="o">(</span>CX<span class="o">)</span>
<span class="w">        </span>0x000d<span class="w"> </span><span class="m">00013</span><span class="w"> </span><span class="o">(</span>/test/hello.go:5<span class="o">)</span><span class="w"> </span>PCDATA<span class="w">  </span><span class="nv">$0</span>,<span class="w"> </span><span class="nv">$-</span><span class="m">2</span>
<span class="w">        </span>0x000d<span class="w"> </span><span class="m">00013</span><span class="w"> </span><span class="o">(</span>/test/hello.go:5<span class="o">)</span><span class="w"> </span>JLS<span class="w">     </span><span class="m">128</span>

&lt;&lt;<span class="w"> </span>snip<span class="w"> </span>&gt;&gt;
</code></pre></div>

<p>你也可以使用 <code>objdump -s</code> 选项，来查看已经编译好的可执行程序的汇编指令，就像下面这样：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>ls
hello<span class="w">  </span>hello.go

$<span class="w"> </span>go<span class="w"> </span>tool<span class="w"> </span>objdump<span class="w"> </span>-s<span class="w"> </span>main.main<span class="w"> </span>hello
TEXT<span class="w"> </span>main.main<span class="o">(</span>SB<span class="o">)</span><span class="w"> </span>/test/hello.go
<span class="w">  </span>hello.go:5<span class="w">            </span>0x4975a0<span class="w">                </span>64488b0c25f8ffffff<span class="w">      </span>MOVQ<span class="w"> </span>FS:0xfffffff8,<span class="w"> </span>CX<span class="w">                  </span>
<span class="w">  </span>hello.go:5<span class="w">            </span>0x4975a9<span class="w">                </span>483b6110<span class="w">                </span>CMPQ<span class="w"> </span>0x10<span class="o">(</span>CX<span class="o">)</span>,<span class="w"> </span>SP<span class="w">                       </span>
<span class="w">  </span>hello.go:5<span class="w">            </span>0x4975ad<span class="w">                </span><span class="m">7671</span><span class="w">                    </span>JBE<span class="w"> </span>0x497620<span class="w">                            </span>
<span class="w">  </span>hello.go:5<span class="w">            </span>0x4975af<span class="w">                </span>4883ec58<span class="w">                </span>SUBQ<span class="w"> </span><span class="nv">$0</span>x58,<span class="w"> </span>SP<span class="w">                          </span>
<span class="w">  </span>hello.go:6<span class="w">            </span>0x4975d8<span class="w">                </span><span class="m">4889442448</span><span class="w">              </span>MOVQ<span class="w"> </span>AX,<span class="w"> </span>0x48<span class="o">(</span>SP<span class="o">)</span><span class="w">                       </span>

&lt;&lt;<span class="w"> </span>snip<span class="w"> </span>&gt;&gt;
</code></pre></div>

<h3>分离二进制文件以减少其大小</h3>
<p>Go 的二进制文件通常比较大。例如, 一个简单的 “Hello World” 程序将会产生一个 1.9M 大小的二进制文件。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>hello.go
$
$<span class="w"> </span>du<span class="w"> </span>-sh<span class="w"> </span>hello
<span class="m">1</span>.9M<span class="w">    </span>hello
$
$<span class="w"> </span>file<span class="w"> </span>hello
hello:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>executable,<span class="w"> </span>x86-64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>statically<span class="w"> </span>linked,<span class="w"> </span>not<span class="w"> </span>stripped
$
</code></pre></div>

<p>为了减少生成的二进制文件的大小，你可以分离执行过程中不需要的信息。使用 <code>-ldflags</code> 和 <code>-s -w</code> 选项可以使生成的二进制文件略微变小为 1.3M。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span>build<span class="w"> </span>-ldflags<span class="o">=</span><span class="s2">&quot;-s -w&quot;</span><span class="w"> </span>hello.go
$
$<span class="w"> </span>du<span class="w"> </span>-sh<span class="w"> </span>hello
<span class="m">1</span>.3M<span class="w">    </span>hello
$
$<span class="w"> </span>file<span class="w"> </span>hello
hello:<span class="w"> </span>ELF<span class="w"> </span><span class="m">64</span>-bit<span class="w"> </span>LSB<span class="w"> </span>executable,<span class="w"> </span>x86-64,<span class="w"> </span>version<span class="w"> </span><span class="m">1</span><span class="w"> </span><span class="o">(</span>SYSV<span class="o">)</span>,<span class="w"> </span>statically<span class="w"> </span>linked,<span class="w"> </span>stripped
$
</code></pre></div>

<h3>总结</h3>
<p>我希望这篇文章向你介绍了一些方便的 Go 编译选项，同时帮助了你更好地理解 Go 编译过程。关于构建过程的其他信息和其他有趣的选项，请参考 Go 命令帮助：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>go<span class="w"> </span><span class="nb">help</span><span class="w"> </span>build
</code></pre></div>

<p><em>题图由 <a href="https://pixabay.com/zh/users/ashrafchemban-11099338/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3916956">Ashraf Chemban</a> 在 <a href="https://pixabay.com/zh/?utm_source=link-attribution&amp;utm_medium=referral&amp;utm_campaign=image&amp;utm_content=3916956">Pixabay</a> 上发布。</em> </p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>