<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>在 Linux 上使用 Checksec 识别二进制文件的安全属性</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Gaurav Kamathe 这篇文章能让你了解如何使用 Checksec ，来识别一个可执行文件的安全属性，了解安全属性的含义，并知道如何使用它们 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li class="active"><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2022/11/zai-linux-shang-shi-yong-checksec-shi-bie-er-jin-zhi-wen-jian-de-an-quan-shu-xing.html" rel="bookmark"
           title="Permalink to 在 Linux 上使用 Checksec 识别二进制文件的安全属性">在 Linux 上使用 Checksec 识别二进制文件的安全属性</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2022-11-18T09:57:08+01:00">
                Published: Fri 18 November 2022
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ji-zhu">技术</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Gaurav Kamathe</p>
<blockquote>
<p>这篇文章能让你了解如何使用 Checksec ，来识别一个可执行文件的安全属性，了解安全属性的含义，并知道如何使用它们。</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/202211/18/095702dzvm482460vnrv6y.jpg"></p>
<p>编译源代码会生成一个二进制文件（LCTT 译注：即 <code>.o</code> 文件）。在编译期间，你可以向 <code>gcc</code> 编译器提供 <ruby> 标志 <rt>  flags </rt></ruby>，以启用或禁用二进制文件的某些属性，这些属性与安全性相关。</p>
<p>Checksec 是一个漂亮的小工具，同时它也是一个 shell 脚本。Checksec 可以识别编译时构建到二进制文件中的安全属性。编译器可能会默认启用一些安全属性，你也可以提供特定的标志，来启用其他的安全属性。</p>
<p>本文将介绍如何使用 Checksec ，来识别二进制文件的安全属性，包括：</p>
<ol>
<li>Checksec 在查找有关安全属性的信息时，使用了什么<strong>底层的命令</strong></li>
<li>在将源代码编译成二进制文件时，如何使用<ruby> GNU 编译器套件 <rt>  GNU Compiler Collection </rt></ruby>（即 GCC）来<strong>启用安全属性</strong>。</li>
</ol>
<h3>安装 checksec</h3>
<p>要在 Fedora 和其他基于 RPM 的 Linux 系统上，安装 Checksec，请使用以下命令：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>dnf<span class="w"> </span>install<span class="w"> </span>checksec
</code></pre></div>

<p>对于基于 Debian 的 Linux 发行版，使用对应的 <code>apt</code> 命令，来安装 Checksec。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>checksec
</code></pre></div>

<h3>shell 脚本</h3>
<p>在安装完 Checksec 后，能够发现 Checksec 是一个<strong>单文件</strong>的 shell 脚本，它位于 <code>/usr/bin/checksec</code>，并且这个文件挺大的。Checksec 的一个优点是你可以通过快速通读这个 shell 脚本，从而了解 Checksec 的执行原理、明白所有能查找有关二进制文件或可执行文件的安全属性的<strong>系统命令</strong>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>file<span class="w"> </span>/usr/bin/checksec
/usr/bin/checksec:<span class="w"> </span>Bourne-Again<span class="w"> </span>shell<span class="w"> </span>script,<span class="w"> </span>ASCII<span class="w"> </span>text<span class="w"> </span>executable,<span class="w"> </span>with<span class="w"> </span>very<span class="w"> </span>long<span class="w"> </span>lines

$<span class="w"> </span>wc<span class="w"> </span>-l<span class="w"> </span>/usr/bin/checksec
<span class="m">2111</span><span class="w"> </span>/usr/bin/checksec
</code></pre></div>

<p>以下的命令展示了如何对你每天都会使用的：<code>ls</code> 命令的二进制文件运行 Checksec。Checksec 命令的格式是：<code>checksec --file=</code>，后面再跟上二进制文件的绝对路径：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>/usr/bin/ls
RELRO<span class="w">           </span>STACK<span class="w"> </span>CANARY<span class="w">      </span>NX<span class="w">            </span>PIE<span class="w">             </span>RPATH<span class="w">      </span>RUNPATH<span class="w">      </span>Symbols<span class="w">         </span>FORTIFY<span class="w"> </span>Fortified<span class="w">       </span>Fortifiable<span class="w">     </span>FILE
Full<span class="w"> </span>RELRO<span class="w">      </span>Canary<span class="w"> </span>found<span class="w">      </span>NX<span class="w"> </span>enabled<span class="w">    </span>PIE<span class="w"> </span>enabled<span class="w">     </span>No<span class="w"> </span>RPATH<span class="w">   </span>No<span class="w"> </span>RUNPATH<span class="w">   </span>No<span class="w"> </span>Symbols<span class="w">        </span>Yes<span class="w">   </span><span class="m">5</span><span class="w">       </span><span class="m">17</span><span class="w">              </span>/usr/bin/ls
</code></pre></div>

<p>当你在终端中对某个二进制文件运行 Checksec 时，你会看到安全属性有颜色上的区分，显示什么是好的安全属性（绿色），什么可能不是好的安全属性（红色）。我在这里说 <strong>“可能”</strong> 是因为即使有些安全属性是红色的，也不一定意味着这个二进制文件很糟糕，它可能只是表明发行版供应商在编译二进制文件时做了一些权衡，从而舍弃了部分安全属性。</p>
<p>Checksec 输出的第一行提供了二进制文件的各种安全属性，例如 <code>RELRO</code>、<code>STACK CANARY</code>、<code>NX</code> 等（我将在后文进行详细解释）。第二行打印出给定二进制文件（本例中为 <code>ls</code>）在这些安全属性的状态（例如，<code>NX enabled</code> 表示为堆栈中的数据没有执行权限）。</p>
<h3>示例二进制文件</h3>
<p>在本文中，我将使用以下的 “hello world” 程序作为示例二进制文件。</p>
<div class="highlight"><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&lt;stdio.h&gt;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Hello World</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>请注意，在编译源文件 <code>hello.c</code> 的时候，我没有给 <code>gcc</code> 提供任何额外的标志：</p>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="n">gcc</span><span class="w"> </span><span class="n">hello</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">hello</span>

<span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">014</span><span class="n">b8966ba43e3ae47fab5acae051e208ec9074c</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">stripped</span>

<span class="err">$</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">hello</span>
<span class="n">Hello</span><span class="w"> </span><span class="n">World</span>
</code></pre></div>

<p>使用 Checksec 运行二进制文件 <code>hello</code>，打印的某些安全属性的状态，与上面的 <code>ls</code> 二进制文件的结果不同（在你的屏幕上，某些属性可能显示为红色）：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello
RELRO<span class="w">           </span>STACK<span class="w"> </span>CANARY<span class="w">      </span>NX<span class="w">            </span>PIE<span class="w">             </span>RPATH<span class="w">      </span>RUNPATH<span class="w">      </span>Symbols<span class="w">         </span>FORTIFY<span class="w"> </span>Fortified<span class="w">       </span>Fortifiable<span class="w">     </span>FILE
Partial<span class="w"> </span>RELRO<span class="w">   </span>No<span class="w"> </span>canary<span class="w"> </span>found<span class="w">   </span>NX<span class="w"> </span>enabled<span class="w">    </span>No<span class="w"> </span>PIE<span class="w">          </span>No<span class="w"> </span>RPATH<span class="w">   </span>No<span class="w"> </span>RUNPATH<span class="w">   </span><span class="m">85</span><span class="o">)</span><span class="w"> </span>Symbols<span class="w">       </span>No<span class="w">    </span><span class="m">0</span><span class="w">       </span><span class="m">0</span>./hello
$
</code></pre></div>

<p>（LCTT 译注：在我的 Ubuntu 22.04 虚拟机，使用 11.3.0 版本的 <code>gcc</code>，结果与上述不太相同，利用默认参数进行编译，会得到 RELRO、PIE、NX 保护是全开的情况。）</p>
<h3>更改 Checksec 的输出格式</h3>
<p>Checksec 允许自定义各种输出格式，你可以使用 <code>--output</code> 来自定义输出格式。我将选择的输出格式是 JSON 格式，并将输出结果通过管道传输到 <code>jq</code> 实用程序，来得到漂亮的打印。</p>
<p>接下来，确保你已安装好了 <a href="https://stedolan.github.io/jq/download/">jq</a>，因为本教程会使用 <code>jq</code> 从 Checksec 的输出结果中，用 <code>grep</code> 来快速得到某一特定的安全属性状态，并报告该安全属性是否启动（启动为 <code>yes</code>，未启动为 <code>no</code>）：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq
<span class="o">{</span>
<span class="w">  </span><span class="s2">&quot;hello&quot;</span>:<span class="w"> </span><span class="o">{</span>
<span class="w">    </span><span class="s2">&quot;relro&quot;</span>:<span class="w"> </span><span class="s2">&quot;partial&quot;</span>,
<span class="w">    </span><span class="s2">&quot;canary&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
<span class="w">    </span><span class="s2">&quot;nx&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
<span class="w">    </span><span class="s2">&quot;pie&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
<span class="w">    </span><span class="s2">&quot;rpath&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
<span class="w">    </span><span class="s2">&quot;runpath&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
<span class="w">    </span><span class="s2">&quot;symbols&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortify_source&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortified&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortify-able&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>
<span class="w">  </span><span class="o">}</span>
<span class="o">}</span>
</code></pre></div>

<h3>看一看所有的安全属性</h3>
<p>上面的二进制文件 <code>hello</code> 包括几个安全属性。我将该二进制文件与 <code>ls</code> 的二进制文件进行比较，以检查启用的安全属性有何不同，并解释 Checksec 是如何找到此信息。</p>
<h4>1、符号（Symbol）</h4>
<p>我先从简单的讲起。在编译期间，某些 <ruby> 符号 <rt>  symbols </rt></ruby>包含在二进制文件中，这些符号主要用作于调试。开发软件时，需要用到这些符号，来调试和修复错误。</p>
<p>这些符号通常会从供用户普遍使用的最终二进制文件中删除。删除这些符号不会影响到二进制文件的执行。删除符号通常是为了节省空间，因为一旦符号被删除了，二进制文件就会稍微小一些。在闭源或专有软件中，符号通常都会被删除，因为把这些符号放在二进制文件中，可以很容易地推断出软件的内部工作原理。</p>
<p>根据 Checksec 的结果，在二进制文件 <code>hello</code> 中有符号，但在 <code>ls</code> 的二进制文件中不会有符号。同样地，你还可以用 <code>file</code> 命令，来找到符号的信息，在二进制文件 <code>hello</code> 的输出结果的最后，看到 <code>not stripped</code>，表明二进制文件 <code>hello</code> 有符号：</p>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="n">checksec</span><span class="w"> </span><span class="o">--</span><span class="k">file</span><span class="o">=/</span><span class="n">bin</span><span class="o">/</span><span class="n">ls</span><span class="w"> </span><span class="o">--</span><span class="k">output</span><span class="o">=</span><span class="n">json</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">jq</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="n">symbols</span>
<span class="w">    </span><span class="ss">&quot;symbols&quot;</span><span class="err">:</span><span class="w"> </span><span class="ss">&quot;no&quot;</span><span class="p">,</span>

<span class="err">$</span><span class="w"> </span><span class="n">checksec</span><span class="w"> </span><span class="o">--</span><span class="k">file</span><span class="o">=</span><span class="p">.</span><span class="o">/</span><span class="n">hello</span><span class="w"> </span><span class="o">--</span><span class="k">output</span><span class="o">=</span><span class="n">json</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">jq</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="n">symbols</span>
<span class="w">    </span><span class="ss">&quot;symbols&quot;</span><span class="err">:</span><span class="w"> </span><span class="ss">&quot;yes&quot;</span><span class="p">,</span>

<span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">014</span><span class="n">b8966ba43e3ae47fab5acae051e208ec9074c</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">stripped</span>
</code></pre></div>

<p>Checksec 是如何找到符号的信息呢？Checksec 提供了一个方便的 <code>--debug</code> 选项，来显示运行了哪些函数。因此，运行以下的命令，会显示在 shell 脚本中运行了哪些函数：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--debug<span class="w"> </span>--file<span class="o">=</span>./hello
</code></pre></div>

<p>在本教程中，我试图寻找 Checksec 查找安全属性信息时，使用了什么<strong>底层命令</strong>。由于 Checksec 是一个 shell 脚本，因此你始终可以使用 Bash 功能。以下的命令将输出从 shell 脚本中运行的每个命令：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>bash<span class="w"> </span>-x<span class="w"> </span>/usr/bin/checksec<span class="w"> </span>--file<span class="o">=</span>./hello
</code></pre></div>

<p>如果你滚动浏览上述的输出结果的话，你会看到 <code>echo_message</code> 后面有各个安全属性的类别。以下显示了 Checksec 检测二进制文件是否包含符号时，运行的底层命令：</p>
<div class="highlight"><pre><span></span><code>+ readelf -W --symbols ./hello
+ grep -q &#39;\\.symtab&#39;
+ echo_message &#39;\033[31m96) Symbols\t\033[m  &#39; Symbols, &#39; symbols=&quot;yes&quot;&#39; &#39;&quot;symbols&quot;:&quot;yes&quot;,&#39;
</code></pre></div>

<p>上面的输出显示，Checksec 利用 <code>readelf</code>，来读取二进制文件，并提供一个特殊 <code>--symbols</code> 标志，来列出二进制文件中的所有符号。然后它会查找一个特殊值：<code>.symtab</code>，它提供了所能找到的条目的计数（即符号的个数）。你可以在上面编译的测试二进制文件 <code>hello</code> 上，尝试以下命令，得到与 Checksec 查看二进制文件类似的符号信息：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>--symbols<span class="w"> </span>./hello
$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>--symbols<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>symtab
</code></pre></div>

<p>（LCTT 译注：也可以通过直接查看 <code>/usr/bin/checksec</code> 下的 Checksec 源文件。）</p>
<h5>如何删除符号</h5>
<p>你可以在编译后或编译时删除符号。</p>
<ul>
<li><strong>编译后：</strong> 在编译后，你可以使用 <code>strip</code>，手动地来删除二进制文件的符号。删除后，使用 <code>file</code> 命令，来检验是否还有符号，现在显示 <code>stripped</code>，表明二进制文件 <code>hello</code> 无符号了：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="n">gcc</span><span class="w"> </span><span class="n">hello</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">hello</span>
<span class="err">$</span>
<span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">322037496</span><span class="n">cf6a2029dcdcf68649a4ebc63780138</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">stripped</span>
<span class="err">$</span>
<span class="err">$</span><span class="w"> </span><span class="n">strip</span><span class="w"> </span><span class="n">hello</span>
<span class="err">$</span>
<span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">322037496</span><span class="n">cf6a2029dcdcf68649a4ebc63780138</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="n">stripped</span>
<span class="err">$</span><span class="w"> </span>
</code></pre></div>

<ul>
<li><strong>编译时：</strong> 你也可以在编译时，用 <code>-s</code> 参数让 gcc 编译器帮你自动地删除符号：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="n">gcc</span><span class="w"> </span><span class="o">-</span><span class="n">s</span><span class="w"> </span><span class="n">hello</span><span class="p">.</span><span class="n">c</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">hello</span>
<span class="err">$</span>
<span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">247</span><span class="n">de82a8ad84e7d8f20751ce79ea9e0cf4bd263</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="n">stripped</span>
<span class="err">$</span>
</code></pre></div>

<p>重新运行 Checksec，你可以看到现在二进制文件 <code>hello</code> 的 <code>symbols</code> 这一属性的值是<code>no</code>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>symbols
<span class="w">    </span><span class="s2">&quot;symbols&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
$
</code></pre></div>

<h4>2、Canary（堆栈溢出哨兵）</h4>
<p>Canary 是放置在缓冲区和 <ruby> 栈 <rt>  stack </rt></ruby> 上的控制数据之间的已知值，它用于监视缓冲区是否溢出。当应用程序执行时，会为其分配两种内存，其中之一就是 <em>栈</em>。栈是一个具有两个操作的数据结构：第一个操作 <code>push</code>，将数据压入堆栈；第二个操作 <code>pop</code>，以后进先出的顺序从栈中弹出数据。恶意的输入可能会导致栈溢出，或使用特制的输入破坏栈，并导致程序崩溃：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>/bin/ls<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>canary
<span class="w">    </span><span class="s2">&quot;canary&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
$
$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>canary
<span class="w">    </span><span class="s2">&quot;canary&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
$
</code></pre></div>

<p>Checksec 是如何确定二进制文件是否启用了 Canary 的呢？使用上述同样的方法，得到 Checksec 在检测二进制文件是否启用 Canary 时，运行的底层命令：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-s<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-E<span class="w"> </span><span class="s1">&#39;__stack_chk_fail|__intel_security_cookie&#39;</span>
</code></pre></div>

<h5>启用 Canary</h5>
<p>为了防止栈溢出等情况，编译器提供了 <code>-stack-protector-all</code> 标志，它向二进制文件添加了额外的代码，来检查缓冲区是否溢出：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>gcc<span class="w"> </span>-fstack-protector-all<span class="w"> </span>hello.c<span class="w"> </span>-o<span class="w"> </span>hello

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>canary
<span class="w">    </span><span class="s2">&quot;canary&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
</code></pre></div>

<p>Checksec 显示 Canary 属性现已启用。你还可以通过以下方式，来验证这一点：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-s<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-E<span class="w"> </span><span class="s1">&#39;__stack_chk_fail|__intel_security_cookie&#39;</span>
<span class="w">     </span><span class="m">2</span>:<span class="w"> </span><span class="m">0000000000000000</span><span class="w">     </span><span class="m">0</span><span class="w"> </span>FUNC<span class="w">    </span>GLOBAL<span class="w"> </span>DEFAULT<span class="w">  </span>UND<span class="w"> </span>__stack_chk_fail@GLIBC_2.4<span class="w"> </span><span class="o">(</span><span class="m">3</span><span class="o">)</span>
<span class="w">    </span><span class="m">83</span>:<span class="w"> </span><span class="m">0000000000000000</span><span class="w">     </span><span class="m">0</span><span class="w"> </span>FUNC<span class="w">    </span>GLOBAL<span class="w"> </span>DEFAULT<span class="w">  </span>UND<span class="w"> </span>__stack_chk_fail@@GLIBC_2.4
$
</code></pre></div>

<h4>3、位置无关可执行文件（PIE）</h4>
<p><ruby> 位置无关可执行文件 <rt>  Position-Independent Executable </rt></ruby>（PIE），顾名思义，它指的是放置在内存中某处执行的代码，不管其绝对地址的位置，即代码段、数据段地址随机化（ASLR）：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>/bin/ls<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>pie
<span class="w">    </span><span class="s2">&quot;pie&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>pie
<span class="w">    </span><span class="s2">&quot;pie&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
</code></pre></div>

<p>通常，PIE 仅对 <ruby> 库 <rt>  libraries </rt></ruby>启用，并不对独立命令行程序启用 PIE。在下面的输出中，<code>hello</code> 显示为 <code>LSB executable</code>，而 <code>libc</code> 标准库（<code>.so</code>） 文件被标记为 <code>LSB shared object</code>：</p>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">014</span><span class="n">b8966ba43e3ae47fab5acae051e208ec9074c</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">stripped</span>

<span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libc</span><span class="o">-</span><span class="mf">2.32</span><span class="p">.</span><span class="n">so</span>
<span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">libc</span><span class="o">-</span><span class="mf">2.32</span><span class="p">.</span><span class="nl">so</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">shared</span><span class="w"> </span><span class="k">object</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="mi">4</span><span class="n">a7fb374097fb927fb93d35ef98ba89262d0c4a4</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">stripped</span>
</code></pre></div>

<p>Checksec 查找是否启用 PIE 的底层命令如下：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-h<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>EXEC
<span class="w">  </span>Type:<span class="w">                              </span>EXEC<span class="w"> </span><span class="o">(</span>Executable<span class="w"> </span>file<span class="o">)</span>
</code></pre></div>

<p>如果你在共享库上尝试相同的命令，你将看到 <code>DYN</code>，而不是 <code>EXEC</code>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-h<span class="w"> </span>/lib64/libc-2.32.so<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>DYN
<span class="w">  </span>Type:<span class="w">                              </span>DYN<span class="w"> </span><span class="o">(</span>Shared<span class="w"> </span>object<span class="w"> </span>file<span class="o">)</span>
</code></pre></div>

<h5>启用 PIE</h5>
<p>要在测试程序 <code>hello.c</code> 上启用 PIE，请在编译时，使用以下命令：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>gcc<span class="w"> </span>-pie<span class="w"> </span>-fpie<span class="w"> </span>hello.c<span class="w"> </span>-o<span class="w"> </span>hello<span class="sb">`</span>
</code></pre></div>

<p>你可以使用 Checksec，来验证 PIE 是否已启用：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>pie
<span class="w">    </span><span class="s2">&quot;pie&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
$
</code></pre></div>

<p>现在，应该会显示为 “<ruby> PIE 可执行 <rt>  pie executable </rt></ruby>”，其类型从 <code>EXEC</code> 更改为 <code>DYN</code>：</p>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="k">file</span><span class="w"> </span><span class="n">hello</span>
<span class="nl">hello</span><span class="p">:</span><span class="w"> </span><span class="n">ELF</span><span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nc">bit</span><span class="w"> </span><span class="n">LSB</span><span class="w"> </span><span class="n">pie</span><span class="w"> </span><span class="n">executable</span><span class="p">,</span><span class="w"> </span><span class="n">x86</span><span class="o">-</span><span class="mi">64</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="p">(</span><span class="n">SYSV</span><span class="p">),</span><span class="w"> </span><span class="n">dynamically</span><span class="w"> </span><span class="n">linked</span><span class="p">,</span><span class="w"> </span><span class="n">interpreter</span><span class="w"> </span><span class="o">/</span><span class="n">lib64</span><span class="o">/</span><span class="n">ld</span><span class="o">-</span><span class="n">linux</span><span class="o">-</span><span class="n">x86</span><span class="o">-</span><span class="mf">64.</span><span class="n">so</span><span class="mf">.2</span><span class="p">,</span><span class="w"> </span><span class="n">BuildID</span><span class="o">[</span><span class="n">sha1</span><span class="o">]=</span><span class="n">bb039adf2530d97e02f534a94f0f668cd540f940</span><span class="p">,</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">GNU</span><span class="o">/</span><span class="n">Linux</span><span class="w"> </span><span class="mf">3.2.0</span><span class="p">,</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">stripped</span>

<span class="err">$</span><span class="w"> </span><span class="n">readelf</span><span class="w"> </span><span class="o">-</span><span class="n">W</span><span class="w"> </span><span class="o">-</span><span class="n">h</span><span class="w"> </span><span class="p">.</span><span class="o">/</span><span class="n">hello</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="n">DYN</span>
<span class="w">  </span><span class="nl">Type</span><span class="p">:</span><span class="w">                              </span><span class="n">DYN</span><span class="w"> </span><span class="p">(</span><span class="n">Shared</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">file</span><span class="p">)</span>
</code></pre></div>

<h4>4、NX（堆栈禁止执行）</h4>
<p>NX 代表 <ruby> 不可执行 <rt>  non-executable </rt></ruby>。它通常在 CPU 层面上启用，因此启用 NX 的操作系统可以将某些内存区域标记为不可执行。通常，缓冲区溢出漏洞将恶意代码放在堆栈上，然后尝试执行它。但是，让堆栈这些可写区域变得不可执行，可以防止这种攻击。在使用 <code>gcc</code> 对源程序进行编译时，默认启用此安全属性：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>/bin/ls<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>nx
<span class="w">    </span><span class="s2">&quot;nx&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>nx
<span class="w">    </span><span class="s2">&quot;nx&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
</code></pre></div>

<p>Checksec 使用以下底层命令，来确定是否启用了 NX。在尾部的 <code>RW</code> 表示堆栈是可读可写的；因为没有 <code>E</code>，所以堆栈是不可执行的：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-l<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>GNU_STACK
<span class="w">  </span>GNU_STACK<span class="w">      </span>0x000000<span class="w"> </span>0x0000000000000000<span class="w"> </span>0x0000000000000000<span class="w"> </span>0x000000<span class="w"> </span>0x000000<span class="w"> </span>RW<span class="w">  </span>0x10
</code></pre></div>

<h5>演示如何禁用 NX</h5>
<p>我们不建议禁用 NX，但你可以在编译程序时，使用 <code>-z execstack</code> 参数，来禁用 NX：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>gcc<span class="w"> </span>-z<span class="w"> </span>execstack<span class="w"> </span>hello.c<span class="w"> </span>-o<span class="w"> </span>hello

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>nx
<span class="w">    </span><span class="s2">&quot;nx&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
</code></pre></div>

<p>编译后，堆栈会变为可读可写可执行（<code>RWE</code>），允许在堆栈上的恶意代码执行：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-l<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>GNU_STACK
<span class="w">  </span>GNU_STACK<span class="w">      </span>0x000000<span class="w"> </span>0x0000000000000000<span class="w"> </span>0x0000000000000000<span class="w"> </span>0x000000<span class="w"> </span>0x000000<span class="w"> </span>RWE<span class="w"> </span>0x10
</code></pre></div>

<h4>5、RELRO（GOT 写保护）</h4>
<p>RELRO 代表 “<ruby> 重定位只读 <rt>  Relocation Read-Only </rt></ruby>”。可执行链接格式（ELF）二进制文件使用全局偏移表（GOT）来动态地解析函数。启用 RELRO 后，会设置二进制文件中的 GOT 表为只读，从而防止重定位攻击：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>/bin/ls<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>relro
<span class="w">    </span><span class="s2">&quot;relro&quot;</span>:<span class="w"> </span><span class="s2">&quot;full&quot;</span>,

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>relro
<span class="w">    </span><span class="s2">&quot;relro&quot;</span>:<span class="w"> </span><span class="s2">&quot;partial&quot;</span>,
</code></pre></div>

<p>Checksec 使用以下底层命令，来查找是否启用 RELRO。在二进制文件 <code>hello</code> 仅启用了 RELRO 属性中的一个属性，因此，在 Checksec 验证时，显示 <code>partial</code>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-l<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>GNU_RELRO
<span class="w">  </span>GNU_RELRO<span class="w">      </span>0x002e10<span class="w"> </span>0x0000000000403e10<span class="w"> </span>0x0000000000403e10<span class="w"> </span>0x0001f0<span class="w"> </span>0x0001f0<span class="w"> </span>R<span class="w">   </span>0x1

$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-d<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>BIND_NOW
</code></pre></div>

<h5>启用全 RELRO</h5>
<p>要启用全 RELRO，请在 <code>gcc</code> 编译时，使用以下命令行参数：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>gcc<span class="w"> </span>-Wl,-z,relro,-z,now<span class="w"> </span>hello.c<span class="w"> </span>-o<span class="w"> </span>hello

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>relro
<span class="w">    </span><span class="s2">&quot;relro&quot;</span>:<span class="w"> </span><span class="s2">&quot;full&quot;</span>,
</code></pre></div>

<p>现在， RELRO 中的第二个属性也被启用，使程序变成全 RELRO：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-l<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>GNU_RELRO
<span class="w">  </span>GNU_RELRO<span class="w">      </span>0x002dd0<span class="w"> </span>0x0000000000403dd0<span class="w"> </span>0x0000000000403dd0<span class="w"> </span>0x000230<span class="w"> </span>0x000230<span class="w"> </span>R<span class="w">   </span>0x1

$<span class="w"> </span>readelf<span class="w"> </span>-W<span class="w"> </span>-d<span class="w"> </span>./hello<span class="w"> </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>BIND_NOW
<span class="w"> </span>0x0000000000000018<span class="w"> </span><span class="o">(</span>BIND_NOW<span class="o">)</span><span class="w">       </span>
</code></pre></div>

<h4>6、Fortify</h4>
<p>Fortify 是另一个安全属性，但它超出了本文的范围。Checksec 是如何在二进制文件中验证 Fortify，以及如何在 <code>gcc</code> 编译时启用 Fortify，作为你需要解决的课后练习。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>/bin/ls<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w">  </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>forti
<span class="w">    </span><span class="s2">&quot;fortify_source&quot;</span>:<span class="w"> </span><span class="s2">&quot;yes&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortified&quot;</span>:<span class="w"> </span><span class="s2">&quot;5&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortify-able&quot;</span>:<span class="w"> </span><span class="s2">&quot;17&quot;</span>

$<span class="w"> </span>checksec<span class="w"> </span>--file<span class="o">=</span>./hello<span class="w"> </span>--output<span class="o">=</span>json<span class="w"> </span><span class="p">|</span><span class="w"> </span>jq<span class="w">  </span><span class="p">|</span><span class="w"> </span>grep<span class="w"> </span>-i<span class="w"> </span>forti
<span class="w">    </span><span class="s2">&quot;fortify_source&quot;</span>:<span class="w"> </span><span class="s2">&quot;no&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortified&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>,
<span class="w">    </span><span class="s2">&quot;fortify-able&quot;</span>:<span class="w"> </span><span class="s2">&quot;0&quot;</span>
</code></pre></div>

<h3>其他的 Checksec 功能</h3>
<p>关于安全性的话题是永无止境的，不可能在本文涵盖所有关于安全性的内容，但我还想提一下 Checksec 命令的一些其他功能，这些功能也很好用。</p>
<h4>对多个二进制文件运行 Checksec</h4>
<p>你不必对每个二进制文件都进行一次 Checksec。相反，你可以提供多个二进制文件所在的目录路径，Checksec 将一次性为你验证所有文件：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--dir<span class="o">=</span>/usr
</code></pre></div>

<h4>对进程运行 Checksec</h4>
<p>Checksec 除了能检查二进制文件的安全属性，Checksec 还能对程序起作用。以下的命令用于查找你系统上所有正在运行的程序的安全属性。如果你希望 Checksec 检查所有正在运行的进程，可以使用 <code>--proc-all</code>，或者你也可以使用进程名称，选择特定的进程进行检查：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--proc-all

$<span class="w"> </span>checksec<span class="w"> </span>--proc<span class="o">=</span>bash
</code></pre></div>

<h4>对内核运行 Checksec</h4>
<p>除了本文介绍的用 Checksec 检查用户态应用程序的安全属性之外，你还可以使用它来检查系统内置的 <ruby> 内核属性 <rt>  kernel properties </rt></ruby>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>checksec<span class="w"> </span>--kernel
</code></pre></div>

<h3>快来试一试 Checksec 吧</h3>
<p>Checksec 是一个能了解哪些用户空间和内核的安全属性被启用的好方法。现在，你就可以开始使用 Checksec，来了解每个安全属性是什么，并明白启用每个安全属性的原因，以及它能阻止的攻击类型。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>