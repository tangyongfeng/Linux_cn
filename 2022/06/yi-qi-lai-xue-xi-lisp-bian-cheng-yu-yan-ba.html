<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>一起来学习 Lisp 编程语言吧！</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Seth Kenlon 许多大型代码库中都有 Lisp 代码的身影，因此，熟悉一下这门语言是一个明智之举。 早在 1958 年，Lisp 就被发明出来了，它是 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2022/06/yi-qi-lai-xue-xi-lisp-bian-cheng-yu-yan-ba.html" rel="bookmark"
           title="Permalink to 一起来学习 Lisp 编程语言吧！">一起来学习 Lisp 编程语言吧！</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2022-06-24T12:40:00+02:00">
                Published: Fri 24 June 2022
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Seth Kenlon</p>
<blockquote>
<p>许多大型代码库中都有 Lisp 代码的身影，因此，熟悉一下这门语言是一个明智之举。</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/202206/24/124147v0loy4e3y0hneih8.jpg"></p>
<p>早在 1958 年，Lisp 就被发明出来了，它是世界上第二古老的计算机编程语言（LCTT 译注：最古老的编程语言是 Fortran，诞生于 1957 年）。它有许多现代的衍生品，包括 Common Lisp、Emacs Lisp（Elisp）、Clojure、Racket、Scheme、Fennel 和 GNU Guile 等。</p>
<p>那些喜欢思考编程语言的设计的人，往往都喜欢 Lisp，因为它的语法和数据有着相同的结构：Lisp 代码实际上是<ruby> 一个列表的列表 <rt>  a list of lists </rt></ruby>，它的名字其实是 “<ruby> 列表处理 <rt>  LISt Processing </rt></ruby>” 的简写。而那些喜欢思考编程语言的美学的人，往往都讨厌 Lisp，因为它经常使用括号来定义范围；事实上，编程界也有一个广为流传的笑话：Lisp 代表的其实是 <ruby> “大量烦人的多余括号” <rt>  Lots of Irritating Superfluous Parentheses </rt></ruby>。</p>
<p>不管你是喜欢还是讨厌 Lisp 的设计哲学，你都不得不承认，它都是一门有趣的语言，过去如此，现在亦然（这得归功于现代方言 Clojure 和 Guile）。你可能会惊讶于在任何特定行业的大代码库中潜伏着多少 Lisp 代码，因此，现在开始学习 Lisp，至少熟悉一下它，不失为一个好主意。</p>
<h3>安装 Lisp</h3>
<p>Lisp 有很多不同的实现。比较流行的开源版本有 <a href="http://sbcl.org">SBCL</a>、<a href="http://clisp.org">GNU Lisp</a> 和 <a href="https://www.gnu.org/software/gcl/">GNU Common Lisp</a>（GCL）。你可以使用发行版的包管理器安装它们中的任意一个，在本文中，我是用的是 <code>clisp</code>（LCTT 译注：也就是 GNU Lisp，一种 ANSI Common Lisp 的实现）。</p>
<p>以下是在不同的 Linux 发行版中安装 <code>clisp</code> 的步骤。</p>
<p>在 Fedora Linux 上，使用 <code>dnf</code>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>dnf<span class="w"> </span>install<span class="w"> </span>clisp
</code></pre></div>

<p>在 Debian 上，使用 <code>apt</code>：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>apt<span class="w"> </span>install<span class="w"> </span>clisp
</code></pre></div>

<p>在 macOS 上，使用 <a href="https://opensource.com/article/20/11/macports">MacPorts</a> 或者 <a href="https://opensource.com/article/20/6/homebrew-linux">Homebrew</a>：</p>
<div class="highlight"><pre><span></span><code># 使用 MacPorts
$ sudo port install clisp

# 使用 Homebrew
$ brew install clisp
</code></pre></div>

<p>在 Windows 上，你可以使用 <a href="https://cygwin.fandom.com/wiki/Clisp">clisp on Cygwin</a> 或者从 <a href="http://mirror.lagoon.nc/gnu/gcl/binaries/stable">gnu.org/software/gcl</a> 上下载 GCL 的二进制文件。</p>
<p>虽然我使用 <code>clisp</code> 命令来运行 Lisp 代码，但是本文中涉及到的大多数语法规则，对任何 Lisp 实现都是适用的。如果你选择使用一个不同的 Lisp 实现，除了用来运行 Lisp 代码的命令会和我不一样外（比如，你可能要用 <code>gcl</code> 或 <code>sbcl</code> 而不是 <code>clisp</code>），其它的所有东西都是相同的。</p>
<h3>列表处理</h3>
<p>Lisp 源代码的基本单元是 “<ruby> 表达式 <rt>  expression </rt></ruby>”，它在形式上是一个列表。举个例子，下面就是一个列表，它由一个操作符（<code>+</code>）和两个整数（<code>1</code> 和 <code>2</code>）组成：</p>
<div class="highlight"><pre><span></span><code>(+ 1 2)
</code></pre></div>

<p>同时，它也是一个 Lisp 表达式，内容是一个符号（<code>+</code>，会被解析成一个加法函数）和它的两个参数（<code>1</code> 和 <code>2</code>）。你可以在 Common Lisp 的交互式环境（即 REPL）中运行该表达式和其它表达式。如果你熟悉 Python 的 IDLE，那么你应该会对 Lisp 的 REPL 感到亲切。（LCTT 译注：REPL 的全称是 “Read-Eval-Print Loop”，意思是 “‘读取-求值-输出’循环”，这个名字很好地描述了它的工作过程。）</p>
<p>要进入到 REPL 中，只需运行 Common Lisp 即可：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>clisp
<span class="o">[</span><span class="m">1</span><span class="o">]</span>&gt;
</code></pre></div>

<p>在 REPL 提示符中，尝试输入一些表达式：</p>
<div class="highlight"><pre><span></span><code>[1]&gt; (+ 1 2)
3
[2]&gt; (- 1 2)
-1
[3]&gt; (- 2 1)
1
[4]&gt; (+ 2 3 4)
9
</code></pre></div>

<h3>函数</h3>
<p>在了解了 Lisp 表达式的基本结构后，你可以使用函数来做更多有用的事。譬如，<code>print</code> 函数可以接受任意数量的参数，然后把它们都显示在你的终端上，<code>pprint</code> 函数还可以实现格式化打印。还有更多不同的打印函数，不过，<code>pprint</code> 在 REPL 中的效果就挺好的：</p>
<div class="highlight"><pre><span></span><code>[1]&gt; (pprint &quot;hello world&quot;)

&quot;hello world&quot;

[2]&gt;
</code></pre></div>

<p>你可以使用 <code>defun</code> 函数来创建一个自定义函数。<code>defun</code> 函数需要你提供自定义函数的名称，以及它接受的参数列表：</p>
<div class="highlight"><pre><span></span><code>[1]&gt; (defun myprinter (s) (pprint s))
MYPRINTER
[2]&gt; (myprinter &quot;hello world&quot;)

&quot;hello world&quot;

[3]&gt;
</code></pre></div>

<h3>变量</h3>
<p>你可以使用 <code>setf</code> 函数来在 Lisp 中创建变量：</p>
<div class="highlight"><pre><span></span><code>[1]&gt; (setf foo &quot;hello world&quot;)
&quot;hello world&quot;
[2]&gt; (pprint foo)

&quot;hello world&quot;

[3]&gt;
</code></pre></div>

<p>你可以在表达式里嵌套表达式（就像使用某种管道一样）。举个例子，你可以先使用 <code>string-upcase</code> 函数，把某个字符串的所有字符转换成大写，然后再使用 <code>pprint</code> 函数，将它的内容格式化打印到终端上：</p>
<div class="highlight"><pre><span></span><code>[3]&gt; (pprint (string-upcase foo))

&quot;HELLO WORLD&quot;

[4]&gt;
</code></pre></div>

<p>Lisp 是动态类型语言，这意味着，你在给变量赋值时不需要声明它的类型。Lisp 默认会把整数当作整数来处理：</p>
<div class="highlight"><pre><span></span><code>[1]&gt; (setf foo 2)
[2]&gt; (setf bar 3)
[3]&gt; (+ foo bar)
5
</code></pre></div>

<p>如果你想让整数被当作字符串来处理，你可以给它加上引号：</p>
<div class="highlight"><pre><span></span><code>[4]&gt; (setf foo &quot;2&quot;)
&quot;2&quot;
[5]&gt; (setf bar &quot;3&quot;)
&quot;3&quot;
[6]&gt; (+ foo bar)

*** - +: &quot;2&quot; is not a number
The following restarts are available:
USE-VALUE      :R1      Input a value to be used instead.
ABORT          :R2      Abort main loop
Break 1 [7]&gt;
</code></pre></div>

<p>在这个示例 REPL 会话中，变量 <code>foo</code> 和 <code>bar</code> 都被赋值为加了引号的数字，因此，Lisp 会把它们当作字符串来处理。数学运算符不能够用在字符串上，因此 REPL 进入了调试器模式。想要跳出这个调试器，你需要按下 <code>Ctrl+D</code> 才行（LCTT 译注：就 <code>clisp</code> 而言，使用 <code>quit</code> 关键字也可以退出）。</p>
<p>你可以使用 <code>typep</code> 函数对一些对象进行类型检查，它可以测试对象是否为某个特定数据类型。返回值 <code>T</code> 和 <code>NIL</code> 分别代表 <code>True</code> 和 <code>False</code>。</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">4</span><span class="p">]&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">typep</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="err">&#39;</span><span class="kt">string</span><span class="p">)</span>
<span class="nx">NIL</span>
<span class="p">[</span><span class="mi">5</span><span class="p">]&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">typep</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">integer</span><span class="p">)</span>
<span class="nx">T</span>
</code></pre></div>

<p><code>string</code> 和 <code>integer</code> 前面加上了一个单引号（<code>'</code>），这是为了防止 Lisp（错误地）把这两个单词当作是变量来求值：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="n">typep</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="n">string</span><span class="p">)</span>
<span class="o">***</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">SYSTEM</span><span class="p">::</span><span class="n">READ</span><span class="o">-</span><span class="n">EVAL</span><span class="o">-</span><span class="n">PRINT</span><span class="p">:</span><span class="w"> </span><span class="n">variable</span><span class="w"> </span><span class="n">STRING</span><span class="w"> </span><span class="n">has</span><span class="w"> </span><span class="n">no</span><span class="w"> </span><span class="n">value</span>
<span class="p">[</span><span class="o">...</span><span class="p">]</span>
</code></pre></div>

<p>这是一种保护某些术语（LCTT 译注：类似于字符串转义）的简便方法，正常情况下它是用 <code>quote</code> 函数来实现的：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">7</span><span class="p">]&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">typep</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">quote</span><span class="w"> </span><span class="kt">string</span><span class="p">))</span>
<span class="nx">NIL</span>
<span class="p">[</span><span class="mi">5</span><span class="p">]&gt;</span><span class="w"> </span><span class="p">(</span><span class="nx">typep</span><span class="w"> </span><span class="nx">foo</span><span class="w"> </span><span class="p">(</span><span class="nx">quote</span><span class="w"> </span><span class="nx">integer</span><span class="p">))</span>
<span class="nx">T</span>
</code></pre></div>

<h3>列表</h3>
<p>不出人意料，你当然也可以在 Lisp 中创建列表：</p>
<div class="highlight"><pre><span></span><code>[1]&gt; (setf foo (list &quot;hello&quot; &quot;world&quot;))
(&quot;hello&quot; &quot;world&quot;)
</code></pre></div>

<p>你可以使用 <code>nth</code> 函数来索引列表：</p>
<div class="highlight"><pre><span></span><code>[2]&gt; (nth 0 foo)
&quot;hello&quot;
[3]&gt; (pprint (string-capitalize (nth 1 foo)))

&quot;World&quot;
</code></pre></div>

<h3>退出 REPL</h3>
<p>要结束一个 REPL 会话，你需要按下键盘上的 <code>Ctrl+D</code>，或者是使用 Lisp 的 <code>quit</code> 关键字：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="mi">99</span><span class="p">]</span><span class="o">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nv">quit</span><span class="p">)</span>
<span class="p">$</span>
</code></pre></div>

<h3>编写脚本</h3>
<p>Lisp 可以被编译，也可以作为解释型的脚本语言来使用。在你刚开始学习的时候，后者很可能是最容易的方式，特别是当你已经熟悉 Python 或 <a href="https://opensource.com/article/20/4/bash-programming-guide">Shell 脚本</a> 时。</p>
<p>下面是一个用 Common Lisp 编写的简单的“掷骰子”脚本：</p>
<div class="highlight"><pre><span></span><code><span class="gh">#</span>!/usr/bin/clisp

(defun roller (num)  
  (pprint (random (parse-integer (nth 0 num))))
)

(setf userput <span class="gs">*args*</span>)
(setf <span class="gs">*random-state*</span> (make-random-state t))
(roller userput)
</code></pre></div>

<p>脚本的第一行注释（LCTT 译注：称之为“<ruby> 释伴 <rt>  shebang </rt></ruby>”）告诉了你的 POSIX 终端，该使用什么可执行文件来运行这个脚本。</p>
<p><code>roller</code> 函数使用 <code>defun</code> 函数创建，它在内部使用 <code>random</code> 函数来打印一个伪随机数，这个伪随机数严格小于 <code>num</code> 列表中下标为 0 的元素。在脚本中，这个 <code>num</code> 列表还没有被创建，不过没关系，因为只有当脚本被调用时，函数才会执行。</p>
<p>接下来的那一行，我们把运行脚本时提供的任意参数，都赋值给一个叫做 <code>userput</code> 的变量。这个 <code>userput</code> 变量是一个列表，当它被传递给 <code>roller</code> 函数后，它就会变成参数 <code>num</code>。</p>
<p>脚本的倒数第二行产生了一个“随机种子”。这为 Lisp 提供了足够的随机性来生成一个几乎随机的数字。</p>
<p>最后一行调用了自定义的 <code>roller</code> 函数，并将 <code>userput</code> 列表作为唯一的参数传递给它。</p>
<p>将这个文件保存为 <code>dice.lisp</code>，并赋予它可执行权限：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>chmod<span class="w"> </span>+x<span class="w"> </span>dice.lisp
</code></pre></div>

<p>最后，运行它，并给它提供一个数字，以作为它选择随机数的最大值：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>./dice.lisp<span class="w"> </span><span class="m">21</span>

<span class="m">13</span>
$<span class="w"> </span>./dice.lisp<span class="w"> </span><span class="m">21</span>

<span class="m">7</span>
$<span class="w"> </span>./dice.lisp<span class="w"> </span><span class="m">21</span>

<span class="m">20</span>
</code></pre></div>

<p>看起来还不错！</p>
<p>你或许注意到，你的模拟骰子有可能会是 0，并且永远达不到你提供给它的最大值参数。换句话说，对于一个 20 面的骰子，这个脚本永远投不出 20（除非你把 0 当作 20）。有一个简单的解决办法，它只需要用到在本文中介绍的知识，你能够想到吗？</p>
<h3>学习 Lisp</h3>
<p>无论你是想将 Lisp 作为个人脚本的实用语言，还是为了助力你的职业生涯，抑或是仅仅作为一个有趣的实验，你都可以去看看一年一度（LCTT 译注：应该是两年一度）的 <a href="https://itch.io/jam/spring-lisp-game-jam-2021">Lisp <ruby> 游戏果酱 <rt>  Game Jam </rt></ruby></a>，从而收获一些特别有创意的用途（其中的大多数提交都是开源的，因此你可以查看代码以从中学习）。</p>
<p>Lisp 是一门有趣而独特的语言，它有着不断增长的开发者用户群、足够悠久的历史和新兴的方言，因此，它有能力让从事各个行业的程序员都满意。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>