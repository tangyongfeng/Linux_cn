<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>全面教程：在 RxJS 中创建流</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Oliver Flaggl 对大多数开发者来说，与 RxJS 的初次接触是通过库的形式，就像 Angular。一些函数会返回 流 stream ，要使用它们就得把注意力放 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2018/09/quan-mian-jiao-cheng-zai-rxjs-zhong-chuang-jian-liu.html" rel="bookmark"
           title="Permalink to 全面教程：在 RxJS 中创建流">全面教程：在 RxJS 中创建流</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-09-01T22:59:02+02:00">
                Published: Sat 01 September 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Oliver Flaggl</p>
<p><img alt="" src="/data/attachment/album/201809/01/225906f2vnvoglzjzmn37l.jpg"></p>
<p>对大多数开发者来说，与 RxJS 的初次接触是通过库的形式，就像 Angular。一些函数会返回<ruby> 流 <rt>  stream </rt></ruby>，要使用它们就得把注意力放在操作符上。</p>
<p>有些时候，混用响应式和非响应式代码似乎很有用。然后大家就开始热衷流的创造。不论是在编写异步代码或者是数据处理时，流都是一个不错的方案。</p>
<p>RxJS 提供很多方式来创建流。不管你遇到的是什么情况，都会有一个完美的创建流的方式。你可能根本用不上它们，但了解它们可以节省你的时间，让你少码一些代码。</p>
<p>我把所有可能的方法，按它们的主要目的，放在四个分类当中：</p>
<ul>
<li>流式化现有数据</li>
<li>生成数据</li>
<li>使用现有 API 进行交互</li>
<li>选择现有的流，并结合起来</li>
</ul>
<p>注意：示例用的是 RxJS 6，可能会以前的版本有所不同。已知的区别是你导入函数的方式不同了。</p>
<p>RxJS 6</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="p">{</span><span class="n">of</span><span class="p">,</span> <span class="n">from</span><span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;rxjs&#39;</span><span class="p">;</span>

<span class="n">of</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
<span class="n">from</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</code></pre></div>

<p>RxJS &lt; 6</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="p">{</span> <span class="n">Observable</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;rxjs/Observable&#39;</span><span class="p">;</span>
<span class="kn">import</span> <span class="s1">&#39;rxjs/add/observable/of&#39;</span><span class="p">;</span>
<span class="kn">import</span> <span class="s1">&#39;rxjs/add/observable/from&#39;</span><span class="p">;</span>

<span class="n">Observable</span><span class="o">.</span><span class="n">of</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
<span class="n">Observable</span><span class="o">.</span><span class="n">from</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>

<span class="o">//</span><span class="n">或</span>

<span class="kn">import</span> <span class="p">{</span> <span class="n">of</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;rxjs/observable/of&#39;</span><span class="p">;</span>
<span class="kn">import</span> <span class="p">{</span> <span class="kn">from</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;rxjs/observable/from&#39;</span><span class="p">;</span>

<span class="n">of</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
<span class="n">from</span><span class="p">(</span><span class="o">...</span><span class="p">);</span>
</code></pre></div>

<p>流的图示中的标记：</p>
<ul>
<li><code>|</code> 表示流结束了</li>
<li><code>X</code> 表示流出现错误并被终结</li>
<li><code>...</code> 表示流的走向不定</li>
</ul>
<h3>流式化已有数据</h3>
<p>你有一些数据，想把它们放到流中。有三种方式，并且都允许你把调度器当作最后一个参数传入（你如果想深入了解调度器，可以看看我的 <a href="https://itnext.io/concurrency-and-asynchronous-behavior-with-rxjs-11b0c4b22597">上一篇文章</a>）。这些生成的流都是静态的。</p>
<h4>of</h4>
<p>如果只有一个或者一些不同的元素，使用 <code>of</code>：</p>
<div class="highlight"><pre><span></span><code>of(1,2,3)
  .subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 2 3 |</span>
</code></pre></div>

<h4>from</h4>
<p>如果有一个数组或者 <em>可迭代的对象</em> ，而且你想要其中的所有元素发送到流中，使用 <code>from</code>。你也可以用它来把一个 promise 对象变成可观测的。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">];</span>

<span class="n">from</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 2 3 |</span>
</code></pre></div>

<h4>pairs</h4>
<p>流式化一个对象的键/值对。用这个对象表示字典时特别有用。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">a</span><span class="p">:</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">:</span><span class="w"> </span><span class="mi">2</span><span class="p">};</span>

<span class="n">pairs</span><span class="p">(</span><span class="n">foo</span><span class="p">)</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// [a,1] [b,2] |</span>
</code></pre></div>

<h4>那么其他的数据结构呢？</h4>
<p>也许你的数据存储在自定义的结构中，而它又没有实现 <em>可迭代的对象</em> 接口，又或者说你的结构是递归的、树状的。也许下面某种选择适合这些情况：</p>
<ol>
<li>先将数据提取到数组里</li>
<li>使用下一节将会讲到的 <code>generate</code> 函数，遍历所有数据</li>
<li>创建一个自定义流（见下一节）</li>
<li>创建一个迭代器</li>
</ol>
<p>稍后会讲到选项 2 和 3 ，因此这里的重点是创建一个迭代器。我们可以对一个 <em>可迭代的对象</em> 调用 <code>from</code> 创建一个流。 <em>可迭代的对象</em> 是一个对象，可以产生一个迭代器（如果你对细节感兴趣，参考 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols">这篇 mdn 文章</a>）。</p>
<p>创建一个迭代器的简单方式是 <ruby> <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function*">  生成函数 </a> <rt>  generator function </rt></ruby>。当你调用一个生成函数时，它返回一个对象，该对象同时遵循 <em>可迭代的对象</em> 接口和 <em>迭代器</em> 接口。</p>
<div class="highlight"><pre><span></span><code><span class="o">//</span><span class="w"> </span><span class="err">自定义的数据结构</span>
<span class="k">class</span><span class="w"> </span><span class="n">List</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">add</span><span class="p">(</span><span class="n">element</span><span class="p">)</span><span class="w"> </span><span class="o">...</span>
<span class="w">  </span><span class="n">get</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="w"> </span><span class="o">...</span>
<span class="w">  </span><span class="n">get</span><span class="w"> </span><span class="n">size</span><span class="p">()</span><span class="w"> </span><span class="o">...</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>

<span class="n">function</span><span class="o">*</span><span class="w"> </span><span class="n">listIterator</span><span class="p">(</span><span class="n">list</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nb">yield</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">myList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">List</span><span class="p">();</span>
<span class="n">myList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">myList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">from</span><span class="p">(</span><span class="n">listIterator</span><span class="p">(</span><span class="n">myList</span><span class="p">))</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 3 |    </span>
</code></pre></div>

<p>调用 <code>listIterator</code> 函数时，返回值是一个 <em>可迭代的对象</em> / <em>迭代器</em> 。函数里面的代码在调用 <code>subscribe</code> 前不会执行。</p>
<h3>生成数据</h3>
<p>你知道要发送哪些数据，但想（或者必须）动态生成它。所有函数的最后一个参数都可以用来接收一个调度器。他们产生静态的流。</p>
<h4>范围（<code>range</code>）</h4>
<p>从初始值开始，发送一系列数字，直到完成了指定次数的迭代。</p>
<div class="highlight"><pre><span></span><code>range(10, 2)  // 从 10 开始，发送两个值
  .subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 10 11 |</span>
</code></pre></div>

<h4>间隔（<code>interval</code>） / 定时器（<code>timer</code>）</h4>
<p>有点像范围，但定时器是周期性的发送累加的数字（就是说，不是立即发送）。两者的区别在于在于定时器允许你为第一个元素设定一个延迟。也可以只产生一个值，只要不指定周期。</p>
<div class="highlight"><pre><span></span><code>interval(1000) // 每 1000ms = 1 秒 发送数据
  .subscribe()
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 0  1  2  3  4 ...</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="nf">delay</span><span class="p">(</span><span class="mi">5000</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">)</span><span class="w"> </span><span class="c1">// 和上面相同，在开始前先等待 5000ms</span>

<span class="nf">delay</span><span class="p">(</span><span class="mi">5000</span><span class="p">)</span>
<span class="na">.subscribe</span><span class="p">(</span><span class="no">i</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="no">console.log</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">)</span><span class="c1">;</span>
<span class="c1">// 5 秒后打印 foo</span>
</code></pre></div>

<p>大多数定时器将会用来周期性的处理数据：</p>
<div class="highlight"><pre><span></span><code>interval(10000).pipe(
  flatMap(i =&gt; fetch(&quot;https://server/stockTicker&quot;)
).subscribe(updateChart)
</code></pre></div>

<p>这段代码每 10 秒获取一次数据，更新屏幕。</p>
<h4>生成（<code>generate</code>）</h4>
<p>这是个更加复杂的函数，允许你发送一系列任意类型的对象。它有一些重载，这里你看到的是最有意思的部分：</p>
<div class="highlight"><pre><span></span><code>generate(
  0,           // 从这个值开始
  x =&gt; x &lt; 10, // 条件：只要值小于 10，就一直发送
  x =&gt; x*2     // 迭代：前一个值加倍
).subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 2 4 8 |</span>
</code></pre></div>

<p>你也可以用它来迭代值，如果一个结构没有实现 <em>可迭代的对象</em> 接口。我们用前面的列表例子来进行演示：</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">myList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">List</span><span class="p">();</span>
<span class="n">myList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">myList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">generate</span><span class="p">(</span>
<span class="w">  </span><span class="mi">0</span><span class="p">,</span><span class="w">                  </span><span class="o">//</span><span class="w"> </span><span class="err">从这个值开始</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">条件：发送数据，直到遍历完整个列表</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="o">++</span><span class="n">i</span><span class="p">,</span><span class="w">           </span><span class="o">//</span><span class="w"> </span><span class="err">迭代：获取下一个索引</span>
<span class="w">  </span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">)</span><span class="w">    </span><span class="o">//</span><span class="w"> </span><span class="err">选择器：从列表中取值</span>
<span class="p">)</span><span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 3 |</span>
</code></pre></div>

<p>如你所见，我添加了另一个参数：选择器。它和 <code>map</code> 操作符作用类似，将生成的值转换为更有用的东西。</p>
<h3>空的流</h3>
<p>有时候你要传递或返回一个不用发送任何数据的流。有三个函数分别用于不同的情况。你可以给这三个函数传递调度器。<code>empty</code> 和 <code>throwError</code> 接收一个调度器参数。</p>
<h4><code>empty</code></h4>
<p>创建一个空的流，一个值也不发送。</p>
<div class="highlight"><pre><span></span><code>empty()
  .subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// |</span>
</code></pre></div>

<h4><code>never</code></h4>
<p>创建一个永远不会结束的流，仍然不发送值。</p>
<div class="highlight"><pre><span></span><code>never()
  .subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// ...</span>
</code></pre></div>

<h4><code>throwError</code></h4>
<p>创建一个流，流出现错误，不发送数据。</p>
<div class="highlight"><pre><span></span><code>throwError(&#39;error&#39;)
  .subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// X</span>
</code></pre></div>

<h3>挂钩已有的 API</h3>
<p>不是所有的库和所有你之前写的代码使用或者支持流。幸运的是 RxJS 提供函数用来桥接非响应式和响应式代码。这一节仅仅讨论 RxJS 为桥接代码提供的模版。</p>
<p>你可能还对这篇出自 <a href="https://medium.com/@benlesh">Ben Lesh</a> 的 <a href="https://medium.com/@benlesh/rxjs-observable-interop-with-promises-and-async-await-bebb05306875">全面的文章</a> 感兴趣，这篇文章讲了几乎所有能与 promises 交互操作的方式。</p>
<h4><code>from</code></h4>
<p>我们已经用过它，把它列在这里是因为，它可以封装一个含有 observable 对象的 promise 对象。</p>
<div class="highlight"><pre><span></span><code>from(new Promise(resolve =&gt; resolve(1)))
  .subscribe();
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 |</span>
</code></pre></div>

<h4>fromEvent</h4>
<p>fromEvent 为 DOM 元素添加一个事件监听器，我确定你知道这个。但你可能不知道的是，也可以通过其它类型来添加事件监听器，例如，一个 jQuery 对象。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">element</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="s1">&#39;#fooButton&#39;</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">从</span><span class="w"> </span><span class="n">DOM</span><span class="w"> </span><span class="err">元素中创建一个</span><span class="w"> </span><span class="n">jQuery</span><span class="w"> </span><span class="err">对象</span>

<span class="n">from</span><span class="p">(</span><span class="n">element</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;click&#39;</span><span class="p">)</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// clickEvent ...</span>
</code></pre></div>

<h4>fromEventPattern</h4>
<p>要理解为什么有 fromEvent 了还需要 fromEventPattern，我们得先理解 fromEvent 是如何工作的。看这段代码：</p>
<div class="highlight"><pre><span></span><code>from(document, &#39;click&#39;)
  .subscribe();
</code></pre></div>

<p>这告诉 RxJS 我们想要监听 document 中的点击事件。在提交过程中，RxJS 发现 document 是一个 <em>EventTarget</em> 类型，因此它可以调用它的 <code>addEventListener</code> 方法。如果我们传入的是一个 jQuery 对象而非 document，那么 RxJs 知道它得调用 <em>on</em> 方法。</p>
<p>这个例子用的是 <em>fromEventPattern</em> ，和 <em>fromEvent</em> 的工作基本上一样：</p>
<div class="highlight"><pre><span></span><code><span class="nf">function</span><span class="w"> </span><span class="no">addClickHandler</span><span class="p">(</span><span class="no">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nf">document.addEventListener</span><span class="p">(</span><span class="err">&#39;</span><span class="no">click</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="no">handler</span><span class="p">)</span><span class="c1">;</span>
<span class="err">}</span>

<span class="nf">function</span><span class="w"> </span><span class="no">removeClickHandler</span><span class="p">(</span><span class="no">handler</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nf">document.removeEventListener</span><span class="p">(</span><span class="err">&#39;</span><span class="no">click</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="no">handler</span><span class="p">)</span><span class="c1">;</span>
<span class="err">}</span>

<span class="nf">fromEventPattern</span><span class="p">(</span>
<span class="w">  </span><span class="nf">addClickHandler</span><span class="p">,</span>
<span class="w">  </span><span class="nf">removeClickHandler</span><span class="p">,</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">(</span><span class="no">console.log</span><span class="p">)</span><span class="c1">;</span>

<span class="c1">// 等效于</span>
<span class="nf">fromEvent</span><span class="p">(</span><span class="no">document</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="no">click</span><span class="err">&#39;</span><span class="p">)</span>
</code></pre></div>

<p>RxJS 自动创建实际的监听器（ <em>handler</em> ）你的工作是添加或者移除监听器。<em>fromEventPattern</em> 的目的基本上是告诉 RxJS 如何注册和移除事件监听器。</p>
<p>现在想象一下你使用了一个库，你可以调用一个叫做 <em>registerListener</em> 的方法。我们不能再用 <em>fromEvent</em>，因为它并不知道该怎么处理这个对象。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">listeners</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>

<span class="k">class</span><span class="w"> </span><span class="n">Foo</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">registerListener</span><span class="p">(</span><span class="n">listener</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">listeners</span><span class="o">.</span><span class="n">push</span><span class="p">(</span><span class="n">listener</span><span class="p">);</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">emit</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">listeners</span><span class="o">.</span><span class="n">forEach</span><span class="p">(</span><span class="n">listener</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">listener</span><span class="p">(</span><span class="n">value</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">foo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Foo</span><span class="p">();</span>

<span class="n">fromEventPattern</span><span class="p">(</span><span class="n">listener</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">foo</span><span class="o">.</span><span class="n">registerListener</span><span class="p">(</span><span class="n">listener</span><span class="p">))</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>

<span class="n">foo</span><span class="o">.</span><span class="n">emit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 ...</span>
</code></pre></div>

<p>当我们调用 <code>foo.emit(1)</code> 时，RxJS 中的监听器将被调用，然后它就能把值发送到流中。</p>
<p>你也可以用它来监听多个事件类型，或者结合所有可以通过回调进行通讯的 API，例如，WebWorker API:</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">myWorker</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Worker</span><span class="p">(</span><span class="s1">&#39;worker.js&#39;</span><span class="p">);</span>

<span class="n">fromEventPattern</span><span class="p">(</span>
<span class="w">  </span><span class="n">handler</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">myWorker</span><span class="o">.</span><span class="n">onmessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">handler</span><span class="w"> </span><span class="p">},</span>
<span class="w">  </span><span class="n">handler</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">myWorker</span><span class="o">.</span><span class="n">onmessage</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">undefined</span><span class="w"> </span><span class="p">}</span>
<span class="p">)</span>
<span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// workerMessage ...</span>
</code></pre></div>

<h4>bindCallback</h4>
<p>它和 fromEventPattern 相似，但它能用于单个值。就在回调函数被调用时，流就结束了。用法当然也不一样 —— 你可以用 bindCallBack 封装函数，然后它就会在调用时魔术般的返回一个流：</p>
<div class="highlight"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="n">value</span><span class="p">,</span><span class="w"> </span><span class="n">callback</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">callback</span><span class="p">(</span><span class="n">value</span><span class="p">);</span>
<span class="p">}</span>

<span class="o">//</span><span class="w"> </span><span class="err">没有流</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="nb">prints</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">console</span>

<span class="o">//</span><span class="w"> </span><span class="err">有流</span>
<span class="k">const</span><span class="w"> </span><span class="n">reactiveFoo</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">bindCallback</span><span class="p">(</span><span class="n">foo</span><span class="p">);</span><span class="w"> </span>
<span class="o">//</span><span class="w"> </span><span class="err">当我们调用</span><span class="w"> </span><span class="n">reactiveFoo</span><span class="w"> </span><span class="err">时，它返回一个</span><span class="w"> </span><span class="n">observable</span><span class="w"> </span><span class="err">对象</span>

<span class="n">reactiveFoo</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="err">在控制台打印</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 |</span>
</code></pre></div>

<h4>websocket</h4>
<p>是的，你完全可以创建一个 websocket 连接然后把它暴露给流：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="p">{</span> <span class="n">webSocket</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;rxjs/webSocket&#39;</span><span class="p">;</span> 

<span class="n">let</span> <span class="n">socket</span><span class="err">$</span> <span class="o">=</span> <span class="n">webSocket</span><span class="p">(</span><span class="s1">&#39;ws://localhost:8081&#39;</span><span class="p">);</span>

<span class="o">//</span> <span class="n">接收消息</span>
<span class="n">socket</span><span class="err">$</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span>
  <span class="p">(</span><span class="n">msg</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;message received: &#39;</span> <span class="o">+</span> <span class="n">msg</span><span class="p">),</span>
  <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">err</span><span class="p">),</span>
  <span class="p">()</span> <span class="o">=&gt;</span> <span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s1">&#39;complete&#39;</span><span class="p">)</span> <span class="o">*</span> <span class="p">);</span>

<span class="o">//</span> <span class="n">发送消息</span>
<span class="n">socket</span><span class="err">$</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">JSON</span><span class="o">.</span><span class="n">stringify</span><span class="p">({</span> <span class="n">op</span><span class="p">:</span> <span class="s1">&#39;hello&#39;</span> <span class="p">}));</span>
</code></pre></div>

<p>把 websocket 功能添加到你的应用中真的很简单。<em>websocket</em> 创建一个 subject。这意味着你可以订阅它，通过调用 <code>next</code> 来获得消息和发送消息。</p>
<h4>ajax</h4>
<p>如你所知：类似于 websocket，提供 AJAX 查询的功能。你可能用了一个带有 AJAX 功能的库或者框架。或者你没有用，那么我建议使用 fetch（或者必要的话用 polyfill），把返回的 promise 封装到一个 observable 对象中（参考稍后会讲到的 <code>defer</code> 函数）。</p>
<h3>定制流</h3>
<p>有时候已有的函数用起来并不是足够灵活。或者你需要对订阅有更强的控制。</p>
<h4>主题（<code>Subject</code>）</h4>
<p><code>Subject</code> 是一个特殊的对象，它使得你的能够把数据发送到流中，并且能够控制数据。<code>Subject</code> 本身就是一个可观察对象，但如果你想要把流暴露给其它代码，建议你使用 <code>asObservable</code> 方法。这样你就不能意外调用原始方法。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">subject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Subject</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">observable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subject</span><span class="o">.</span><span class="n">asObservable</span><span class="p">();</span>

<span class="n">observable</span><span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">subject</span><span class="o">.</span><span class="n">complete</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 2 |</span>
</code></pre></div>

<p>注意在订阅前发送的值将会“丢失”：</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">subject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Subject</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">observable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subject</span><span class="o">.</span><span class="n">asObservable</span><span class="p">();</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">observable</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">subject</span><span class="o">.</span><span class="n">complete</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 2</span>
</code></pre></div>

<p>除了常规的 <code>Subject</code>，RxJS 还提供了三种特殊的版本。</p>
<p><code>AsyncSubject</code> 在结束后只发送最后的一个值。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">subject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">AsyncSubject</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">observable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subject</span><span class="o">.</span><span class="n">asObservable</span><span class="p">();</span>

<span class="n">observable</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">subject</span><span class="o">.</span><span class="n">complete</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 输出</span>
<span class="c1">// 2</span>
</code></pre></div>

<p><code>BehaviorSubject</code> 使得你能够提供一个（默认的）值，如果当前没有其它值发送的话，这个值会被发送给每个订阅者。否则订阅者收到最后一个发送的值。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">subject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">BehaviorSubject</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="k">const</span><span class="w"> </span><span class="n">observable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subject</span><span class="o">.</span><span class="n">asObservable</span><span class="p">();</span>

<span class="k">const</span><span class="w"> </span><span class="n">subscription1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">observable</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">subscription1</span><span class="o">.</span><span class="n">unsubscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 输出</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">subscription2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">observable</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>

<span class="o">//</span><span class="w"> </span><span class="err">输出</span>
<span class="o">//</span><span class="w"> </span><span class="mi">2</span>
</code></pre></div>

<p><code>ReplaySubject</code> 存储一定数量、或一定时间或所有的发送过的值。所有新的订阅者将会获得所有存储了的值。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">subject</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">ReplaySubject</span><span class="p">();</span>
<span class="k">const</span><span class="w"> </span><span class="n">observable</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">subject</span><span class="o">.</span><span class="n">asObservable</span><span class="p">();</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

<span class="n">observable</span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>

<span class="n">subject</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">subject</span><span class="o">.</span><span class="n">complete</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 输出</span>
<span class="c1">// 1</span>
<span class="c1">// 2</span>
</code></pre></div>

<p>你可以在 <a href="http://reactivex.io/documentation/subject.html">ReactiveX 文档</a>（它提供了一些其它的连接） 里面找到更多关于 <code>Subject</code> 的信息。<a href="https://medium.com/@benlesh">Ben Lesh</a> 在 <a href="https://medium.com/@benlesh/on-the-subject-of-subjects-in-rxjs-2b08b7198b93">On The Subject Of Subjects</a> 上面提供了一些关于 <code>Subject</code> 的理解，<a href="https://medium.com/@cartant">Nicholas Jamieson</a> 在 <a href="https://blog.angularindepth.com/rxjs-understanding-subjects-5c585188c3e1">in RxJS: Understanding Subjects</a> 上也提供了一些理解。</p>
<h4>可观察对象</h4>
<p>你可以简单地用 new 操作符创建一个可观察对象。通过你传入的函数，你可以控制流，只要有人订阅了或者它接收到一个可以当成 <code>Subject</code> 使用的观察者，这个函数就会被调用，比如，调用 <code>next</code>、<code>complet</code> 和 <code>error</code>。</p>
<p>让我们回顾一下列表示例：</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">myList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">List</span><span class="p">();</span>
<span class="n">myList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">myList</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>

<span class="n">new</span><span class="w"> </span><span class="n">Observable</span><span class="p">(</span><span class="n">observer</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">for</span><span class="w"> </span><span class="p">(</span><span class="n">let</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">&lt;</span><span class="n">list</span><span class="o">.</span><span class="n">size</span><span class="p">;</span><span class="w"> </span><span class="n">i</span><span class="o">++</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">observer</span><span class="o">.</span><span class="n">next</span><span class="p">(</span><span class="n">list</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
<span class="w">  </span><span class="p">}</span>

<span class="w">  </span><span class="n">observer</span><span class="o">.</span><span class="n">complete</span><span class="p">();</span>
<span class="p">})</span>
<span class="o">.</span><span class="n">subscribe</span><span class="p">();</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 3 |</span>
</code></pre></div>

<p>这个函数可以返回一个 <code>unsubcribe</code> 函数，当有订阅者取消订阅时这个函数就会被调用。你可以用它来清楚或者执行一些收尾操作。</p>
<div class="highlight"><pre><span></span><code><span class="nx">new</span><span class="w"> </span><span class="nx">Observable</span><span class="p">(</span><span class="nx">observer</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 流式化</span>

<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">                 </span><span class="c1">//clean up</span>
<span class="w">               </span><span class="p">};</span>
<span class="p">})</span>
<span class="p">.</span><span class="nx">subscribe</span><span class="p">();</span>
</code></pre></div>

<h4>继承可观察对象</h4>
<p>在有可用的操作符前，这是一种实现自定义操作符的方式。RxJS 在内部扩展了 <em>可观察对象</em> 。<code>Subject</code> 就是一个例子，另一个是 <code>publisher</code> 操作符。它返回一个 <code>ConnectableObservable</code> 对象，该对象提供额外的方法 <code>connect</code>。</p>
<h4>实现 <code>Subscribable</code> 接口</h4>
<p>有时候你已经用一个对象来保存状态，并且能够发送值。如果你实现了 <code>Subscribable</code> 接口，你可以把它转换成一个可观察对象。<code>Subscribable</code> 接口中只有一个 <code>subscribe</code> 方法。</p>
<div class="highlight"><pre><span></span><code><span class="kd">interface</span><span class="w"> </span><span class="nx">Subscribable</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">  </span><span class="nx">subscribe</span><span class="p">(</span><span class="nx">observerOrNext</span><span class="p">?:</span><span class="w"> </span><span class="nx">PartialObserver</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">((</span><span class="nx">value</span><span class="p">:</span><span class="w"> </span><span class="nx">T</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nx">void</span><span class="p">),</span><span class="w"> </span><span class="nx">error</span><span class="p">?:</span><span class="w"> </span><span class="p">(</span><span class="nx">error</span><span class="p">:</span><span class="w"> </span><span class="nx">any</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nx">void</span><span class="p">,</span><span class="w"> </span><span class="nx">complete</span><span class="p">?:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="nx">void</span><span class="p">):</span><span class="w"> </span><span class="nx">Unsubscribable</span><span class="p">}</span>
</code></pre></div>

<h3>结合和选择现有的流</h3>
<p>知道怎么创建一个独立的流还不够。有时候你有好几个流但其实只需要一个。有些函数也可作为操作符，所以我不打算在这里深入展开。推荐看看 <a href="https://medium.com/@maximus.koretskyi">Max NgWizard K</a> 所写的一篇 <a href="https://blog.angularindepth.com/learn-to-combine-rxjs-sequences-with-super-intuitive-interactive-diagrams-20fce8e6511">文章</a>，它还包含一些有趣的动画。</p>
<p>还有一个建议：你可以通过拖拽元素的方式交互式的使用结合操作，参考 <a href="http://rxmarbles.com/#merge">RxMarbles</a>。</p>
<h4>ObservableInput 类型</h4>
<p>期望接收流的操作符和函数通常不单独和可观察对象一起工作。相反，它们实际上期望的参数类型是 ObservableInput，定义如下：</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">ObservableInput</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">&gt;</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">SubscribableOrPromise</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">ArrayLike</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">&gt;</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="nx">Iterable</span><span class="p">&lt;</span><span class="nx">T</span><span class="p">&gt;;</span>
</code></pre></div>

<p>这意味着你可以传递一个 promises 或者数组却不需要事先把他们转换成可观察对象。</p>
<h4>defer</h4>
<p>主要的目的是把一个 observable 对象的创建延迟（<code>defer</code>）到有人想要订阅的时间。在以下情况，这很有用：</p>
<ul>
<li>创建可观察对象的开销较大</li>
<li>你想要给每个订阅者新的可观察对象</li>
<li>你想要在订阅时候选择不同的可观察对象</li>
<li>有些代码必须在订阅之后执行</li>
</ul>
<p>最后一点包含了一个并不起眼的用例：Promises（<code>defer</code> 也可以返回一个 promise 对象）。看看这个用到了 fetch API 的例子：</p>
<div class="highlight"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">getUser</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;fetching data&quot;</span><span class="p">);</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">fetch</span><span class="p">(</span><span class="err">`</span><span class="n">https</span><span class="p">:</span><span class="o">//</span><span class="n">server</span><span class="o">/</span><span class="n">user</span><span class="o">/$</span><span class="p">{</span><span class="n">id</span><span class="p">}</span><span class="err">`</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span><span class="w"> </span><span class="n">userPromise</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">getUser</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;I don&#39;t want that request now&quot;</span><span class="p">);</span>

<span class="o">//</span><span class="w"> </span><span class="err">其它地方</span>
<span class="n">userPromise</span><span class="o">.</span><span class="n">then</span><span class="p">(</span><span class="n">response</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">);</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 输出</span>
<span class="c1">// fetching data</span>
<span class="c1">// I don&#39;t want that request now</span>
<span class="c1">// done</span>
</code></pre></div>

<p>只要流在你订阅的时候执行了，promise 就会立即执行。我们调用 <code>getUser</code> 的瞬间，就发送了一个请求，哪怕我们这个时候不想发送请求。当然，我们可以使用 <code>from</code> 来把一个 promise 对象转换成可观察对象，但我们传递的 promise 对象已经创建或执行了。<code>defer</code> 让我们能够等到订阅才发送这个请求：</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">user</span><span class="o">$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">defer</span><span class="p">(()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">getUser</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

<span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;I don&#39;t want that request now&quot;</span><span class="p">);</span>

<span class="o">//</span><span class="w"> </span><span class="err">其它地方</span>
<span class="n">user</span><span class="o">$.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">response</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="s2">&quot;done&quot;</span><span class="p">);</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 输出</span>
<span class="c1">// I don&#39;t want that request now</span>
<span class="c1">// fetching data</span>
<span class="c1">// done</span>
</code></pre></div>

<h4>iif</h4>
<p><code>iif</code> 包含了一个关于 <code>defer</code> 的特殊用例：在订阅时选择两个流中的一个：</p>
<div class="highlight"><pre><span></span><code><span class="nf">iif</span><span class="p">(</span>
<span class="w">  </span><span class="err">()</span><span class="w"> </span><span class="err">=&gt;</span><span class="w"> </span><span class="nf">new</span><span class="w"> </span><span class="no">Date</span><span class="p">().</span><span class="no">getHours</span><span class="p">()</span><span class="w"> </span><span class="err">&lt;</span><span class="w"> </span><span class="mi">12</span><span class="p">,</span>
<span class="w">  </span><span class="nf">of</span><span class="p">(</span><span class="err">&quot;</span><span class="no">AM</span><span class="err">&quot;</span><span class="p">),</span>
<span class="w">  </span><span class="nf">of</span><span class="p">(</span><span class="err">&quot;</span><span class="no">PM</span><span class="err">&quot;</span><span class="p">)</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">()</span><span class="c1">;</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// AM before noon, PM afterwards</span>
</code></pre></div>

<p>引用该文档：</p>
<blockquote>
<p>实际上 <a href="https://rxjs-dev.firebaseapp.com/api/index/iif">iif</a> 能够轻松地用 <a href="https://rxjs-dev.firebaseapp.com/api/index/defer">defer</a> 实现，它仅仅是出于方便和可读性的目的。</p>
</blockquote>
<h4>onErrorResumeNext</h4>
<p>开启第一个流并且在失败的时候继续进行下一个流。错误被忽略掉。</p>
<div class="highlight"><pre><span></span><code><span class="k">const</span><span class="w"> </span><span class="n">stream1</span><span class="o">$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">of</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">pipe</span><span class="p">(</span>
<span class="w">  </span><span class="n">tap</span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">if</span><span class="p">(</span><span class="n">i</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="n">throw</span><span class="w"> </span><span class="s1">&#39;error&#39;</span><span class="p">})</span><span class="w"> </span><span class="o">//</span><span class="n">fail</span><span class="w"> </span><span class="n">after</span><span class="w"> </span><span class="n">first</span><span class="w"> </span><span class="n">element</span>
<span class="p">);</span>

<span class="k">const</span><span class="w"> </span><span class="n">stream2</span><span class="o">$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">of</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">);</span>

<span class="n">onErrorResumeNext</span><span class="p">(</span><span class="n">stream1</span><span class="o">$</span><span class="p">,</span><span class="w"> </span><span class="n">stream2</span><span class="o">$</span><span class="p">)</span>
<span class="w">  </span><span class="o">.</span><span class="n">subscribe</span><span class="p">(</span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">);</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 1 3 4 |</span>
</code></pre></div>

<p>如果你有多个 web 服务，这就很有用了。万一主服务器开启失败，那么备份的服务就能自动调用。</p>
<h4>forkJoin</h4>
<p>它让流并行运行，当流结束时发送存在数组中的最后的值。由于每个流只有最后一个值被发送，它一般用在只发送一个元素的流的情况，就像 HTTP 请求。你让请求并行运行，在所有流收到响应时执行某些任务。</p>
<div class="highlight"><pre><span></span><code><span class="nf">function</span><span class="w"> </span><span class="no">handleResponses</span><span class="p">([</span><span class="no">user</span><span class="p">,</span><span class="w"> </span><span class="no">account</span><span class="p">])</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="c1">// 执行某些任务</span>
<span class="err">}</span>

<span class="nf">forkJoin</span><span class="p">(</span>
<span class="w">  </span><span class="nf">fetch</span><span class="p">(</span><span class="err">&quot;</span><span class="no">https</span><span class="p">:</span><span class="c1">//server/user/1&quot;),</span>
<span class="w">  </span><span class="nf">fetch</span><span class="p">(</span><span class="err">&quot;</span><span class="no">https</span><span class="p">:</span><span class="c1">//server/account/1&quot;)</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">(</span><span class="no">handleResponses</span><span class="p">)</span><span class="c1">;</span>
</code></pre></div>

<h4>merge / concat</h4>
<p>发送每一个从可观察对象源中发出的值。</p>
<p><code>merge</code> 接收一个参数，让你定义有多少流能被同时订阅。默认是无限制的。设为 1 就意味着监听一个源流，在它结束的时候订阅下一个。由于这是一个常见的场景，RxJS 为你提供了一个显示的函数：<code>concat</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nf">merge</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">1</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1200</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">2</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
<span class="w">  </span><span class="nf">timer</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1000</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">3</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
<span class="w">  </span><span class="err">2</span><span class="w"> </span><span class="c1">//two concurrent streams</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">()</span><span class="c1">;</span>

<span class="c1">// 只订阅流 1 和流 2</span>

<span class="c1">// 输出</span>
<span class="c1">// Stream 1 -&gt; after 1000ms</span>
<span class="c1">// Stream 2 -&gt; after 1200ms</span>
<span class="c1">// Stream 1 -&gt; after 2000ms</span>

<span class="c1">// 流 1 结束后，开始订阅流 3</span>

<span class="c1">// 输出</span>
<span class="c1">// Stream 3 -&gt; after 0 ms</span>
<span class="c1">// Stream 2 -&gt; after 400 ms (2400ms from beginning)</span>
<span class="c1">// Stream 3 -&gt; after 1000ms</span>

<span class="nf">merge</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">1</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1200</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">2</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="w">  </span><span class="err">1</span>
<span class="err">)</span>
<span class="c1">// 等效于</span>
<span class="nf">concat</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">1</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">)),</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1200</span><span class="p">).</span><span class="no">pipe</span><span class="p">(</span><span class="no">mapTo</span><span class="p">(</span><span class="err">&quot;</span><span class="no">Stream</span><span class="w"> </span><span class="mi">2</span><span class="err">&quot;</span><span class="p">),</span><span class="w"> </span><span class="no">take</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
<span class="err">)</span>

<span class="c1">// 输出</span>
<span class="c1">// Stream 1 -&gt; after 1000ms</span>
<span class="c1">// Stream 1 -&gt; after 2000ms</span>
<span class="c1">// Stream 2 -&gt; after 3200ms</span>
<span class="c1">// Stream 2 -&gt; after 4400ms</span>
</code></pre></div>

<h4>zip / combineLatest</h4>
<p><code>merge</code> 和 <code>concat</code> 一个接一个的发送所有从源流中读到的值，而 <code>zip</code> 和 <code>combineLatest</code> 是把每个流中的一个值结合起来一起发送。<code>zip</code> 结合所有源流中发送的第一个值。如果流的内容相关联，那么这就很有用。</p>
<div class="highlight"><pre><span></span><code><span class="nf">zip</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1200</span><span class="p">),</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">()</span><span class="c1">;</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// [0, 0] [1, 1] [2, 2] ...</span>
</code></pre></div>

<p><code>combineLatest</code> 与之类似，但结合的是源流中发送的最后一个值。直到所有源流至少发送一个值之后才会触发事件。这之后每次源流发送一个值，它都会把这个值与其他流发送的最后一个值结合起来。</p>
<div class="highlight"><pre><span></span><code><span class="nf">combineLatest</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1200</span><span class="p">),</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">()</span><span class="c1">;</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// [0, 0] [1, 0] [1, 1] [2, 1] ...</span>
</code></pre></div>

<p>两个函数都让允许传递一个选择器函数，把元素结合成其它对象而不是数组：</p>
<div class="highlight"><pre><span></span><code><span class="nf">zip</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1200</span><span class="p">),</span>
<span class="w">  </span><span class="err">(</span><span class="nf">e1</span><span class="p">,</span><span class="w"> </span><span class="no">e2</span><span class="p">)</span><span class="w"> </span><span class="p">-</span><span class="err">&gt;</span><span class="w"> </span><span class="no">e1</span><span class="w"> </span><span class="err">+</span><span class="w"> </span><span class="no">e2</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">()</span><span class="c1">;</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// 0 2 4 6 ...</span>
</code></pre></div>

<h4>race</h4>
<p>选择第一个发送数据的流。产生的流基本是最快的。</p>
<div class="highlight"><pre><span></span><code><span class="nf">race</span><span class="p">(</span>
<span class="w">  </span><span class="nf">interval</span><span class="p">(</span><span class="mi">1000</span><span class="p">),</span>
<span class="w">  </span><span class="nf">of</span><span class="p">(</span><span class="err">&quot;</span><span class="no">foo</span><span class="err">&quot;</span><span class="p">)</span>
<span class="err">)</span>
<span class="na">.subscribe</span><span class="p">()</span><span class="c1">;</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="c1">// 结果</span>
<span class="c1">// foo |</span>
</code></pre></div>

<p>由于 <code>of</code> 立即产生一个值，因此它是最快的流，然而这个流就被选中了。</p>
<h3>总结</h3>
<p>已经有很多创建可观察对象的方式了。如果你想要创造响应式的 API 或者想用响应式的 API 结合传统 API，那么了解这些方法很重要。</p>
<p>我已经向你展示了所有可用的方法，但它们其实还有很多内容可以讲。如果你想更加深入地了解，我极力推荐你查阅 <a href="http://reactivex.io/documentation/operators.html#creating">文档</a> 或者阅读相关文章。</p>
<p><a href="https://rxviz.com/">RxViz</a> 是另一种值得了解的有意思的方式。你编写 RxJS 代码，产生的流可以用图形或动画进行显示。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>