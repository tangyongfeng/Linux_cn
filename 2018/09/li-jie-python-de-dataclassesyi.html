<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>理解 Python 的 Dataclasses（一）</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Shikhar Chauhan 如果你正在阅读本文，那么你已经意识到了 Python 3.7 以及它所包含的新特性。就我个人而言，我对 Dataclasses 感到非常兴奋，因 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2018/09/li-jie-python-de-dataclassesyi.html" rel="bookmark"
           title="Permalink to 理解 Python 的 Dataclasses（一）">理解 Python 的 Dataclasses（一）</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-09-02T21:58:40+02:00">
                Published: Sun 02 September 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Shikhar Chauhan</p>
<p><img alt="" src="/data/attachment/album/201809/02/215843ybbbu9wemwrzazwm.png"></p>
<p>如果你正在阅读本文，那么你已经意识到了 Python 3.7 以及它所包含的新特性。就我个人而言，我对 <code>Dataclasses</code> 感到非常兴奋，因为我等了它一段时间了。</p>
<p>本系列包含两部分：</p>
<ol>
<li>Dataclass 特点概述</li>
<li>在下一篇文章概述 Dataclass 的 <code>fields</code></li>
</ol>
<h3>介绍</h3>
<p><code>Dataclasses</code> 是 Python 的类（LCTT 译注：更准确的说，它是一个模块），适用于存储数据对象。你可能会问什么是数据对象？下面是定义数据对象的一个不太详细的特性列表：</p>
<ul>
<li>它们存储数据并代表某种数据类型。例如：一个数字。对于熟悉 ORM 的人来说，模型实例就是一个数据对象。它代表一种特定的实体。它包含那些定义或表示实体的属性。</li>
<li>它们可以与同一类型的其他对象进行比较。例如：一个数字可以是 <code>greater than</code>（大于）、<code>less than</code>（小于） 或 <code>equal</code>（等于） 另一个数字。</li>
</ul>
<p>当然还有更多的特性，但是这个列表足以帮助你理解问题的关键。</p>
<p>为了理解 <code>Dataclasses</code>，我们将实现一个包含数字的简单类，并允许我们执行上面提到的操作。</p>
<p>首先，我们将使用普通类，然后我们再使用 <code>Dataclasses</code> 来实现相同的结果。</p>
<p>但在我们开始之前，先来谈谈 <code>Dataclasses</code> 的用法。</p>
<p>Python 3.7 提供了一个装饰器 <a href="https://docs.python.org/3.7/library/dataclasses.html#dataclasses.dataclass">dataclass</a>，用于将类转换为 <code>dataclass</code>。</p>
<p>你所要做的就是将类包在装饰器中：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">dataclasses</span> <span class="kn">import</span> <span class="n">dataclass</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
 <span class="o">...</span>
</code></pre></div>

<p>现在，让我们深入了解一下 <code>dataclass</code> 带给我们的变化和用途。</p>
<h3>初始化</h3>
<p>通常是这样：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="n">Number:</span>

    <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="nb">val</span>):
        <span class="nb">self</span>.<span class="nb">val</span> = <span class="nb">val</span>

&gt;&gt;&gt; <span class="nb">one</span> = <span class="n">Number</span>(<span class="mi">1</span>)
&gt;&gt;&gt; <span class="nb">one</span>.<span class="nb">val</span>
&gt;&gt;&gt; <span class="mi">1</span>
</code></pre></div>

<p>用 <code>dataclass</code> 是这样：</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Number</span><span class="p">:</span>
<span class="w">    </span><span class="nl">val</span><span class="p">:</span><span class="nc">int</span><span class="w"> </span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">one</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">one</span><span class="p">.</span><span class="n">val</span>
<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mi">1</span>
</code></pre></div>

<p>以下是 <code>dataclass</code> 装饰器带来的变化：</p>
<ol>
<li>无需定义 <code>__init__</code>，然后将值赋给 <code>self</code>，<code>dataclass</code> 负责处理它（LCTT 译注：此处原文可能有误，提及一个不存在的 <code>d</code>）</li>
<li>我们以更加易读的方式预先定义了成员属性，以及<a href="https://stackoverflow.com/q/32557920/4333721">类型提示</a>。我们现在立即能知道 <code>val</code> 是 <code>int</code> 类型。这无疑比一般定义类成员的方式更具可读性。</li>
</ol>
<blockquote>
<p>Python 之禅: 可读性很重要</p>
</blockquote>
<p>它也可以定义默认值：</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Number</span><span class="p">:</span>
<span class="w">    </span><span class="nl">val</span><span class="p">:</span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<h3>表示</h3>
<p>对象表示指的是对象的一个有意义的字符串表示，它在调试时非常有用。</p>
<p>默认的 Python 对象表示不是很直观：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="n">Number:</span>
    <span class="n">def</span> <span class="n">__init__</span>(<span class="nb">self</span>, <span class="nb">val</span> = <span class="mi">0</span>):
    <span class="nb">self</span>.<span class="nb">val</span> = <span class="nb">val</span>

&gt;&gt;&gt; <span class="n">a</span> = <span class="n">Number</span>(<span class="mi">1</span>)
&gt;&gt;&gt; <span class="n">a</span>
&gt;&gt;&gt; <span class="s">&lt;__main__.Number object at 0x7ff395b2ccc0&gt;</span>
</code></pre></div>

<p>这让我们无法知悉对象的作用，并且会导致糟糕的调试体验。</p>
<p>一个有意义的表示可以通过在类中定义一个 <code>__repr__</code> 方法来实现。</p>
<div class="highlight"><pre><span></span><code>def __repr__(self):
    return self.val
</code></pre></div>

<p>现在我们得到这个对象有意义的表示：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = Number(1)
&gt;&gt;&gt; a
&gt;&gt;&gt; 1
</code></pre></div>

<p><code>dataclass</code> 会自动添加一个 <code>__repr__</code>  函数，这样我们就不必手动实现它了。</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Number</span><span class="p">:</span>
<span class="w">    </span><span class="nl">val</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = Number(1)
&gt;&gt;&gt; a
&gt;&gt;&gt; Number(val = 1)
</code></pre></div>

<h3>数据比较</h3>
<p>通常，数据对象之间需要相互比较。</p>
<p>两个对象 <code>a</code> 和 <code>b</code> 之间的比较通常包括以下操作：</p>
<ul>
<li><code>a &lt; b</code></li>
<li><code>a &gt; b</code></li>
<li><code>a == b</code></li>
<li><code>a &gt;= b</code></li>
<li><code>a &lt;= b</code></li>
</ul>
<p>在 Python 中，能够在可以执行上述操作的类中定义<a href="https://docs.python.org/3/reference/datamodel.html#object.__lt__">方法</a>。为了简单起见，不让这篇文章过于冗长，我将只展示 <code>==</code> 和 <code>&lt;</code> 的实现。</p>
<p>通常这样写：</p>
<div class="highlight"><pre><span></span><code><span class="k">class</span> <span class="n">Number:</span>
    <span class="n">def</span> <span class="n">__init__</span>( <span class="nb">self</span>, <span class="nb">val</span> = <span class="mi">0</span>):
       <span class="nb">self</span>.<span class="nb">val</span> = <span class="nb">val</span>

    <span class="n">def</span> <span class="n">__eq__</span>(<span class="nb">self</span>, <span class="n">other</span>):
        <span class="k">return</span> <span class="nb">self</span>.<span class="nb">val</span> == <span class="n">other</span>.<span class="nb">val</span>

    <span class="n">def</span> <span class="n">__lt__</span>(<span class="nb">self</span>, <span class="n">other</span>):
        <span class="k">return</span> <span class="nb">self</span>.<span class="nb">val</span> &lt; <span class="n">other</span>.<span class="nb">val</span>
</code></pre></div>

<p>使用 <code>dataclass</code>：</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span><span class="p">(</span><span class="k">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Number</span><span class="p">:</span>
<span class="w">    </span><span class="nl">val</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<p>是的，就是这样简单。</p>
<p>我们不需要定义 <code>__eq__</code> 和 <code>__lt__</code> 方法，因为当 <code>order = True</code> 被调用时，<code>dataclass</code> 装饰器会自动将它们添加到我们的类定义中。</p>
<p>那么，它是如何做到的呢？</p>
<p>当你使用 <code>dataclass</code> 时，它会在类定义中添加函数 <code>__eq__</code> 和 <code>__lt__</code> 。我们已经知道这点了。那么，这些函数是怎样知道如何检查相等并进行比较呢？</p>
<p>生成 <code>__eq__</code> 函数的 <code>dataclass</code> 类会比较两个属性构成的元组，一个由自己属性构成的，另一个由同类的其他实例的属性构成。在我们的例子中，<code>自动</code>生成的 <code>__eq__</code> 函数相当于：</p>
<div class="highlight"><pre><span></span><code>def __eq__(self, other):
    return (self.val,) == (other.val,)
</code></pre></div>

<p>让我们来看一个更详细的例子：</p>
<p>我们会编写一个 <code>dataclass</code> 类 <code>Person</code> 来保存 <code>name</code> 和 <code>age</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span><span class="p">(</span><span class="k">order</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Person</span><span class="p">:</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="nf">str</span>
<span class="w">    </span><span class="nl">age</span><span class="p">:</span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<p>自动生成的 <code>__eq__</code> 方法等同于：</p>
<div class="highlight"><pre><span></span><code>def __eq__(self, other):
    return (self.name, self.age) == ( other.name, other.age)
</code></pre></div>

<p>请注意属性的顺序。它们总是按照你在 <code>dataclass</code> 类中定义的顺序生成。</p>
<p>同样，等效的 <code>__le__</code> 函数类似于：</p>
<div class="highlight"><pre><span></span><code>def __le__(self, other):
    return (self.name, self.age) &lt;= (other.name, other.age)
</code></pre></div>

<p>当你需要对数据对象列表进行排序时，通常会出现像 <code>__le__</code> 这样的函数的定义。Python 内置的 <a href="https://docs.python.org/3.7/library/functions.html#sorted">sorted</a> 函数依赖于比较两个对象。</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">import</span> <span class="nn">random</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="p">[</span><span class="n">Number</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span> <span class="c1">#generate list of random numbers</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">7</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">9</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">7</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">sorted_a</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="c1">#Sort Numbers in ascending order</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">7</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">7</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">9</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">)]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">reverse_sorted_a</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">reverse</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="c1">#Sort Numbers in descending order </span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">reverse_sorted_a</span>

<span class="o">&gt;&gt;&gt;</span> <span class="p">[</span><span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">10</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">9</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">7</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">7</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">6</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">5</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">2</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="n">Number</span><span class="p">(</span><span class="n">val</span><span class="o">=</span><span class="mi">1</span><span class="p">)]</span>
</code></pre></div>

<h3><code>dataclass</code> 作为一个可调用的装饰器</h3>
<p>定义所有的 <code>dunder</code>（LCTT 译注：这是指双下划线方法，即魔法方法）方法并不总是值得的。你的用例可能只包括存储值和检查相等性。因此，你只需定义 <code>__init__</code> 和 <code>__eq__</code> 方法。如果我们可以告诉装饰器不生成其他方法，那么它会减少一些开销，并且我们将在数据对象上有正确的操作。</p>
<p>幸运的是，这可以通过将 <code>dataclass</code> 装饰器作为可调用对象来实现。</p>
<p>从官方<a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.dataclass">文档</a>来看，装饰器可以用作具有如下参数的可调用对象：</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span><span class="p">(</span><span class="n">init</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="w"> </span><span class="n">repr</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="w"> </span><span class="n">eq</span><span class="o">=</span><span class="k">True</span><span class="p">,</span><span class="w"> </span><span class="k">order</span><span class="o">=</span><span class="k">False</span><span class="p">,</span><span class="w"> </span><span class="n">unsafe_hash</span><span class="o">=</span><span class="k">False</span><span class="p">,</span><span class="w"> </span><span class="n">frozen</span><span class="o">=</span><span class="k">False</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nl">C</span><span class="p">:</span>
<span class="w"> </span><span class="err">…</span>
</code></pre></div>

<ol>
<li><code>init</code>：默认将生成 <code>__init__</code> 方法。如果传入 <code>False</code>，那么该类将不会有 <code>__init__</code> 方法。</li>
<li><code>repr</code>：<code>__repr__</code> 方法默认生成。如果传入 <code>False</code>，那么该类将不会有 <code>__repr__</code> 方法。</li>
<li><code>eq</code>：默认将生成 <code>__eq__</code> 方法。如果传入 <code>False</code>，那么 <code>__eq__</code> 方法将不会被 <code>dataclass</code> 添加，但默认为 <code>object.__eq__</code>。</li>
<li><code>order</code>：默认将生成 <code>__gt__</code>、<code>__ge__</code>、<code>__lt__</code>、<code>__le__</code> 方法。如果传入 <code>False</code>，则省略它们。</li>
</ol>
<p>我们在接下来会讨论 <code>frozen</code>。由于 <code>unsafe_hash</code> 参数复杂的用例，它值得单独发布一篇文章。</p>
<p>现在回到我们的用例，以下是我们需要的：</p>
<ol>
<li><code>__init__</code>  </li>
<li><code>__eq__</code></li>
</ol>
<p>默认会生成这些函数，因此我们需要的是不生成其他函数。那么我们该怎么做呢？很简单，只需将相关参数作为 false 传入给生成器即可。</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span><span class="p">(</span><span class="n">repr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">False</span><span class="p">)</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="k">order</span><span class="p">,</span><span class="w"> </span><span class="n">unsafe_hash</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="n">frozen</span><span class="w"> </span><span class="k">are</span><span class="w"> </span><span class="k">False</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Number</span><span class="p">:</span>
<span class="w">    </span><span class="nl">val</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>


<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="o">&lt;</span><span class="n">__main__</span><span class="p">.</span><span class="n">Number</span><span class="w"> </span><span class="k">object</span><span class="w"> </span><span class="k">at</span><span class="w"> </span><span class="mh">0x7ff395afe898</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Number</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">b</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="k">False</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">b</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">Traceback</span><span class="w"> </span><span class="p">(</span><span class="n">most</span><span class="w"> </span><span class="n">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">last</span><span class="p">)</span><span class="err">:</span>
<span class="w"> </span><span class="k">File</span><span class="w"> </span><span class="err">“</span><span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="o">&lt;</span><span class="k">module</span><span class="o">&gt;</span>
<span class="nl">TypeError</span><span class="p">:</span><span class="w"> </span><span class="err">‘</span><span class="o">&lt;</span><span class="err">’</span><span class="w"> </span><span class="ow">not</span><span class="w"> </span><span class="n">supported</span><span class="w"> </span><span class="ow">between</span><span class="w"> </span><span class="n">instances</span><span class="w"> </span><span class="k">of</span><span class="w"> </span><span class="err">‘</span><span class="n">Number</span><span class="err">’</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="err">‘</span><span class="n">Number</span><span class="err">’</span>
</code></pre></div>

<h3>Frozen（不可变） 实例</h3>
<p>Frozen 实例是在初始化对象后无法修改其属性的对象。</p>
<blockquote>
<p>无法创建真正不可变的 Python 对象</p>
</blockquote>
<p>在 Python 中创建对象的不可变属性是一项艰巨的任务，我将不会在本篇文章中深入探讨。</p>
<p>以下是我们期望不可变对象能够做到的：</p>
<div class="highlight"><pre><span></span><code>&gt;&gt;&gt; a = Number(10) #Assuming Number class is immutable

&gt;&gt;&gt; a.val = 10 # Raises Error
</code></pre></div>

<p>有了 <code>dataclass</code>，就可以通过使用 <code>dataclass</code> 装饰器作为可调用对象配合参数 <code>frozen=True</code> 来定义一个 <code>frozen</code> 对象。</p>
<p>当实例化一个 <code>frozen</code> 对象时，任何企图修改对象属性的行为都会引发 <code>FrozenInstanceError</code>。</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">True</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Number</span><span class="p">:</span>
<span class="w">    </span><span class="nl">val</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Number</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">val</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">Traceback</span><span class="w"> </span><span class="p">(</span><span class="n">most</span><span class="w"> </span><span class="n">recent</span><span class="w"> </span><span class="k">call</span><span class="w"> </span><span class="k">last</span><span class="p">)</span><span class="err">:</span>
<span class="w"> </span><span class="k">File</span><span class="w"> </span><span class="err">“</span><span class="o">&lt;</span><span class="n">stdin</span><span class="o">&gt;</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="o">&lt;</span><span class="k">module</span><span class="o">&gt;</span>
<span class="w"> </span><span class="k">File</span><span class="w"> </span><span class="err">“</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span><span class="err">”</span><span class="p">,</span><span class="w"> </span><span class="n">line</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">__setattr__</span>
<span class="n">dataclasses</span><span class="p">.</span><span class="nl">FrozenInstanceError</span><span class="p">:</span><span class="w"> </span><span class="n">cannot</span><span class="w"> </span><span class="n">assign</span><span class="w"> </span><span class="k">to</span><span class="w"> </span><span class="n">field</span><span class="w"> </span><span class="err">‘</span><span class="n">val</span><span class="err">’</span>
</code></pre></div>

<p>因此，一个 <code>frozen</code> 实例是一种很好方式来存储：</p>
<ul>
<li>常数</li>
<li>设置</li>
</ul>
<p>这些通常不会在应用程序的生命周期内发生变化，任何企图修改它们的行为都应该被禁止。</p>
<h3>后期初始化处理</h3>
<p>有了 <code>dataclass</code>，需要定义一个 <code>__init__</code> 方法来将变量赋给 <code>self</code> 这种初始化操作已经得到了处理。但是我们失去了在变量被赋值之后立即需要的函数调用或处理的灵活性。</p>
<p>让我们来讨论一个用例，在这个用例中，我们定义一个 <code>Float</code> 类来包含浮点数，然后在初始化之后立即计算整数和小数部分。</p>
<p>通常是这样：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">math</span>

<span class="k">class</span> <span class="nc">Float</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">val</span> <span class="o">=</span> <span class="n">val</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">integer</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Float</span><span class="p">(</span> <span class="mf">2.2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">decimal</span>

<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.2000</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">integer</span>

<span class="o">&gt;&gt;&gt;</span> <span class="mf">2.0</span>
</code></pre></div>

<p>幸运的是，使用 <a href="https://docs.python.org/3/library/dataclasses.html#post-init-processing"><strong>post_init</strong></a> 方法已经能够处理后期初始化操作。</p>
<p>生成的 <code>__init__</code> 方法在返回之前调用 <code>__post_init__</code> 返回。因此，可以在函数中进行任何处理。</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">math</span>

<span class="nd">@dataclass</span>
<span class="k">class</span> <span class="nc">FloatNumber</span><span class="p">:</span>
    <span class="n">val</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span>

    <span class="k">def</span> <span class="nf">__post_init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">decimal</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">integer</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">modf</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">val</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="n">Number</span><span class="p">(</span><span class="mf">2.2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">val</span>

<span class="o">&gt;&gt;&gt;</span> <span class="mf">2.2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">integer</span>

<span class="o">&gt;&gt;&gt;</span> <span class="mf">2.0</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">a</span><span class="o">.</span><span class="n">decimal</span>

<span class="o">&gt;&gt;&gt;</span> <span class="mf">0.2</span>
</code></pre></div>

<p>多么方便！</p>
<h3>继承</h3>
<p><code>Dataclasses</code> 支持继承，就像普通的 Python 类一样。</p>
<p>因此，父类中定义的属性将在子类中可用。</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nl">Person</span><span class="p">:</span>
<span class="w">    </span><span class="nl">age</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">    </span><span class="nl">name</span><span class="p">:</span><span class="w"> </span><span class="nf">str</span>

<span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="n">Student</span><span class="p">(</span><span class="n">Person</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="nl">grade</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Student</span><span class="p">(</span><span class="mi">20</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;John Doe&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">12</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">age</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mi">20</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">name</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="ss">&quot;John Doe&quot;</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">s</span><span class="p">.</span><span class="n">grade</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="mi">12</span>
</code></pre></div>

<p>请注意，<code>Student</code> 的参数是在类中定义的字段的顺序。</p>
<p>继承过程中 <code>__post_init__</code> 的行为是怎样的？</p>
<p>由于 <code>__post_init__</code> 只是另一个函数，因此必须以传统方式调用它：</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="nl">A</span><span class="p">:</span>
<span class="w">    </span><span class="nl">a</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span>

<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">__post_init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="ss">&quot;A&quot;</span><span class="p">)</span>

<span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="nl">b</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span>

<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">__post_init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="ss">&quot;B&quot;</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">B</span>
</code></pre></div>

<p>在上面的例子中，只有 <code>B</code> 的 <code>__post_init__</code> 被调用，那么我们如何调用 <code>A</code> 的 <code>__post_init__</code> 呢？</p>
<p>因为它是父类的函数，所以可以用 <code>super</code> 来调用它。</p>
<div class="highlight"><pre><span></span><code><span class="nv">@dataclass</span>
<span class="k">class</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="err">:</span>
<span class="w">    </span><span class="nl">b</span><span class="p">:</span><span class="w"> </span><span class="nc">int</span>

<span class="w">    </span><span class="n">def</span><span class="w"> </span><span class="n">__post_init__</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="err">:</span>
<span class="w">        </span><span class="n">super</span><span class="p">().</span><span class="n">__post_init__</span><span class="p">()</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="n">调用</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="n">的</span><span class="w"> </span><span class="n">post</span><span class="w"> </span><span class="n">init</span>
<span class="w">        </span><span class="k">print</span><span class="p">(</span><span class="ss">&quot;B&quot;</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">B</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span><span class="w"> </span><span class="n">A</span>
<span class="w">    </span><span class="n">B</span>
</code></pre></div>

<h3>结论</h3>
<p>因此，以上是 <code>dataclass</code> 使 Python 开发人员变得更轻松的几种方法。</p>
<p>我试着彻底覆盖大部分的用例，但是，没有人是完美的。如果你发现了错误，或者想让我注意相关的用例，请联系我。</p>
<p>我将在另一篇文章中介绍 <a href="https://docs.python.org/3/library/dataclasses.html#dataclasses.field">dataclasses.field</a> 和 <code>unsafe_hash</code>。</p>
<p>在 <a href="http://github.com/xssChauhan/">Github</a> 和 <a href="https://twitter.com/xssChauhan">Twitter</a> 关注我。</p>
<p>更新：<code>dataclasses.field</code> 的文章可以在<a href="https://medium.com/@xsschauhan/understanding-python-dataclasses-part-2-660ecc11c9b8">这里</a>找到。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>