<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>Linux DNS 查询剖析（第四部分）</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Zwischenzugs 在 Linux DNS 查询剖析（第一部分），Linux DNS 查询剖析（第二部分） 和 Linux DNS 查询剖析（第三部分） 中，我们已经介绍了以下内容： nsswitch /etc/hosts /etc …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li class="active"><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2018/09/linux-dns-cha-xun-pou-xi-di-si-bu-fen.html" rel="bookmark"
           title="Permalink to Linux DNS 查询剖析（第四部分）">Linux DNS 查询剖析（第四部分）</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-09-27T22:02:33+02:00">
                Published: Thu 27 September 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ji-zhu">技术</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Zwischenzugs</p>
<p><img alt="" src="/data/attachment/album/201809/27/220200ozwwbwyizwydadi0.jpeg"></p>
<p>在 <a href="/article-9943-1.html">Linux DNS 查询剖析（第一部分）</a>，<a href="/article-9949-1.html">Linux DNS 查询剖析（第二部分）</a> 和 <a href="/article-9972-1.html">Linux DNS 查询剖析（第三部分）</a> 中，我们已经介绍了以下内容：</p>
<ul>
<li><code>nsswitch</code></li>
<li><code>/etc/hosts</code></li>
<li><code>/etc/resolv.conf</code></li>
<li><code>ping</code> 与 <code>host</code> 查询方式的对比</li>
<li><code>systemd</code> 和对应的 <code>networking</code> 服务</li>
<li><code>ifup</code> 和 <code>ifdown</code></li>
<li><code>dhclient</code></li>
<li><code>resolvconf</code></li>
<li><code>NetworkManager</code></li>
<li><code>dnsmasq</code></li>
</ul>
<p>在第四部分中，我将介绍容器如何完成 DNS 查询。你想的没错，也不是那么简单。</p>
<h3>1) Docker 和 DNS</h3>
<p>在 <a href="/article-9972-1.html">Linux DNS 查询剖析（第三部分）</a> 中，我们介绍了 <code>dnsmasq</code>，其工作方式如下：将 DNS 查询指向到 localhost 地址 <code>127.0.0.1</code>，同时启动一个进程监听 <code>53</code> 端口并处理查询请求。</p>
<p>在按上述方式配置 DNS 的主机上，如果运行了一个 Docker 容器，容器内的 <code>/etc/resolv.conf</code> 文件会是怎样的呢？</p>
<p>我们来动手试验一下吧。</p>
<p>按照默认 Docker 创建流程，可以看到如下的默认输出：</p>
<div class="highlight"><pre><span></span><code>$<span class="w">  </span>docker<span class="w"> </span>run<span class="w">  </span>ubuntu<span class="w"> </span>cat<span class="w"> </span>/etc/resolv.conf
<span class="c1"># Dynamic resolv.conf(5) file for glibc resolver(3) generated by resolvconf(8)</span>
<span class="c1">#     DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN</span>
<span class="c1"># 127.0.0.53 is the systemd-resolved stub resolver.</span>
<span class="c1"># run &quot;systemd-resolve --status&quot; to see details about the actual nameservers.</span>

search<span class="w"> </span>home
nameserver<span class="w"> </span><span class="m">8</span>.8.8.8
nameserver<span class="w"> </span><span class="m">8</span>.8.4.4
</code></pre></div>

<p>奇怪！</p>
<h4>地址 <code>8.8.8.8</code> 和 <code>8.8.4.4</code> 从何而来呢？</h4>
<p>当我思考容器内的 <code>/etc/resolv.conf</code> 配置时，我的第一反应是继承主机的 <code>/etc/resolv.conf</code>。但只要稍微进一步分析，就会发现这样并不总是有效的。</p>
<p>如果在主机上配置了 <code>dnsmasq</code>，那么 <code>/etc/resolv.conf</code> 文件总会指向 <code>127.0.0.1</code> 这个<ruby> 回环地址 <rt>  loopback address </rt></ruby>。如果这个地址被容器继承，容器会在其本身的<ruby> 网络上下文 <rt>  networking context </rt></ruby>中使用；由于容器内并没有运行（在 <code>127.0.0.1</code> 地址的）DNS 服务器，因此 DNS 查询都会失败。</p>
<p>“有了！”你可能有了新主意：将 主机的 的 IP 地址用作 DNS 服务器地址，其中这个 IP 地址可以从容器的<ruby> 默认路由 <rt>  default route </rt></ruby>中获取：</p>
<div class="highlight"><pre><span></span><code><span class="n">root</span><span class="mi">@79</span><span class="n">a95170e679</span><span class="o">:/</span><span class="err">#</span><span class="w"> </span><span class="n">ip</span><span class="w"> </span><span class="n">route</span>
<span class="k">default</span><span class="w"> </span><span class="n">via</span><span class="w"> </span><span class="mf">172.17.0.1</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="n">eth0</span>
<span class="mf">172.17.0.0</span><span class="o">/</span><span class="mi">16</span><span class="w"> </span><span class="n">dev</span><span class="w"> </span><span class="n">eth0</span><span class="w"> </span><span class="n">proto</span><span class="w"> </span><span class="n">kernel</span><span class="w"> </span><span class="n">scope</span><span class="w"> </span><span class="n">link</span><span class="w"> </span><span class="n">src</span><span class="w"> </span><span class="mf">172.17.0.2</span>
</code></pre></div>

<h4>使用主机 IP 地址真的可行吗？</h4>
<p>从默认路由中，我们可以找到主机的 IP 地址 <code>172.17.0.1</code>，进而可以通过手动指定 DNS 服务器的方式进行测试（你也可以更新 <code>/etc/resolv.conf</code> 文件并使用 <code>ping</code> 进行测试；但我觉得这里很适合介绍新的 <code>dig</code> 工具及其 <code>@</code> 参数，后者用于指定需要查询的 DNS 服务器地址）：</p>
<div class="highlight"><pre><span></span><code><span class="n">root</span><span class="mi">@79</span><span class="n">a95170e679</span><span class="o">:/</span><span class="err">#</span><span class="w"> </span><span class="n">dig</span><span class="w"> </span><span class="mf">@172.17.0.1</span><span class="w"> </span><span class="n">google</span><span class="p">.</span><span class="n">com</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="o">-</span><span class="n">A1</span><span class="w"> </span><span class="n">ANSWER</span><span class="p">.</span><span class="n">SECTION</span>
<span class="p">;;</span><span class="w"> </span><span class="n">ANSWER</span><span class="w"> </span><span class="n">SECTION</span><span class="o">:</span>
<span class="n">google</span><span class="p">.</span><span class="n">com</span><span class="p">.</span><span class="w">             </span><span class="mi">112</span><span class="w">     </span><span class="n">IN</span><span class="w">      </span><span class="n">A</span><span class="w">       </span><span class="mf">172.217.23.14</span>
</code></pre></div>

<p>但是还有一个问题，这种方式仅适用于主机配置了 <code>dnsmasq</code> 的情况；如果主机没有配置 <code>dnsmasq</code>，主机上并不存在用于查询的 DNS 服务器。</p>
<p>在这个问题上，Docker 的解决方案是忽略所有可能的复杂情况，即无论主机中使用什么 DNS 服务器，容器内都使用 Google 的 DNS 服务器 <code>8.8.8.8</code> 和 <code>8.8.4.4</code> 完成 DNS 查询。</p>
<p>我的经历：在 2013 年，我遇到了使用 Docker 以来的第一个问题，与 Docker 的这种 DNS 解决方案密切相关。我们公司的网络屏蔽了 <code>8.8.8.8</code> 和 <code>8.8.4.4</code>，导致容器无法解析域名。</p>
<p>这就是 Docker 容器的情况，但对于包括 Kubernetes 在内的容器 <ruby> 编排引擎 <rt>  orchestrators </rt></ruby>，情况又有些不同。</p>
<h3>2) Kubernetes 和 DNS</h3>
<p>在 Kubernetes 中，最小部署单元是 pod；它是一组相互协作的容器，共享 IP 地址（和其它资源）。</p>
<p>Kubernetes 面临的一个额外的挑战是，将 Kubernetes 服务请求（例如，<code>myservice.kubernetes.io</code>）通过对应的<ruby> 解析器 <rt>  resolver </rt></ruby>，转发到具体服务地址对应的<ruby> 内网地址 <rt>  private network </rt></ruby>。这里提到的服务地址被称为归属于“<ruby> 集群域 <rt>  cluster domain </rt></ruby>”。集群域可由管理员配置，根据配置可以是 <code>cluster.local</code> 或 <code>myorg.badger</code> 等。</p>
<p>在 Kubernetes 中，你可以为 pod 指定如下四种 pod 内 DNS 查询的方式。</p>
<p><strong>Default</strong></p>
<p>在这种（名称容易让人误解）的方式中，pod 与其所在的主机采用相同的 DNS 查询路径，与前面介绍的主机 DNS 查询一致。我们说这种方式的名称容易让人误解，因为该方式并不是默认选项！<code>ClusterFirst</code> 才是默认选项。</p>
<p>如果你希望覆盖 <code>/etc/resolv.conf</code> 中的条目，你可以添加到 <code>kubelet</code> 的配置中。</p>
<p><strong>ClusterFirst</strong></p>
<p>在 <code>ClusterFirst</code> 方式中，遇到 DNS 查询请求会做有选择的转发。根据配置的不同，有以下两种方式：</p>
<p>第一种方式配置相对古老但更简明，即采用一个规则：如果请求的域名不是集群域的子域，那么将其转发到 pod 所在的主机。</p>
<p>第二种方式相对新一些，你可以在内部 DNS 中配置选择性转发。</p>
<p>下面给出示例配置并从 <a href="https://kubernetes.io/docs/tasks/administer-cluster/dns-custom-nameservers/#impacts-on-pods">Kubernetes 文档</a>中选取一张图说明流程：</p>
<div class="highlight"><pre><span></span><code><span class="n">apiVersion</span><span class="o">:</span><span class="w"> </span><span class="n">v1</span>
<span class="n">kind</span><span class="o">:</span><span class="w"> </span><span class="n">ConfigMap</span>
<span class="n">metadata</span><span class="o">:</span>
<span class="w">  </span><span class="n">name</span><span class="o">:</span><span class="w"> </span><span class="n">kube</span><span class="o">-</span><span class="n">dns</span>
<span class="w">  </span><span class="kd">namespace</span><span class="o">:</span><span class="w"> </span><span class="n">kube</span><span class="o">-</span><span class="n">system</span>
<span class="n">data</span><span class="o">:</span>
<span class="w">  </span><span class="n">stubDomains</span><span class="o">:</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="o">{</span><span class="s2">&quot;acme.local&quot;</span><span class="o">:</span><span class="w"> </span><span class="o">[</span><span class="s2">&quot;1.2.3.4&quot;</span><span class="o">]}</span>
<span class="w">  </span><span class="n">upstreamNameservers</span><span class="o">:</span><span class="w"> </span><span class="o">|</span>
<span class="w">    </span><span class="o">[</span><span class="s2">&quot;8.8.8.8&quot;</span><span class="o">,</span><span class="w"> </span><span class="s2">&quot;8.8.4.4&quot;</span><span class="o">]</span>
</code></pre></div>

<p>在 <code>stubDomains</code> 条目中，可以为特定域名指定特定的 DNS 服务器；而 <code>upstreamNameservers</code> 条目则给出，待查询域名不是集群域子域情况下用到的 DNS 服务器。</p>
<p>这是通过在一个 pod 中运行我们熟知的 <code>dnsmasq</code> 实现的。</p>
<p><img alt="kubedns" src="/data/attachment/album/201809/27/220238y708309mckx80x8k.png"></p>
<p>剩下两种选项都比较小众：</p>
<p><strong>ClusterFirstWithHostNet</strong></p>
<p>适用于 pod 使用主机网络的情况，例如绕开 Docker 网络配置，直接使用与 pod 对应主机相同的网络。</p>
<p><strong>None</strong></p>
<p><code>None</code> 意味着不改变 DNS，但强制要求你在 <code>pod</code> <ruby> 规范文件 <rt>  specification </rt></ruby>的 <code>dnsConfig</code> 条目中指定 DNS 配置。</p>
<h3>CoreDNS 即将到来</h3>
<p>除了上面提到的那些，一旦 <code>CoreDNS</code> 取代 Kubernetes 中的 <code>kube-dns</code>，情况还会发生变化。<code>CoreDNS</code> 相比 <code>kube-dns</code> 具有可配置性更高、效率更高等优势。</p>
<p>如果想了解更多，参考<a href="https://coredns.io/">这里</a>。</p>
<p>如果你对 OpenShift 的网络感兴趣，我曾写过一篇<a href="https://zwischenzugs.com/2017/10/21/openshift-3-6-dns-in-pictures/">文章</a>可供你参考。但文章中 OpenShift 的版本是 3.6，可能有些过时。</p>
<h3>第四部分总结</h3>
<p>第四部分到此结束，其中我们介绍了：</p>
<ul>
<li>Docker DNS 查询</li>
<li>Kubernetes DNS 查询</li>
<li>选择性转发（子域不转发）</li>
<li>kube-dns</li>
</ul>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>