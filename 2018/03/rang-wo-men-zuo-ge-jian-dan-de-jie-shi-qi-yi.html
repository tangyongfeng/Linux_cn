<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>让我们做个简单的解释器（一）</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Ruslan Spivak “如果你不知道编译器是怎么工作的，那你就不知道电脑是怎么工作的。如果你不能百分百确定，那就是不知道它们 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2018/03/rang-wo-men-zuo-ge-jian-dan-de-jie-shi-qi-yi.html" rel="bookmark"
           title="Permalink to 让我们做个简单的解释器（一）">让我们做个简单的解释器（一）</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2018-03-04T09:41:00+01:00">
                Published: Sun 04 March 2018
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Ruslan Spivak</p>
<blockquote>
<p>“如果你不知道编译器是怎么工作的，那你就不知道电脑是怎么工作的。如果你不能百分百确定，那就是不知道它们是如何工作的。” --Steve Yegge</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/201803/02/214643pynf6qfpbbjn2u24.jpg"></p>
<p>就是这样。想一想。你是萌新还是一个资深的软件开发者实际上都无关紧要：如果你不知道<ruby> 编译器 <rt>  compiler </rt></ruby>和<ruby> 解释器 <rt>  interpreter </rt></ruby>是怎么工作的，那么你就不知道电脑是怎么工作的。就这么简单。</p>
<p>所以，你知道编译器和解释器是怎么工作的吗？我是说，你百分百确定自己知道他们怎么工作吗？如果不知道。</p>
<p><img alt="" src="/data/attachment/album/201803/02/214840x9f799pyckc7ctff.png"></p>
<p>或者如果你不知道但你非常想要了解它。</p>
<p><img alt="" src="/data/attachment/album/201803/02/214841ccotc0dtv02cntz0.png"></p>
<p>不用担心。如果你能坚持跟着这个系列做下去，和我一起构建一个解释器和编译器，最后你将会知道他们是怎么工作的。并且你会变成一个自信满满的快乐的人。至少我希望如此。</p>
<p><img alt="" src="/data/attachment/album/201803/02/214845kn35skqb3u00qb43.png"></p>
<p>为什么要学习编译器和解释器？有三点理由。</p>
<ol>
<li>要写出一个解释器或编译器，你需要有很多的专业知识，并能融会贯通。写一个解释器或编译器能帮你加强这些能力，成为一个更厉害的软件开发者。而且，你要学的技能对编写软件非常有用，而不是仅仅局限于解释器或编译器。</li>
<li>你确实想要了解电脑是怎么工作的。通常解释器和编译器看上去很魔幻。你或许不习惯这种魔力。你会想去揭开构建解释器和编译器那层神秘的面纱，了解它们的原理，把事情做好。</li>
<li>你想要创建自己的编程语言或者特定领域的语言。如果你创建了一个，你还要为它创建一个解释器或者编译器。最近，兴起了对新的编程语言的兴趣。你能看到几乎每天都有一门新的编程语言横空出世：Elixir，Go，Rust，还有很多。</li>
</ol>
<p>好，但什么是解释器和编译器？</p>
<p><strong>解释器</strong> 和 <strong>编译器</strong> 的任务是把用高级语言写的源程序翻译成其他的格式。很奇怪，是不是？忍一忍，稍后你会在这个系列学到到底把源程序翻译成什么东西。</p>
<p>这时你可能会奇怪解释器和编译器之间有什么区别。为了实现这个系列的目的，我们规定一下，如果有个翻译器把源程序翻译成机器语言，那它就是 <strong>编译器</strong>。如果一个翻译器可以处理并执行源程序，却不用把它翻译器机器语言，那它就是 <strong>解释器</strong>。直观上它看起来像这样：</p>
<p><img alt="" src="/data/attachment/album/201803/02/214846mfc4vhixlgkfjxlz.png"></p>
<p>我希望你现在确信你很想学习构建一个编译器和解释器。你期望在这个教程里学习解释器的哪些知识呢？</p>
<p>你看这样如何。你和我一起为 <a href="https://en.wikipedia.org/wiki/Pascal_%28programming_language%29">Pascal</a> 语言的一个大子集做一个简单的解释器。在这个系列结束的时候你能做出一个可以运行的 Pascal 解释器和一个像 Python 的 <a href="https://docs.python.org/2/library/pdb.html">pdb</a> 那样的源代码级别的调试器。</p>
<p>你或许会问，为什么是 Pascal？一方面，它不是我为了这个系列而提出的一个虚构的语言：它是真实存在的一门编程语言，有很多重要的语言结构。有些陈旧但有用的计算机书籍使用 Pascal 编程语言作为示例（我知道对于选择一门语言来构建解释器，这个理由并不令人信服，但我认为学一门非主流的语言也不错 :））。</p>
<p>这有个 Pascal 中的阶乘函数示例，你将能用自己的解释器解释代码，还能够用可交互的源码级调试器进行调试，你可以这样创造：</p>
<div class="highlight"><pre><span></span><code><span class="n">program</span><span class="w"> </span><span class="n">factorial</span><span class="p">;</span>

<span class="n">function</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="n">integer</span><span class="p">):</span><span class="w"> </span><span class="n">longint</span><span class="p">;</span>
<span class="n">begin</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">then</span>
<span class="w">        </span><span class="n">factorial</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">    </span><span class="k">else</span>
<span class="w">        </span><span class="n">factorial</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="n">end</span><span class="p">;</span>

<span class="k">var</span>
<span class="w">    </span><span class="n">n</span><span class="p">:</span><span class="w"> </span><span class="n">integer</span><span class="p">;</span>

<span class="n">begin</span>
<span class="w">    </span><span class="k">for</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="n">do</span>
<span class="w">        </span><span class="n">writeln</span><span class="p">(</span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;! = &#39;</span><span class="p">,</span><span class="w"> </span><span class="n">factorial</span><span class="p">(</span><span class="n">n</span><span class="p">));</span>
<span class="n">end</span><span class="o">.</span>
</code></pre></div>

<p>这个 Pascal 解释器的实现语言会使用 Python，但你也可以用其他任何语言，因为这里展示的思想不依赖任何特殊的实现语言。好，让我们开始干活。准备好了，出发！</p>
<p>你会从编写一个简单的算术表达式解析器，也就是常说的计算器，开始学习解释器和编译器。今天的目标非常简单：让你的计算器能处理两个个位数相加，比如 <code>3+5</code>。下面是你的计算器的源代码——不好意思，是解释器：</p>
<div class="highlight"><pre><span></span><code><span class="err">#</span><span class="w"> </span><span class="nx">标记类型</span>
<span class="err">#</span>
<span class="err">#</span><span class="w"> </span><span class="nx">EOF</span><span class="w"> </span><span class="err">（</span><span class="nx">end</span><span class="o">-</span><span class="nx">of</span><span class="o">-</span><span class="nx">file</span><span class="w"> </span><span class="nx">文件末尾</span><span class="err">）</span><span class="nx">标记是用来表示所有输入都解析完成</span>
<span class="nx">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="nx">PLUS</span><span class="p">,</span><span class="w"> </span><span class="nx">EOF</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">INTEGER</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">PLUS</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">EOF</span><span class="err">&#39;</span>


<span class="kd">class</span><span class="w"> </span><span class="nx">Token</span><span class="p">(</span><span class="nx">object</span><span class="p">):</span>
<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">__init__</span><span class="p">(</span><span class="kp">self</span><span class="p">,</span><span class="w"> </span><span class="k">type</span><span class="p">,</span><span class="w"> </span><span class="nx">value</span><span class="p">):</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="nx">类型</span><span class="p">:</span><span class="w"> </span><span class="nx">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="nx">PLUS</span><span class="p">,</span><span class="w"> </span><span class="nx">MINUS</span><span class="p">,</span><span class="w"> </span><span class="k">or</span><span class="w"> </span><span class="nx">EOF</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="k">type</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="k">type</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">token</span><span class="w"> </span><span class="nx">值</span><span class="p">:</span><span class="w"> </span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">,</span><span class="w"> </span><span class="mi">6</span><span class="p">,</span><span class="w"> </span><span class="mi">7</span><span class="p">,</span><span class="w"> </span><span class="mi">8</span><span class="p">,</span><span class="w"> </span><span class="mi">9</span><span class="p">,</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">,</span><span class="w"> </span><span class="nx">或</span><span class="w"> </span><span class="nx">None</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">value</span>

<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">__str__</span><span class="p">(</span><span class="kp">self</span><span class="p">):</span>
<span class="w">        </span><span class="s">&quot;&quot;&quot;String representation of the class instance.</span>

<span class="s">        Examples:</span>
<span class="s">            Token(INTEGER, 3)</span>
<span class="s">            Token(PLUS &#39;+&#39;)</span>
<span class="s">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">Token</span><span class="p">({</span><span class="k">type</span><span class="p">},</span><span class="w"> </span><span class="p">{</span><span class="nx">value</span><span class="p">})</span><span class="err">&#39;</span><span class="p">.</span><span class="nx">format</span><span class="p">(</span>
<span class="w">            </span><span class="k">type</span><span class="p">=</span><span class="kp">self</span><span class="p">.</span><span class="k">type</span><span class="p">,</span>
<span class="w">            </span><span class="nx">value</span><span class="p">=</span><span class="nx">repr</span><span class="p">(</span><span class="kp">self</span><span class="p">.</span><span class="nx">value</span><span class="p">)</span>
<span class="w">        </span><span class="p">)</span>

<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">__repr__</span><span class="p">(</span><span class="kp">self</span><span class="p">):</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">__str__</span><span class="p">()</span>


<span class="kd">class</span><span class="w"> </span><span class="nx">Interpreter</span><span class="p">(</span><span class="nx">object</span><span class="p">):</span>
<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">__init__</span><span class="p">(</span><span class="kp">self</span><span class="p">,</span><span class="w"> </span><span class="nx">text</span><span class="p">):</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">用户输入字符串</span><span class="p">,</span><span class="w"> </span><span class="nx">例如</span><span class="w"> </span><span class="s">&quot;3+5&quot;</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">text</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">text</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="nx">是</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">text</span><span class="w"> </span><span class="nx">的索引</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">0</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">当前标记实例</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">None</span>

<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">error</span><span class="p">(</span><span class="kp">self</span><span class="p">):</span>
<span class="w">        </span><span class="nx">raise</span><span class="w"> </span><span class="nx">Exception</span><span class="p">(</span><span class="err">&#39;</span><span class="nx">Error</span><span class="w"> </span><span class="nx">parsing</span><span class="w"> </span><span class="nx">input</span><span class="err">&#39;</span><span class="p">)</span>

<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">get_next_token</span><span class="p">(</span><span class="kp">self</span><span class="p">):</span>
<span class="w">        </span><span class="s">&quot;&quot;&quot;词法分析器（也说成扫描器或者标记器）</span>

<span class="s">        该方法负责把一个句子分成若干个标记。每次处理一个标记</span>
<span class="s">        &quot;&quot;&quot;</span>
<span class="w">        </span><span class="nx">text</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">text</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="nx">索引到达了</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">text</span><span class="w"> </span><span class="nx">的末尾吗</span><span class="err">？</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">如果到了</span><span class="err">，</span><span class="nx">就返回</span><span class="w"> </span><span class="nx">EOF</span><span class="w"> </span><span class="nx">标记</span><span class="err">，</span><span class="nx">因为没有更多的</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">能转换成标记的输入了</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="p">&gt;</span><span class="w"> </span><span class="nx">len</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">Token</span><span class="p">(</span><span class="nx">EOF</span><span class="p">,</span><span class="w"> </span><span class="nx">None</span><span class="p">)</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">从</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="nx">位置获取当前的字符</span><span class="err">，</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">基于单个字符判断要生成哪种标记</span>
<span class="w">        </span><span class="nx">current_char</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">text</span><span class="p">[</span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="p">]</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">如果字符是一个数字</span><span class="err">，</span><span class="nx">就把他转换成一个整数</span><span class="err">，</span><span class="nx">生成一个</span><span class="w"> </span><span class="nx">INTEGER</span><span class="w"> </span><span class="err">#</span><span class="w"> </span><span class="nx">标记</span><span class="err">，</span><span class="nx">累加</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="nx">索引</span><span class="err">，</span><span class="nx">指向数字后面的下一个字符</span><span class="err">，</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">并返回</span><span class="w"> </span><span class="nx">INTEGER</span><span class="w"> </span><span class="nx">标记</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">current_char</span><span class="p">.</span><span class="nx">isdigit</span><span class="p">():</span>
<span class="w">            </span><span class="nx">token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Token</span><span class="p">(</span><span class="nx">INTEGER</span><span class="p">,</span><span class="w"> </span><span class="nx">int</span><span class="p">(</span><span class="nx">current_char</span><span class="p">))</span>
<span class="w">            </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">token</span>

<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="nx">current_char</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="sc">&#39;+&#39;</span><span class="p">:</span>
<span class="w">            </span><span class="nx">token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Token</span><span class="p">(</span><span class="nx">PLUS</span><span class="p">,</span><span class="w"> </span><span class="nx">current_char</span><span class="p">)</span>
<span class="w">            </span><span class="kp">self</span><span class="p">.</span><span class="nx">pos</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="nx">token</span>

<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">error</span><span class="p">()</span>

<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">eat</span><span class="p">(</span><span class="kp">self</span><span class="p">,</span><span class="w"> </span><span class="nx">token_type</span><span class="p">):</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">将当前的标记类型与传入的标记类型作比较</span><span class="err">，</span><span class="nx">如果他们相匹配</span><span class="err">，</span><span class="nx">就</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="err">“</span><span class="nx">eat</span><span class="err">”</span><span class="w"> </span><span class="nx">掉当前的标记并将下一个标记赋给</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span><span class="err">，</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">否则抛出一个异常</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span><span class="p">.</span><span class="k">type</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="nx">token_type</span><span class="p">:</span>
<span class="w">            </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">get_next_token</span><span class="p">()</span>
<span class="w">        </span><span class="k">else</span><span class="p">:</span>
<span class="w">            </span><span class="kp">self</span><span class="p">.</span><span class="nx">error</span><span class="p">()</span>

<span class="w">    </span><span class="nx">def</span><span class="w"> </span><span class="nx">expr</span><span class="p">(</span><span class="kp">self</span><span class="p">):</span>
<span class="w">        </span><span class="s">&quot;&quot;&quot;expr -&gt; INTEGER PLUS INTEGER&quot;&quot;&quot;</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">将输入中的第一个标记设置成当前标记</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">get_next_token</span><span class="p">()</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">我们期望当前标记是个位数</span><span class="err">。</span>
<span class="w">        </span><span class="nx">left</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">eat</span><span class="p">(</span><span class="nx">INTEGER</span><span class="p">)</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">期望当前标记是</span><span class="w"> </span><span class="err">‘</span><span class="o">+</span><span class="err">’</span><span class="w"> </span><span class="nx">号</span>
<span class="w">        </span><span class="nx">op</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">eat</span><span class="p">(</span><span class="nx">PLUS</span><span class="p">)</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">我们期望当前标记是个位数</span><span class="err">。</span>
<span class="w">        </span><span class="nx">right</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span>
<span class="w">        </span><span class="kp">self</span><span class="p">.</span><span class="nx">eat</span><span class="p">(</span><span class="nx">INTEGER</span><span class="p">)</span>

<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">上述操作完成后</span><span class="err">，</span><span class="kp">self</span><span class="p">.</span><span class="nx">current_token</span><span class="w"> </span><span class="nx">被设成</span><span class="w"> </span><span class="nx">EOF</span><span class="w"> </span><span class="nx">标记</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">这时成功找到</span><span class="w"> </span><span class="nx">INTEGER</span><span class="w"> </span><span class="nx">PLUS</span><span class="w"> </span><span class="nx">INTEGER</span><span class="w"> </span><span class="nx">标记序列</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">这个方法就可以返回两个整数相加的结果了</span><span class="err">，</span>
<span class="w">        </span><span class="err">#</span><span class="w"> </span><span class="nx">即高效的解释了用户输入</span>
<span class="w">        </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">left</span><span class="p">.</span><span class="nx">value</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nx">right</span><span class="p">.</span><span class="nx">value</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="nx">result</span>


<span class="nx">def</span><span class="w"> </span><span class="nx">main</span><span class="p">():</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="nx">True</span><span class="p">:</span>
<span class="w">        </span><span class="nx">try</span><span class="p">:</span>
<span class="w">            </span><span class="err">#</span><span class="w"> </span><span class="nx">要在</span><span class="w"> </span><span class="nx">Python3</span><span class="w"> </span><span class="nx">下运行</span><span class="err">，</span><span class="nx">请把</span><span class="w"> </span><span class="err">‘</span><span class="nx">raw_input</span><span class="err">’</span><span class="w"> </span><span class="nx">换成</span><span class="w"> </span><span class="err">‘</span><span class="nx">input</span><span class="err">’</span>
<span class="w">            </span><span class="nx">text</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">raw_input</span><span class="p">(</span><span class="err">&#39;</span><span class="nx">calc</span><span class="p">&gt;</span><span class="w"> </span><span class="err">&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="nx">except</span><span class="w"> </span><span class="nx">EOFError</span><span class="p">:</span>
<span class="w">            </span><span class="k">break</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="nx">text</span><span class="p">:</span>
<span class="w">            </span><span class="k">continue</span>
<span class="w">        </span><span class="nx">interpreter</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">Interpreter</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
<span class="w">        </span><span class="nx">result</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nx">interpreter</span><span class="p">.</span><span class="nx">expr</span><span class="p">()</span>
<span class="w">        </span><span class="nx">print</span><span class="p">(</span><span class="nx">result</span><span class="p">)</span>


<span class="k">if</span><span class="w"> </span><span class="nx">__name__</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">__main__</span><span class="err">&#39;</span><span class="p">:</span>
<span class="w">    </span><span class="nx">main</span><span class="p">()</span>
</code></pre></div>

<p>把上面的代码保存到 <code>calc1.py</code> 文件，或者直接从 <a href="https://github.com/rspivak/lsbasi/blob/master/part1/calc1.py">GitHub</a> 上下载。在你深入研究代码前，在命令行里面运行它看看效果。试一试！这是我笔记本上的示例会话（如果你想在 Python3 下运行，你要把 <code>raw_input</code> 换成 <code>input</code>）：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>python<span class="w"> </span>calc1.py
calc&gt;<span class="w"> </span><span class="m">3</span>+4
<span class="m">7</span>
calc&gt;<span class="w"> </span><span class="m">3</span>+5
<span class="m">8</span>
calc&gt;<span class="w"> </span><span class="m">3</span>+9
<span class="m">12</span>
calc&gt;
</code></pre></div>

<p>要让你的简易计算器正常工作，不抛出异常，你的输入要遵守以下几个规则：</p>
<ul>
<li>只允许输入个位数</li>
<li>此时支持的唯一一个运算符是加法</li>
<li>输入中不允许有任何的空格符号</li>
</ul>
<p>要让计算器变得简单，这些限制非常必要。不用担心，你很快就会让它变得很复杂。</p>
<p>好，现在让我们深入它，看看解释器是怎么工作，它是怎么评估出算术表达式的。</p>
<p>当你在命令行中输入一个表达式 <code>3+5</code>，解释器就获得了字符串 “3+5”。为了让解释器能够真正理解要用这个字符串做什么，它首先要把输入 “3+5” 分到叫做 <code>token</code>（标记）的容器里。<ruby> 标记 <rt>  token </rt></ruby> 是一个拥有类型和值的对象。比如说，对字符 “3” 而言，标记的类型是 INTEGER 整数，对应的值是 3。</p>
<p>把输入字符串分成标记的过程叫<ruby> 词法分析 <rt>  lexical analysis </rt></ruby>。因此解释器的需要做的第一步是读取输入字符，并将其转换成标记流。解释器中的这一部分叫做<ruby> 词法分析器 <rt>  lexical analyzer </rt></ruby>，或者简短点叫 <strong>lexer</strong>。你也可以给它起别的名字，诸如<ruby> 扫描器 <rt>  scanner </rt></ruby>或者<ruby> 标记器 <rt>  tokenizer </rt></ruby>。它们指的都是同一个东西：解释器或编译器中将输入字符转换成标记流的那部分。</p>
<p><code>Interpreter</code> 类中的 <code>get_next_token</code> 方法就是词法分析器。每次调用它的时候，你都能从传入解释器的输入字符中获得创建的下一个标记。仔细看看这个方法，看看它是如何完成把字符转换成标记的任务的。输入被存在可变文本中，它保存了输入的字符串和关于该字符串的索引（把字符串想象成字符数组）。<code>pos</code> 开始时设为 0，指向字符 ‘3’。这个方法一开始检查字符是不是数字，如果是，就将 <code>pos</code> 加 1，并返回一个 INTEGER 类型的标记实例，并把字符 ‘3’ 的值设为整数，也就是整数 3：</p>
<p><img alt="" src="/data/attachment/album/201803/02/214847ppss6o63dsokwcqc.png"></p>
<p>现在 <code>pos</code> 指向文本中的 ‘+’ 号。下次调用这个方法的时候，它会测试 <code>pos</code> 位置的字符是不是个数字，然后检测下一个字符是不是个加号，就是这样。结果这个方法把 <code>pos</code> 加 1，返回一个新创建的标记，类型是 PLUS，值为 ‘+’。</p>
<p><img alt="" src="/data/attachment/album/201803/02/214848f9oqx09z6k7x69rs.png"></p>
<p><code>pos</code> 现在指向字符 ‘5’。当你再调用 <code>get_next_token</code> 方法时，该方法会检查这是不是个数字，就是这样，然后它把 <code>pos</code> 加 1，返回一个新的 INTEGER 标记，该标记的值被设为整数 5：</p>
<p><img alt="" src="/data/attachment/album/201803/02/214849kiqzq60heoeofcvc.png"></p>
<p>因为 <code>pos</code> 索引现在到了字符串 “3+5” 的末尾，你每次调用 <code>get_next_token</code> 方法时，它将会返回 EOF 标记：</p>
<p><img alt="" src="/data/attachment/album/201803/02/214851e5y5yyn9y5mkyxxm.png"></p>
<p>自己试一试，看看计算器里的词法分析器的运行：</p>
<div class="highlight"><pre><span></span><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">calc1</span> <span class="kn">import</span> <span class="n">Interpreter</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span> <span class="o">=</span> <span class="n">Interpreter</span><span class="p">(</span><span class="s1">&#39;3+5&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">PLUS</span><span class="p">,</span> <span class="s1">&#39;+&#39;</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">INTEGER</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">interpreter</span><span class="o">.</span><span class="n">get_next_token</span><span class="p">()</span>
<span class="n">Token</span><span class="p">(</span><span class="n">EOF</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span>
</code></pre></div>

<p>既然你的解释器能够从输入字符中获取标记流，解释器需要对它做点什么：它需要在词法分析器 <code>get_next_token</code> 中获取的标记流中找出相应的结构。你的解释器应该能够找到流中的结构：INTEGER -&gt; PLUS -&gt; INTEGER。就是这样，它尝试找出标记的序列：整数后面要跟着加号，加号后面要跟着整数。</p>
<p>负责找出并解释结构的方法就是 <code>expr</code>。该方法检验标记序列确实与期望的标记序列是对应的，比如 INTEGER -&gt; PLUS -&gt; INTEGER。成功确认了这个结构后，就会生成加号左右两边的标记的值相加的结果，这样就成功解释你输入到解释器中的算术表达式了。</p>
<p><code>expr</code> 方法用了一个助手方法 <code>eat</code> 来检验传入的标记类型是否与当前的标记类型相匹配。在匹配到传入的标记类型后，<code>eat</code> 方法会获取下一个标记，并将其赋给 <code>current_token</code> 变量，然后高效地 “吃掉” 当前匹配的标记，并将标记流的虚拟指针向后移动。如果标记流的结构与期望的 INTEGER -&gt; PLUS -&gt; INTEGER 标记序列不对应，<code>eat</code> 方法就抛出一个异常。</p>
<p>让我们回顾下解释器做了什么来对算术表达式进行评估的：</p>
<ul>
<li>解释器接受输入字符串，比如说 “3+5”</li>
<li>解释器调用 <code>expr</code> 方法，在词法分析器 <code>get_next_token</code> 返回的标记流中找出结构。这个结构就是 INTEGER -&gt; PLUS -&gt; INTEGER 这样的格式。在确认了格式后，它就通过把两个整型标记相加来解释输入，因为此时对于解释器来说很清楚，它要做的就是把两个整数 3 和 5 进行相加。</li>
</ul>
<p>恭喜。你刚刚学习了怎么构建自己的第一个解释器！</p>
<p>现在是时候做练习了。</p>
<p><img alt="" src="/data/attachment/album/201803/02/214853zoceezo3ynffmjff.png"></p>
<p>看了这篇文章，你肯定觉得不够，是吗？好，准备好做这些练习：</p>
<ol>
<li>修改代码，允许输入多位数，比如 “12+3”</li>
<li>添加一个方法忽略空格符，让你的计算器能够处理带有空白的输入，比如 “12 + 3”</li>
<li>修改代码，用 ‘-’ 号而非 ‘+’ 号去执行减法比如 “7-5”</li>
</ol>
<p><strong>检验你的理解</strong></p>
<ol>
<li>什么是解释器？</li>
<li>什么是编译器</li>
<li>解释器和编译器有什么差别？</li>
<li>什么是标记?</li>
<li>将输入分隔成若干个标记的过程叫什么？</li>
<li>解释器中进行词法分析的部分叫什么？</li>
<li>解释器或编译器中进行词法分析的部分有哪些其他的常见名字？</li>
</ol>
<p>在结束本文前，我衷心希望你能留下学习解释器和编译器的承诺。并且现在就开始做。不要把它留到以后。不要拖延。如果你已经看完了本文，就开始吧。如果已经仔细看完了但是还没做什么练习 —— 现在就开始做吧。如果已经开始做练习了，那就把剩下的做完。你懂得。而且你知道吗？签下承诺书，今天就开始学习解释器和编译器！</p>
<blockquote>
<p>本人， ______，身体健全，思想正常，在此承诺从今天开始学习解释器和编译器，直到我百分百了解它们是怎么工作的！</p>
<p>签字人:</p>
<p>日期:</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/201803/02/214855gfv5y6ohesfdpfeh.png"></p>
<p>签字，写上日期，把它放在你每天都能看到的地方，确保你能坚守承诺。谨记你的承诺：</p>
<blockquote>
<p>“承诺就是，你说自己会去做的事，在你说完就一直陪着你的东西。” —— Darren Hardy</p>
</blockquote>
<p>好，今天的就结束了。这个系列的下一篇文章里，你将会扩展自己的计算器，让它能够处理更复杂的算术表达式。敬请期待。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>