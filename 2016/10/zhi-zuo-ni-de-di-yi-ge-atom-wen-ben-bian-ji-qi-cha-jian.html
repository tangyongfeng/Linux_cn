<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>制作你的第一个 Atom 文本编辑器插件</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: NickTikhonov 序言 这篇教程将会教你怎么制作你的第一个 Atom 文本编辑器的插件。我们将会制作一个山寨版的 Sourcerer，这是一个从 StackOverflow 查 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2016/10/zhi-zuo-ni-de-di-yi-ge-atom-wen-ben-bian-ji-qi-cha-jian.html" rel="bookmark"
           title="Permalink to 制作你的第一个 Atom 文本编辑器插件">制作你的第一个 Atom 文本编辑器插件</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-10-15T16:16:22+02:00">
                Published: Sat 15 October 2016
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: NickTikhonov</p>
<p><img alt="" src="/data/attachment/album/201610/15/161556nz01buuwz1gq25zw.jpg"></p>
<h3>序言</h3>
<p>这篇教程将会教你怎么制作你的第一个 Atom 文本编辑器的插件。我们将会制作一个山寨版的 <a href="https://github.com/NickTikhonov/sourcerer">Sourcerer</a>，这是一个从 StackOverflow 查询并使用代码片段的插件。到教程结束时，你将会制作好一个将编程问题（用英语描述的）转换成获取自 StackOverflow 的代码片段的插件，像这样：</p>
<p><img alt="" src="/data/attachment/album/201610/15/154809kzgamoaygugu9nnp.gif"></p>
<h4>教程须知</h4>
<p>Atom 文本编辑器是用 web 技术创造出来的。我们将完全使用 JavaScript 的 EcmaScript 6 规范来制作插件。你需要熟悉以下内容：</p>
<ul>
<li>使用命令行</li>
<li>JavaScript 编程</li>
<li><a href="https://developers.google.com/web/fundamentals/getting-started/primers/promises">Promises</a></li>
<li><a href="https://atom.io/">HTTP</a></li>
</ul>
<h4>教程的仓库</h4>
<p>你可以跟着教程一步一步走，或者看看 <a href="https://github.com/NickTikhonov/sourcefetch-guide">放在 GitHub 上的仓库</a>，这里有插件的源代码。这个仓库的历史提交记录包含了这里每一个标题。</p>
<h3>开始</h3>
<h4>安装 Atom</h4>
<p>根据 <a href="https://atom.io/">Atom 官网</a> 的说明来下载 Atom。我们同时还要安装上 <code>apm</code>（Atom 包管理器的命令行工具）。你可以打开 Atom 并在应用菜单中导航到 <code>Atom &gt; Install Shell Commands</code> 来安装。打开你的命令行终端，运行 <code>apm -v</code> 来检查 <code>apm</code> 是否已经正确安装好，安装成功的话打印出来的工具版本和相关环境信息应该是像这样的：</p>
<div class="highlight"><pre><span></span><code>apm -v
&gt; apm  1.9.2
&gt; npm  2.13.3
&gt; node 0.10.40
&gt; python 2.7.10
&gt; git 2.7.4
</code></pre></div>

<h4>生成骨架代码</h4>
<p>让我们使用 Atom 提供的一个实用工具创建一个新的 <strong>package</strong>（软件包）来开始这篇教程。</p>
<ul>
<li>启动编辑器，按下 <code>Cmd+Shift+P</code>（MacOS）或者 <code>Ctrl+Shift+P</code>（Windows/Linux）来打开<ruby> 命令面板 <rp>  （ </rp> <rt>  Command Palette </rt> <rp>  ） </rp></ruby>。</li>
<li>搜索“Package Generator: Generate Package”并点击列表中正确的条目，你会看到一个输入提示，输入软件包的名称：“sourcefetch”。</li>
<li>按下回车键来生成这个骨架代码包，它会自动在 Atom 中打开。</li>
</ul>
<p>如果你在侧边栏没有看到软件包的文件，依次按下 <code>Cmd+K</code> <code>Cmd+B</code>（MacOS）或者 <code>Ctrl+K</code> <code>Ctrl+B</code>（Windows/Linux）。</p>
<p><img alt="" src="/data/attachment/album/201610/15/154924xs3id22wnynulfoy.gif"></p>
<blockquote>
<p><ruby> 命令面板 <rp>  （ </rp> <rt>  Command Palette </rt> <rp>  ） </rp></ruby>可以让你通过模糊搜索来找到并运行软件包。这是一个执行命令比较方便的途径，你不用去找导航菜单，也不用刻意去记快捷键。我们将会在整篇教程中使用这个方法。</p>
</blockquote>
<h4>运行骨架代码包</h4>
<p>在开始编程前让我们来试用一下这个骨架代码包。我们首先需要重启 Atom，这样它才可以识别我们新增的软件包。再次打开命令面板，执行 <code>Window: Reload</code> 命令。</p>
<p>重新加载当前窗口以确保 Atom 执行的是我们最新的源代码。每当需要测试我们对软件包的改动的时候，就需要运行这条命令。</p>
<p>通过导航到编辑器菜单的 <code>Packages &gt; sourcefetch &gt; Toggle</code> 或者在命令面板执行 <code>sourcefetch:toggle</code> 来运行软件包的 <code>toggle</code> 命令。你应该会看到屏幕的顶部出现了一个小黑窗。再次运行这条命令就可以隐藏它。</p>
<p><img alt="" src="/data/attachment/album/201610/15/155008b7a0pgzv8rk8rcpb.gif"></p>
<h4>“toggle”命令</h4>
<p>打开 <code>lib/sourcefetch.js</code>，这个文件包含有软件包的逻辑和 <code>toggle</code> 命令的定义。</p>
<div class="highlight"><pre><span></span><code><span class="nv">toggle</span><span class="ss">()</span><span class="w"> </span>{
<span class="w"> </span><span class="nv">console</span>.<span class="nv">log</span><span class="ss">(</span><span class="s1">&#39;Sourcefetch was toggled!&#39;</span><span class="ss">)</span><span class="c1">;</span>
<span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="ss">(</span>
<span class="w">   </span><span class="nv">this</span>.<span class="nv">modalPanel</span>.<span class="nv">isVisible</span><span class="ss">()</span><span class="w"> </span>?
<span class="w">   </span><span class="nv">this</span>.<span class="nv">modalPanel</span>.<span class="nv">hide</span><span class="ss">()</span><span class="w"> </span>:
<span class="w">   </span><span class="nv">this</span>.<span class="nv">modalPanel</span>.<span class="k">show</span><span class="ss">()</span>
<span class="w"> </span><span class="ss">)</span><span class="c1">;</span>
}
</code></pre></div>

<p><code>toggle</code> 是这个模块导出的一个函数。根据模态面板的可见性，它通过一个<a href="https://en.wikipedia.org/wiki/%3F:">三目运算符</a> 来调用 <code>show</code> 和 <code>hide</code> 方法。<code>modalPanel</code> 是 <a href="https://atom.io/docs/api/v1.9.4/Panel">Panel</a>（一个由 Atom API 提供的 UI 元素） 的一个实例。我们需要在 <code>export default</code> 内部声明 <code>modalPanel</code> 才可以让我们通过一个实例变量 <code>this</code> 来访问它。</p>
<div class="highlight"><pre><span></span><code><span class="nt">this</span><span class="p">.</span><span class="nc">subscriptions</span><span class="p">.</span><span class="nc">add</span><span class="o">(</span><span class="nt">atom</span><span class="p">.</span><span class="nc">commands</span><span class="p">.</span><span class="nc">add</span><span class="o">(</span><span class="s1">&#39;atom-workspace&#39;</span><span class="o">,</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="err">&#39;</span><span class="n">sourcefetch</span><span class="p">:</span><span class="n">toggle</span><span class="err">&#39;</span><span class="o">:</span><span class="w"> </span><span class="p">()</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="n">this</span><span class="o">.</span><span class="nb">toggle</span><span class="p">()</span>
<span class="p">}</span><span class="o">));</span>
</code></pre></div>

<p>上面的语句让 Atom 在用户运行 <code>sourcefetch:toggle</code> 的时候执行 <code>toggle</code> 方法。我们指定了一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">匿名函数</a> <code>() =&gt; this.toggle()</code>，每次执行这条命令的时候都会执行这个函数。这是<a href="https://en.wikipedia.org/wiki/Event-driven_programming">事件驱动编程</a>（一种常用的 JavaScript 模式）的一个范例。</p>
<h4>Atom 命令</h4>
<p>命令只是用户触发事件时使用的一些字符串标识符，它定义在软件包的命名空间内。我们已经用过的命令有：</p>
<ul>
<li><code>package-generator:generate-package</code></li>
<li><code>Window:reload</code></li>
<li><code>sourcefetch:toggle</code></li>
</ul>
<p>软件包对应到命令，以执行代码来响应事件。</p>
<h3>进行你的第一次代码更改</h3>
<p>让我们来进行第一次代码更改——我们将通过改变 <code>toggle</code> 函数来实现逆转用户选中文本的功能。</p>
<h4>改变 “toggle” 函数</h4>
<p>如下更改 <code>toggle</code> 函数。</p>
<div class="highlight"><pre><span></span><code><span class="nv">toggle</span><span class="ss">()</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">let</span><span class="w"> </span><span class="nv">editor</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">atom</span>.<span class="nv">workspace</span>.<span class="nv">getActiveTextEditor</span><span class="ss">())</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">let</span><span class="w"> </span><span class="nv">selection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">editor</span>.<span class="nv">getSelectedText</span><span class="ss">()</span>
<span class="w">    </span><span class="nv">let</span><span class="w"> </span><span class="nv">reversed</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">selection</span>.<span class="nv">split</span><span class="ss">(</span><span class="s1">&#39;&#39;</span><span class="ss">)</span>.<span class="nv">reverse</span><span class="ss">()</span>.<span class="nv">join</span><span class="ss">(</span><span class="s1">&#39;&#39;</span><span class="ss">)</span>
<span class="w">    </span><span class="nv">editor</span>.<span class="nv">insertText</span><span class="ss">(</span><span class="nv">reversed</span><span class="ss">)</span>
<span class="w">  </span>}
}
</code></pre></div>

<h4>测试你的改动</h4>
<ul>
<li>通过在命令面板运行 <code>Window: Reload</code> 来重新加载 Atom。</li>
<li>通过导航到 <code>File &gt; New</code> 来创建一个新文件，随便写点什么并通过光标选中它。</li>
<li>通过命令面板、Atom 菜单或者右击文本然后选中 <code>Toggle sourcefetch</code> 来运行 <code>sourcefetch:toggle</code> 命令。</li>
</ul>
<p>更新后的命令将会改变选中文本的顺序：</p>
<p><img alt="" src="/data/attachment/album/201610/15/155103uthil87z17eu7shz.gif"></p>
<p>在 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/89e174ab6ec6e270938338b34905f75bb74dbede">sourcefetch 教程仓库</a> 查看这一步的全部代码更改。</p>
<h3>Atom 编辑器 API</h3>
<p>我们添加的代码通过用 <a href="https://atom.io/docs/api/v1.11.1/TextEditor">TextEditor API</a> 来访问编辑器内的文本并进行操作。让我们来仔细看看。</p>
<div class="highlight"><pre><span></span><code>let editor
if (editor = atom.workspace.getActiveTextEditor()) { /* ... */ }
</code></pre></div>

<p>头两行代码获取了 <a href="https://atom.io/docs/api/latest/TextEditor">TextEditor</a> 实例的一个引用。变量的赋值和后面的代码被包在一个条件结构里，这是为了处理没有可用的编辑器实例的情况，例如，当用户在设置菜单中运行该命令时。</p>
<div class="highlight"><pre><span></span><code>let selection = editor.getSelectedText()
</code></pre></div>

<p>调用 <code>getSelectedText</code> 方法可以让我们访问到用户选中的文本。如果当前没有文本被选中，函数将返回一个空字符串。</p>
<div class="highlight"><pre><span></span><code>let reversed = selection.split(&#39;&#39;).reverse().join(&#39;&#39;)
editor.insertText(reversed)
</code></pre></div>

<p>我们选中的文本通过一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">JavaScript 字符串方法</a> 来逆转。最后，我们调用 <code>insertText</code> 方法来将选中的文本替换为逆转后的文本副本。通过阅读 <a href="https://atom.io/docs/api/latest/TextEditor">Atom API 文档</a>，你可以学到更多关于 TextEditor 的不同的方法。</p>
<h3>浏览骨架代码</h3>
<p>现在我们已经完成第一次代码更改了，让我们浏览骨架代码包的代码来深入了解一下 Atom 的软件包是怎样构成的。</p>
<h4>主文件</h4>
<p>主文件是 Atom 软件包的入口文件。Atom 通过 <code>package.json</code> 里的条目设置来找到主文件的位置：</p>
<div class="highlight"><pre><span></span><code>&quot;main&quot;: &quot;./lib/sourcefetch&quot;,
</code></pre></div>

<p>这个文件导出一个带有生命周期函数（Atom 在特定的事件发生时调用的处理函数）的对象。</p>
<ul>
<li><strong>activate</strong> 会在 Atom 初次加载软件包的时候调用。这个函数用来初始化一些诸如软件包所需的用户界面元素的对象，以及订阅软件包命令的处理函数。</li>
<li><strong>deactivate</strong> 会在软件包停用的时候调用，例如，当用户关闭或者刷新编辑器的时候。</li>
<li><strong>serialize</strong> Atom 调用它在使用软件包的过程中保存软件包的当前状态。它的返回值会在 Atom 下一次加载软件包的时候作为一个参数传递给 <code>activate</code>。</li>
</ul>
<p>我们将会重命名我们的软件包命令为 <code>fetch</code>，并移除一些我们不再需要的用户界面元素。按照如下更改主文件：</p>
<div class="highlight"><pre><span></span><code><span class="s1">&#39;use babel&#39;</span><span class="p">;</span>

<span class="kn">import</span> <span class="p">{</span> <span class="n">CompositeDisposable</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;atom&#39;</span>

<span class="n">export</span> <span class="n">default</span> <span class="p">{</span>

  <span class="n">subscriptions</span><span class="p">:</span> <span class="n">null</span><span class="p">,</span>

  <span class="n">activate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">subscriptions</span> <span class="o">=</span> <span class="n">new</span> <span class="n">CompositeDisposable</span><span class="p">()</span>

    <span class="n">this</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">commands</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="s1">&#39;atom-workspace&#39;</span><span class="p">,</span> <span class="p">{</span>
      <span class="s1">&#39;sourcefetch:fetch&#39;</span><span class="p">:</span> <span class="p">()</span> <span class="o">=&gt;</span> <span class="n">this</span><span class="o">.</span><span class="n">fetch</span><span class="p">()</span>
    <span class="p">}))</span>
  <span class="p">},</span>

  <span class="n">deactivate</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">this</span><span class="o">.</span><span class="n">subscriptions</span><span class="o">.</span><span class="n">dispose</span><span class="p">()</span>
  <span class="p">},</span>

  <span class="n">fetch</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">let</span> <span class="n">editor</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">editor</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">workspace</span><span class="o">.</span><span class="n">getActiveTextEditor</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">let</span> <span class="n">selection</span> <span class="o">=</span> <span class="n">editor</span><span class="o">.</span><span class="n">getSelectedText</span><span class="p">()</span>
      <span class="n">selection</span> <span class="o">=</span> <span class="n">selection</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">reverse</span><span class="p">()</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
      <span class="n">editor</span><span class="o">.</span><span class="n">insertText</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div>

<h3>“启用”命令</h3>
<p>为了提升性能，Atom 软件包可以用时加载。我们可以让 Atom 在用户执行特定的命令的时候才加载我们的软件包。这些命令被称为 <strong>启用命令</strong>，它们在 <code>package.json</code> 中定义：</p>
<div class="highlight"><pre><span></span><code>&quot;activationCommands&quot;: {
  &quot;atom-workspace&quot;: &quot;sourcefetch:toggle&quot;
},
</code></pre></div>

<p>更新一下这个条目设置，让 <code>fetch</code> 成为一个启用命令。</p>
<div class="highlight"><pre><span></span><code>&quot;activationCommands&quot;: {
  &quot;atom-workspace&quot;: &quot;sourcefetch:fetch&quot;
},
</code></pre></div>

<p>有一些软件包需要在 Atom 启动的时候被加载，例如那些改变 Atom 外观的软件包。在那样的情况下，<code>activationCommands</code> 会被完全忽略。</p>
<h3>“触发”命令</h3>
<h4>菜单项</h4>
<p><code>menus</code> 目录下的 JSON 文件指定了哪些菜单项是为我们的软件包而建的。让我们看看 <code>menus/sourcefetch.json</code>：</p>
<div class="highlight"><pre><span></span><code>&quot;context-menu&quot;: {
  &quot;atom-text-editor&quot;: [
    {
      &quot;label&quot;: &quot;Toggle sourcefetch&quot;,
      &quot;command&quot;: &quot;sourcefetch:toggle&quot;
    }
  ]
},
</code></pre></div>

<p>这个 <code>context-menu</code> 对象可以让我们定义右击菜单的一些新条目。每一个条目都是通过一个显示在菜单的 <code>label</code> 属性和一个点击后执行的命令的 <code>command</code> 属性来定义的。</p>
<div class="highlight"><pre><span></span><code>&quot;context-menu&quot;: {
  &quot;atom-text-editor&quot;: [
    {
      &quot;label&quot;: &quot;Fetch code&quot;,
      &quot;command&quot;: &quot;sourcefetch:fetch&quot;
    }
  ]
},
</code></pre></div>

<p>同一个文件中的这个 <code>menu</code> 对象用来定义插件的自定义应用菜单。我们如下重命名它的条目：</p>
<div class="highlight"><pre><span></span><code>&quot;menu&quot;: [
  {
    &quot;label&quot;: &quot;Packages&quot;,
    &quot;submenu&quot;: [
      {
        &quot;label&quot;: &quot;sourcefetch&quot;,
        &quot;submenu&quot;: [
          {
            &quot;label&quot;: &quot;Fetch code&quot;,
            &quot;command&quot;: &quot;sourcefetch:fetch&quot;
          }
        ]
      }
    ]
  }
]
</code></pre></div>

<h4>键盘快捷键</h4>
<p>命令还可以通过键盘快捷键来触发。快捷键通过 <code>keymaps</code> 目录的 JSON 文件来定义：</p>
<div class="highlight"><pre><span></span><code>{
  &quot;atom-workspace&quot;: {
    &quot;ctrl-alt-o&quot;: &quot;sourcefetch:toggle&quot;
  }
}
</code></pre></div>

<p>以上代码可以让用户通过 <code>Ctrl+Alt+O</code>（Windows/Linux） 或 <code>Cmd+Alt+O</code>（MacOS） 来触发 <code>toggle</code> 命令。</p>
<p>重命名引用的命令为 <code>fetch</code>：</p>
<div class="highlight"><pre><span></span><code>&quot;ctrl-alt-o&quot;: &quot;sourcefetch:fetch&quot;
</code></pre></div>

<p>通过执行 <code>Window: Reload</code> 命令来重启 Atom。你应该会看到 Atom 的右击菜单更新了，并且逆转文本的功能应该还可以像之前一样使用。</p>
<p>在 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/aa3ec5585b0aa049393351a30be14590df09c29a">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3>使用 NodeJS 模块</h3>
<p>现在我们已经完成了第一次代码更改并且了解了 Atom 软件包的结构，让我们介绍一下 <a href="https://www.npmjs.com/">Node 包管理器（npm）</a> 中的第一个依赖项模块。我们将使用 <strong>request</strong> 模块发起 HTTP 请求来下载网站的 HTML 文件。稍后将会用到这个功能来扒 StackOverflow 的页面。</p>
<h4>安装依赖</h4>
<p>打开你的命令行工具，切换到你的软件包的根目录并运行：</p>
<div class="highlight"><pre><span></span><code><span class="n">npm</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="o">--</span><span class="n">save</span><span class="w"> </span><span class="n">request</span><span class="mf">@2.73.0</span>
<span class="n">apm</span><span class="w"> </span><span class="n">install</span>
</code></pre></div>

<p>这两条命令将 <code>request</code> 模块添加到我们软件包的依赖列表并将模块安装到 <code>node_modules</code> 目录。你应该会在 <code>package.json</code> 看到一个新条目。<code>@</code> 符号的作用是让 npm 安装我们这篇教程需要用到的特定版本的模块。运行 <code>apm install</code> 是为了让 Atom 知道使用我们新安装的模块。</p>
<div class="highlight"><pre><span></span><code>&quot;dependencies&quot;: {
  &quot;request&quot;: &quot;^2.73.0&quot;
}
</code></pre></div>

<h4>下载 HTML 并将记录打印在开发者控制台</h4>
<p>通过在 <code>lib/sourcefetch.js</code> 的顶部添加一条引用语句引入 <code>request</code> 模块到我们的主文件：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="p">{</span> <span class="n">CompositeDisposable</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;atom&#39;</span>
<span class="kn">import</span> <span class="nn">request</span> <span class="kn">from</span> <span class="s1">&#39;request&#39;</span>
</code></pre></div>

<p>现在，在 <code>fetch</code> 函数下面添加一个新函数 <code>download</code> 作为模块的导出项：</p>
<div class="highlight"><pre><span></span><code><span class="k">export</span><span class="w"> </span><span class="n">default</span><span class="w"> </span><span class="p">{</span><span class="w">  </span>

<span class="w">  </span><span class="o">/*</span><span class="w"> </span><span class="n">subscriptions</span><span class="p">,</span><span class="w"> </span><span class="n">activate</span><span class="p">(),</span><span class="w"> </span><span class="n">deactivate</span><span class="p">()</span><span class="w"> </span><span class="o">*/</span>

<span class="w">  </span><span class="n">fetch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">...</span>
<span class="w">  </span><span class="p">},</span>

<span class="w">  </span><span class="n">download</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">response</span><span class="o">.</span><span class="n">statusCode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>这个函数用 <code>request</code> 模块来下载一个页面的内容并将记录输出到控制台。当 HTTP 请求完成之后，我们的<a href="http://recurial.com/programming/understanding-callback-functions-in-javascript/">回调函数</a>会将响应体作为参数来被调用。</p>
<p>最后一步是更新 <code>fetch</code> 函数以调用 <code>download</code> 函数：</p>
<div class="highlight"><pre><span></span><code><span class="n">fetch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">editor</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atom</span><span class="o">.</span><span class="n">workspace</span><span class="o">.</span><span class="n">getActiveTextEditor</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">selection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">editor</span><span class="o">.</span><span class="n">getSelectedText</span><span class="p">()</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">},</span>
</code></pre></div>

<p><code>fetch</code> 函数现在的功能是将 selection 当作一个 URL 传递给 <code>download</code> 函数，而不再是逆转选中的文本了。让我们来看看这次的更改：</p>
<ul>
<li>通过执行 <code>Window: Reload</code> 命令来重新加载 Atom。</li>
<li>打开开发者工具。为此，导航到菜单中的 <code>View &gt; Developer &gt; Toggle Developer Tools</code>。</li>
<li>新建一个文件，导航到 <code>File &gt; New</code>。</li>
<li>输入一个 URL 并选中它，例如：<code>http://www.atom.io</code>。</li>
<li>用上述的任意一种方法执行我们软件包的命令：</li>
</ul>
<p><img alt="" src="/data/attachment/album/201610/15/155404zh46j6658z46lz2u.gif"></p>
<blockquote>
<p><strong>开发者工具</strong>让 Atom 软件包的调试更轻松。每个 <code>console.log</code> 语句都可以将信息打印到交互控制台，你还可以使用 <code>Elements</code> 选项卡来浏览整个应用的可视化结构——即 HTML 的<a href="https://www.wikipedia.com/en/Document_Object_Model">文本对象模型（DOM）</a>。</p>
</blockquote>
<p>在 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/85992043e57c802ca71ff6e8a4f9c477fbfd13db">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3>用 Promises 来将下载好的 HTML 插入到编辑器中</h3>
<p>理想情况下，我们希望 <code>download</code> 函数可以将 HTML 作为一个字符串来返回，而不仅仅是将页面的内容打印到控制台。然而，返回文本内容是无法实现的，因为我们要在回调函数里面访问内容而不是在 <code>download</code> 函数那里。</p>
<p>我们会通过返回一个 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 来解决这个问题，而不再是返回一个值。让我们改动 <code>download</code> 函数来返回一个 Promise：</p>
<div class="highlight"><pre><span></span><code><span class="n">download</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Promise</span><span class="p">((</span><span class="n">resolve</span><span class="p">,</span><span class="w"> </span><span class="n">reject</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">request</span><span class="p">(</span><span class="n">url</span><span class="p">,</span><span class="w"> </span><span class="p">(</span><span class="n">error</span><span class="p">,</span><span class="w"> </span><span class="n">response</span><span class="p">,</span><span class="w"> </span><span class="n">body</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">response</span><span class="o">.</span><span class="n">statusCode</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">200</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">resolve</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">reject</span><span class="p">({</span>
<span class="w">          </span><span class="n">reason</span><span class="p">:</span><span class="w"> </span><span class="s1">&#39;Unable to download page&#39;</span>
<span class="w">        </span><span class="p">})</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div>

<p>Promises 允许我们通过将异步逻辑封装在一个提供两个回调方法的函数里来返回获得的值（<code>resolve</code> 用来处理请求成功的返回值，<code>reject</code> 用来向使用者报错）。如果请求返回了错误我们就调用 <code>reject</code>，否则就用 <code>resolve</code> 来处理 HTML。</p>
<p>让我们更改 <code>fetch</code> 函数来使用 <code>download</code> 返回的 Promise：</p>
<div class="highlight"><pre><span></span><code><span class="n">fetch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">editor</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atom</span><span class="o">.</span><span class="n">workspace</span><span class="o">.</span><span class="n">getActiveTextEditor</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">selection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">editor</span><span class="o">.</span><span class="n">getSelectedText</span><span class="p">()</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span><span class="o">.</span><span class="n">then</span><span class="p">((</span><span class="n">html</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">editor</span><span class="o">.</span><span class="n">insertText</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="w">    </span><span class="p">})</span><span class="o">.</span><span class="n">catch</span><span class="p">((</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addWarning</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">},</span>
</code></pre></div>

<p>在我们新版的 <code>fetch</code> 函数里，我们通过在 <code>download</code> 返回的 Promise 调用 <code>then</code> 方法来对 HTML 进行操作。这会将 HTML 插入到编辑器中。我们同样会通过调用 <code>catch</code> 方法来接收并处理所有的错误。我们通过用 <a href="https://atom.io/docs/api/v1.11.1/NotificationManager">Atom Notification API</a> 来显示警告的形式来处理错误。</p>
<p>看看发生了什么变化。重新加载 Atom 并在一个选中的 URL 上执行软件包命令：</p>
<p><img alt="" src="/data/attachment/album/201610/15/155458yaag3og5h9eoz96h.gif"></p>
<p>如果这个 URL 是无效的，一个警告通知将会弹出来：</p>
<p><img alt="" src="/data/attachment/album/201610/15/160402qqfffspoxrcgdorw.gif"></p>
<p>在 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/896d160dca711f4a53ff5b182018b39cf78d2774">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h4>编写一个爬虫来提取 StackOverflow 页面的代码片段</h4>
<p>下一步涉及用我们前面扒到的 StackOverflow 的页面的 HTML 来提取代码片段。我们尤其关注那些来自采纳答案（提问者选择的一个正确答案）的代码。我们可以在假设这类答案都是相关且正确的前提下大大简化我们这个软件包的实现。</p>
<h4>使用 jQuery 和 Chrome 开发者工具来构建查询</h4>
<p>这一部分假设你使用的是 <a href="https://www.google.com/chrome/">Chrome</a> 浏览器。你接下来可以使用其它浏览器，但是提示可能会不一样。</p>
<p>让我们先看看一张典型的包含采纳答案和代码片段的 StackOverflow 页面。我们将会使用 Chrome 开发者工具来浏览 HTML：</p>
<ul>
<li>打开 Chrome 并跳到任意一个带有采纳答案和代码的 StackOverflow 页面，比如像这个用 Python 写的 <a href="http://stackoverflow.com/questions/1077347/hello-world-in-python">hello world</a> 的例子或者这个关于 <a href="http://stackoverflow.com/questions/3463426/in-c-how-should-i-read-a-text-file-and-print-all-strings">用 <code>C</code> 来读取文本内容的问题</a>。</li>
<li>滚动窗口到采纳答案的位置并选中一部分代码。</li>
<li>右击选中文本并选择 <code>检查</code>。</li>
<li>使用元素侦察器来检查代码片段在 HTML 中的位置。</li>
</ul>
<p>注意文本结构应该是这样的：</p>
<div class="highlight"><pre><span></span><code><span class="nt">&lt;div</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;accepted-answer&quot;</span><span class="nt">&gt;</span>
<span class="w">  </span>...
<span class="w">    </span>...
<span class="w">      </span><span class="nt">&lt;pre&gt;</span>
<span class="w">        </span><span class="nt">&lt;code&gt;</span>
<span class="w">          </span>...snippet<span class="w"> </span>elements...
<span class="w">        </span><span class="nt">&lt;/code&gt;</span>
<span class="w">      </span><span class="nt">&lt;/pre&gt;</span>
<span class="w">    </span>...
<span class="w">  </span>...
<span class="nt">&lt;/div&gt;</span>
</code></pre></div>

<ul>
<li>采纳的答案通过一个 class 为 <code>accepted-answer</code> 的 <code>div</code> 来表示</li>
<li>代码块位于 <code>pre</code> 元素的内部</li>
<li>呈现代码片段的元素就是里面那一对 <code>code</code> 标签</li>
</ul>
<p><img alt="" src="/data/attachment/album/201610/15/160428thz0g7i2n2hkan3q.gif"></p>
<p>现在让我们写一些 <code>jQuery</code> 代码来提取代码片段：</p>
<ul>
<li>在开发者工具那里点击 <strong>Console</strong> 选项卡来访问 Javascript 控制台。</li>
<li>在控制台中输入 <code>$('div.accepted-answer pre code').text()</code> 并按下回车键。</li>
</ul>
<p>你应该会看到控制台中打印出采纳答案的代码片段。我们刚刚运行的代码使用了一个 jQuery 提供的特别的 <code>$</code> 函数。<code>$</code> 接收要选择的<strong>查询字符串</strong>并返回网站中的某些 HTML 元素。让我们通过思考几个查询案例看看这段代码的工作原理：</p>
<div class="highlight"><pre><span></span><code>$(&#39;div.accepted-answer&#39;)
&gt;<span class="w"> </span>[<span class="nt">&lt;div</span><span class="w"> </span><span class="na">id=</span><span class="s">&quot;answer-1077349&quot;</span><span class="w"> </span><span class="na">class=</span><span class="s">&quot;answer accepted-answer&quot;</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="nt">&gt;&lt;/div&gt;</span>]
</code></pre></div>

<p>上面的查询会匹配所有 class 为 <code>accepted-answer</code> 的 <code>&lt;div&gt;</code> 元素，在我们的案例中只有一个 div。</p>
<div class="highlight"><pre><span></span><code>$(&#39;div.accepted-answer<span class="w"> </span>pre<span class="w"> </span>code&#39;)
&gt;<span class="w"> </span>[<span class="nt">&lt;code&gt;</span>...<span class="nt">&lt;/code&gt;</span>]
</code></pre></div>

<p>在前面的基础上改造了一下，这个查询会匹配所有在之前匹配的 <code>&lt;div&gt;</code> 内部的 <code>&lt;pre&gt;</code> 元素内部的 <code>&lt;code&gt;</code> 元素。</p>
<div class="highlight"><pre><span></span><code>$(&#39;div.accepted-answer pre code&#39;).text()
&gt; &quot;print(&quot;Hello World!&quot;)&quot;
</code></pre></div>

<p><code>text</code> 函数提取并连接原本将由上一个查询返回的元素列表中的所有文本。这也从代码中去除了用来使语法高亮的元素。</p>
<h3>介绍 Cheerio</h3>
<p>我们的下一步涉及使用我们创建好的查询结合 <a href="https://www.npmjs.com/package/cheerio">Cheerio</a>（一个服务器端实现的 jQuery）来实现扒页面的功能。</p>
<h4>安装 Cheerio</h4>
<p>打开你的命令行工具，切换到你的软件包的根目录并执行：</p>
<div class="highlight"><pre><span></span><code><span class="n">npm</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="o">--</span><span class="n">save</span><span class="w"> </span><span class="n">cheerio</span><span class="mf">@0.20.0</span>
<span class="n">apm</span><span class="w"> </span><span class="n">install</span>
</code></pre></div>

<h4>实现扒页面的功能</h4>
<p>在 <code>lib/sourcefetch.js</code> 为 <code>cheerio</code> 添加一条引用语句：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="p">{</span> <span class="n">CompositeDisposable</span> <span class="p">}</span> <span class="kn">from</span> <span class="s1">&#39;atom&#39;</span>
<span class="kn">import</span> <span class="nn">request</span> <span class="kn">from</span> <span class="s1">&#39;request&#39;</span>
<span class="kn">import</span> <span class="nn">cheerio</span> <span class="kn">from</span> <span class="s1">&#39;cheerio&#39;</span>
</code></pre></div>

<p>现在创建一个新函数 <code>scrape</code>，它用来提取 StackOverflow HTML 里面的代码片段：</p>
<div class="highlight"><pre><span></span><code><span class="n">fetch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">},</span>

<span class="n">scrape</span><span class="p">(</span><span class="n">html</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">$</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cheerio</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="o">$</span><span class="p">(</span><span class="s1">&#39;div.accepted-answer pre code&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">text</span><span class="p">()</span>
<span class="p">},</span>

<span class="n">download</span><span class="p">(</span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">...</span>
<span class="p">}</span>
</code></pre></div>

<p>最后，让我们更改 <code>fetch</code> 函数以传递下载好的 HTML 给 <code>scrape</code> 而不是将其插入到编辑器：</p>
<div class="highlight"><pre><span></span><code><span class="n">fetch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">editor</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atom</span><span class="o">.</span><span class="n">workspace</span><span class="o">.</span><span class="n">getActiveTextEditor</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">selection</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">editor</span><span class="o">.</span><span class="n">getSelectedText</span><span class="p">()</span>
<span class="w">    </span><span class="n">this</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">selection</span><span class="p">)</span><span class="o">.</span><span class="n">then</span><span class="p">((</span><span class="n">html</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">scrape</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">answer</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addWarning</span><span class="p">(</span><span class="s1">&#39;No answer found :(&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">editor</span><span class="o">.</span><span class="n">insertText</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span><span class="o">.</span><span class="n">catch</span><span class="p">((</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">console</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">error</span><span class="p">)</span>
<span class="w">      </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addWarning</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">},</span>
</code></pre></div>

<p>我们扒取页面的功能仅仅用两行代码就实现了，因为 cheerio 已经替我们做好了所有的工作！我们通过调用 <code>load</code> 方法加载 HTML 字符串来创建一个 <code>$</code> 函数，然后用这个函数来执行 jQuery 语句并返回结果。你可以在官方 <a href="https://github.com/cheeriojs/cheerio">开发者文档</a> 查看完整的 <code>Cheerio API</code>。</p>
<h3>测试更新后的软件包</h3>
<p>重新加载 Atom 并在一个选中的 StackOverflow URL 上运行 <code>soucefetch:fetch</code> 以查看到目前为止的进度。</p>
<p>如果我们在一个有采纳答案的页面上运行这条命令，代码片段将会被插入到编辑器中：</p>
<p><img alt="" src="/data/attachment/album/201610/15/160534c1dq1d48twxshzzx.gif"></p>
<p>如果我们在一个没有采纳答案的页面上运行这条命令，将会弹出一个警告通知：</p>
<p><img alt="" src="/data/attachment/album/201610/15/160612a2jj2226uuwq2qxu.gif"></p>
<p>我们最新的 <code>fetch</code> 函数给我们提供了一个 StackOverflow 页面的代码片段而不再是整个 HTML 内容。要注意我们更新的 <code>fetch</code> 函数会检查有没有答案并显示通知以提醒用户。</p>
<p>在 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/039a1e1e976d029f7d6b061b4c0dac3eb4a3b5d2">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3>实现用来查找相关的 StackOverflow URL 的谷歌搜索功能</h3>
<p>现在我们已经将 StackOverflow 的 URL 转化为代码片段了，让我们来实现最后一个函数——<code>search</code>，它应该要返回一个相关的 URL 并附加一些像“hello world”或者“快速排序”这样的描述。我们会通过一个非官方的 <code>google</code> npm 模块来使用谷歌搜索功能，这样可以让我们以编程的方式来搜索。</p>
<h4>安装这个 Google npm 模块</h4>
<p>通过在软件包的根目录打开命令行工具并执行命令来安装 <code>google</code> 模块：</p>
<div class="highlight"><pre><span></span><code><span class="n">npm</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="o">--</span><span class="n">save</span><span class="w"> </span><span class="n">google</span><span class="mf">@2.0.0</span>
<span class="n">apm</span><span class="w"> </span><span class="n">install</span>
</code></pre></div>

<h4>引入并配置模块</h4>
<p>在 <code>lib/sourcefetch.js</code> 的顶部为 <code>google</code> 模块添加一条引用语句：</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">google</span> <span class="kn">from</span> <span class="s2">&quot;google&quot;</span>
</code></pre></div>

<p>我们将配置一下 <code>google</code> 以限制搜索期间返回的结果数。将下面这行代码添加到引用语句下面以限制搜索返回最热门的那个结果。</p>
<div class="highlight"><pre><span></span><code>google.resultsPerPage = 1
</code></pre></div>

<h4>实现 search 函数</h4>
<p>接下来让我们来实现我们的 <code>search</code> 函数：</p>
<div class="highlight"><pre><span></span><code>fetch()<span class="w"> </span>{
<span class="w">  </span>...
},

search(query,<span class="w"> </span>language)<span class="w"> </span>{
<span class="w">  </span>return<span class="w"> </span>new<span class="w"> </span>Promise((resolve,<span class="w"> </span>reject)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">    </span>let<span class="w"> </span>searchString<span class="w"> </span>=<span class="w"> </span>`<span class="cp">${</span><span class="n">query</span><span class="cp">}</span><span class="w"> </span>in<span class="w"> </span><span class="cp">${</span><span class="n">language</span><span class="cp">}</span><span class="w"> </span>site:stackoverflow.com`

<span class="w">    </span>google(searchString,<span class="w"> </span>(err,<span class="w"> </span>res)<span class="w"> </span>=&gt;<span class="w"> </span>{
<span class="w">      </span>if<span class="w"> </span>(err)<span class="w"> </span>{
<span class="w">        </span>reject({
<span class="w">          </span>reason:<span class="w"> </span>&#39;A<span class="w"> </span>search<span class="w"> </span>error<span class="w"> </span>has<span class="w"> </span>occured<span class="w"> </span>:(&#39;
<span class="w">        </span>})
<span class="w">      </span>}<span class="w"> </span>else<span class="w"> </span>if<span class="w"> </span>(res.links.length<span class="w"> </span>===<span class="w"> </span>0)<span class="w"> </span>{
<span class="w">        </span>reject({
<span class="w">          </span>reason:<span class="w"> </span>&#39;No<span class="w"> </span>results<span class="w"> </span>found<span class="w"> </span>:(&#39;
<span class="w">        </span>})
<span class="w">      </span>}<span class="w"> </span>else<span class="w"> </span>{
<span class="w">        </span>resolve(res.links[0].href)
<span class="w">      </span>}
<span class="w">    </span>})
<span class="w">  </span>})
},

scrape()<span class="w"> </span>{
<span class="w">  </span>...
}
</code></pre></div>

<p>以上代码通过谷歌来搜索一个和指定的关键词以及编程语言相关的 StackOverflow 页面，并返回一个最热门的 URL。让我们看看这是怎样来实现的：</p>
<div class="highlight"><pre><span></span><code>let<span class="w"> </span>searchString<span class="w"> </span>=<span class="w"> </span>`<span class="cp">${</span><span class="n">query</span><span class="cp">}</span><span class="w"> </span>in<span class="w"> </span><span class="cp">${</span><span class="n">language</span><span class="cp">}</span><span class="w"> </span>site:stackoverflow.com`
</code></pre></div>

<p>我们使用用户输入的查询和当前所选的语言来构造搜索字符串。比方说，当用户在写 Python 的时候输入“hello world”，查询语句就会变成 <code>hello world in python site:stackoverflow.com</code>。字符串的最后一部分是谷歌搜索提供的一个过滤器，它让我们可以将搜索结果的来源限制为 StackOverflow。</p>
<div class="highlight"><pre><span></span><code><span class="nv">google</span><span class="ss">(</span><span class="nv">searchString</span>,<span class="w"> </span><span class="ss">(</span><span class="nv">err</span>,<span class="w"> </span><span class="nv">res</span><span class="ss">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span>{
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">err</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">reject</span><span class="ss">(</span>{
<span class="w">      </span><span class="nv">reason</span>:<span class="w"> </span><span class="s1">&#39;A search error has occured :(&#39;</span>
<span class="w">    </span>}<span class="ss">)</span>
<span class="w">  </span>}<span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="ss">(</span><span class="nv">res</span>.<span class="nv">links</span>.<span class="nv">length</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="mi">0</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">reject</span><span class="ss">(</span>{
<span class="w">      </span><span class="nv">reason</span>:<span class="w"> </span><span class="s1">&#39;No results found :(&#39;</span>
<span class="w">    </span>}<span class="ss">)</span>
<span class="w">  </span>}<span class="w"> </span><span class="k">else</span><span class="w"> </span>{
<span class="w">    </span><span class="nv">resolve</span><span class="ss">(</span><span class="nv">res</span>.<span class="nv">links</span>[<span class="mi">0</span>].<span class="nv">href</span><span class="ss">)</span>
<span class="w">  </span>}
}<span class="ss">)</span>
</code></pre></div>

<p>我们将 <code>google</code> 方法放在一个 <code>Promise</code> 里面，这样我们可以异步地返回我们的 URL。我们会传递由 <code>google</code> 返回的所有错误并且会在没有可用的搜索结果的时候返回一个错误。否则我们将通过 <code>resolve</code> 来解析最热门结果的 URL。</p>
<h3>更新 fetch 来使用 search</h3>
<p>我们的最后一步是更新 <code>fetch</code> 函数来使用 <code>search</code> 函数：</p>
<div class="highlight"><pre><span></span><code><span class="n">fetch</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="n">editor</span>
<span class="w">  </span><span class="n">let</span><span class="w"> </span><span class="bp">self</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">this</span>

<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">editor</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">atom</span><span class="o">.</span><span class="n">workspace</span><span class="o">.</span><span class="n">getActiveTextEditor</span><span class="p">())</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">editor</span><span class="o">.</span><span class="n">getSelectedText</span><span class="p">()</span>
<span class="w">    </span><span class="n">let</span><span class="w"> </span><span class="n">language</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">editor</span><span class="o">.</span><span class="n">getGrammar</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>

<span class="w">    </span><span class="bp">self</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">query</span><span class="p">,</span><span class="w"> </span><span class="n">language</span><span class="p">)</span><span class="o">.</span><span class="n">then</span><span class="p">((</span><span class="n">url</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addSuccess</span><span class="p">(</span><span class="s1">&#39;Found google results!&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">url</span><span class="p">)</span>
<span class="w">    </span><span class="p">})</span><span class="o">.</span><span class="n">then</span><span class="p">((</span><span class="n">html</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">let</span><span class="w"> </span><span class="n">answer</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="bp">self</span><span class="o">.</span><span class="n">scrape</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">answer</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="s1">&#39;&#39;</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addWarning</span><span class="p">(</span><span class="s1">&#39;No answer found :(&#39;</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addSuccess</span><span class="p">(</span><span class="s1">&#39;Found snippet!&#39;</span><span class="p">)</span>
<span class="w">        </span><span class="n">editor</span><span class="o">.</span><span class="n">insertText</span><span class="p">(</span><span class="n">answer</span><span class="p">)</span>
<span class="w">      </span><span class="p">}</span>
<span class="w">    </span><span class="p">})</span><span class="o">.</span><span class="n">catch</span><span class="p">((</span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">atom</span><span class="o">.</span><span class="n">notifications</span><span class="o">.</span><span class="n">addWarning</span><span class="p">(</span><span class="n">error</span><span class="o">.</span><span class="n">reason</span><span class="p">)</span>
<span class="w">    </span><span class="p">})</span>
<span class="w">  </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>让我们看看发生了什么变化：</p>
<ul>
<li>我们选中的文本现在变成了用户输入的 <code>query</code></li>
<li>我们使用 <a href="https://atom.io/docs/api/v1.11.1/TextEditor">TextEditor API</a> 来获取当前编辑器选项卡使用的 <code>language</code></li>
<li>我们调用 <code>search</code> 方法来获取一个 URL，然后通过在得到的 Promise 上调用 <code>then</code> 方法来访问这个 URL</li>
</ul>
<p>我们不在 <code>download</code> 返回的 Promise 上调用 <code>then</code> 方法，而是在前面 <code>search</code> 方法本身链式调用的另一个 <code>then</code> 方法返回的 Promise 上面接着调用 <code>then</code> 方法。这样可以帮助我们避免<a href="http://callbackhell.com/">回调地狱</a></p>
<p>在 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial/commit/aa9d0b5fc4811a70292869730e0f60ddf0bcf2aa">sourcefetch 教程仓库</a> 查看这一步所有的代码更改。</p>
<h3>测试最终的插件</h3>
<p>大功告成了！重新加载 Atom，对一个“问题描述”运行软件包的命令来看看我们最终的插件是否工作，不要忘了在编辑器右下角选择一种语言。</p>
<p><img alt="" src="/data/attachment/album/201610/15/160818no9eml1fphvwg5df.gif"></p>
<h3>下一步</h3>
<p>现在你知道怎么去 “hack” Atom 的基本原理了，通过 <a href="https://github.com/NickTikhonov/sourcefetch-tutorial">分叉 sourcefetch 这个仓库并添加你的特性</a> 来随心所欲地实践你所学到的知识。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>