<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>搭个 Web 服务器（二）</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Ruslan 在第一部分中，我提出了一个问题：“如何在你刚刚搭建起来的 Web 服务器上适配 Django, Flask 或 Pyramid 应用，而不用单独对 Web 服务器 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2016/08/da-ge-web-fu-wu-qi-er.html" rel="bookmark"
           title="Permalink to 搭个 Web 服务器（二）">搭个 Web 服务器（二）</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2016-08-16T09:33:00+02:00">
                Published: Tue 16 August 2016
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Ruslan</p>
<p>在<a href="/article-7662-1.html">第一部分</a>中，我提出了一个问题：“如何在你刚刚搭建起来的 Web 服务器上适配 Django, Flask 或 Pyramid 应用，而不用单独对 Web 服务器做做出改动以适应各种不同的 Web 框架呢？”我们可以从这一篇中找到答案。</p>
<p><img alt="" src="/data/attachment/album/201608/15/225543dvfgvgu5i21s5s3y.jpg"></p>
<p>曾几何时，你所选择的 Python Web 框架会限制你所可选择的 Web 服务器，反之亦然。如果某个框架及服务器设计用来协同工作的，那么一切正常：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225600ojw49umhdpn4aewo.png"></p>
<p>但你可能正面对着（或者曾经面对过）尝试将一对无法适配的框架和服务器搭配在一起的问题：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225601j9av7y9ywxa05x5i.png"></p>
<p>基本上，你需要选择那些能够一起工作的框架和服务器，而不能选择你想用的那些。</p>
<p>所以，你该如何确保在不对 Web 服务器或框架的代码做任何更改的情况下，让你的 Web 服务器和多个不同的 Web 框架一同工作呢？这个问题的答案，就是 Python <ruby> <a href="https://www.python.org/dev/peps/pep-0333/">  Web 服务器网关接口 </a> <rp>  （ </rp> <rt>  Web Server Gateway Interface </rt> <rp>  ） </rp></ruby>（缩写为 <a href="https://www.python.org/dev/peps/pep-0333/">WSGI</a>，念做“wizgy”）。</p>
<p><img alt="" src="/data/attachment/album/201608/15/225602vhub9wht9e8cbeiz.png"></p>
<p>WSGI 允许开发者互不干扰地选择 Web 框架及 Web 服务器的类型。现在，你可以真正将 Web 服务器及框架任意搭配，然后选出你最中意的那对组合。比如，你可以使用 <a href="https://www.djangoproject.com/">Django</a>，<a href="http://flask.pocoo.org/">Flask</a> 或者 <a href="http://trypyramid.com/">Pyramid</a>，与 <a href="http://gunicorn.org/">Gunicorn</a>，<a href="http://uwsgi-docs.readthedocs.org/">Nginx/uWSGI</a> 或 <a href="http://waitress.readthedocs.org/">Waitress</a> 进行结合。感谢 WSGI 同时对服务器与框架的支持，我们可以真正随意选择它们的搭配了。</p>
<p><img alt="" src="/data/attachment/album/201608/15/225604wpler4o4pvlezrro.png"></p>
<p>所以，WSGI 就是我在第一部分中提出，又在本文开头重复了一遍的那个问题的答案。你的 Web 服务器必须实现 WSGI 接口的服务器部分，而现代的 Python Web 框架均已实现了 WSGI 接口的框架部分，这使得你可以直接在 Web 服务器中使用任意框架，而不需要更改任何服务器代码，以对特定的 Web 框架实现兼容。</p>
<p>现在，你已经知道 Web 服务器及 Web 框架对 WSGI 的支持使得你可以选择最合适的一对来使用，而且它也有利于服务器和框架的开发者，这样他们只需专注于其擅长的部分来进行开发，而不需要触及另一部分的代码。其它语言也拥有类似的接口，比如：Java 拥有 Servlet API，而 Ruby 拥有 Rack。</p>
<p>这些理论都不错，但是我打赌你在说：“Show me the code!” 那好，我们来看看下面这个很小的 WSGI 服务器实现：</p>
<div class="highlight"><pre><span></span><code><span class="c1">### 使用 Python 2.7.9，在 Linux 及 Mac OS X 下测试通过</span>
<span class="kn">import</span> <span class="nn">socket</span>
<span class="kn">import</span> <span class="nn">StringIO</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="k">class</span> <span class="nc">WSGIServer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>

    <span class="n">address_family</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">AF_INET</span>
    <span class="n">socket_type</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">SOCK_STREAM</span>
    <span class="n">request_queue_size</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">server_address</span><span class="p">):</span>
        <span class="c1">### 创建一个监听的套接字</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span> <span class="o">=</span> <span class="n">listen_socket</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">socket</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">address_family</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">socket_type</span>
        <span class="p">)</span>
        <span class="c1">### 允许复用同一地址</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">setsockopt</span><span class="p">(</span><span class="n">socket</span><span class="o">.</span><span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">socket</span><span class="o">.</span><span class="n">SO_REUSEADDR</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1">### 绑定地址</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">bind</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
        <span class="c1">### 激活套接字</span>
        <span class="n">listen_socket</span><span class="o">.</span><span class="n">listen</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_queue_size</span><span class="p">)</span>
        <span class="c1">### 获取主机的名称及端口</span>
        <span class="n">host</span><span class="p">,</span> <span class="n">port</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span><span class="o">.</span><span class="n">getsockname</span><span class="p">()[:</span><span class="mi">2</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_name</span> <span class="o">=</span> <span class="n">socket</span><span class="o">.</span><span class="n">getfqdn</span><span class="p">(</span><span class="n">host</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">server_port</span> <span class="o">=</span> <span class="n">port</span>
        <span class="c1">### 返回由 Web 框架/应用设定的响应头部字段</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span> <span class="nf">set_app</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">application</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">application</span> <span class="o">=</span> <span class="n">application</span>

    <span class="k">def</span> <span class="nf">serve_forever</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">listen_socket</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">listen_socket</span>
        <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
            <span class="c1">### 获取新的客户端连接</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="p">,</span> <span class="n">client_address</span> <span class="o">=</span> <span class="n">listen_socket</span><span class="o">.</span><span class="n">accept</span><span class="p">()</span>
            <span class="c1">### 处理一条请求后关闭连接，然后循环等待另一个连接建立</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">handle_one_request</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">handle_one_request</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">request_data</span> <span class="o">=</span> <span class="n">request_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">recv</span><span class="p">(</span><span class="mi">1024</span><span class="p">)</span>
        <span class="c1">### 以 &#39;curl -v&#39; 的风格输出格式化请求数据</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="s1">&#39;&lt; </span><span class="si">{line}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">request_data</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">parse_request</span><span class="p">(</span><span class="n">request_data</span><span class="p">)</span>

        <span class="c1">### 根据请求数据构建环境变量字典</span>
        <span class="n">env</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_environ</span><span class="p">()</span>

        <span class="c1">### 此时需要调用 Web 应用来获取结果，</span>
        <span class="c1">### 取回的结果将成为 HTTP 响应体</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">application</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">start_response</span><span class="p">)</span>

        <span class="c1">### 构造一个响应，回送至客户端</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">finish_response</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">parse_request</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
        <span class="n">request_line</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">request_line</span> <span class="o">=</span> <span class="n">request_line</span><span class="o">.</span><span class="n">rstrip</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="c1">### 将请求行分成几个部分</span>
        <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_method</span><span class="p">,</span>  <span class="c1"># GET</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">path</span><span class="p">,</span>            <span class="c1"># /hello</span>
         <span class="bp">self</span><span class="o">.</span><span class="n">request_version</span>  <span class="c1"># HTTP/1.1</span>
         <span class="p">)</span> <span class="o">=</span> <span class="n">request_line</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">get_environ</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">env</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1">### 以下代码段没有遵循 PEP8 规则，但这样排版，是为了通过强调</span>
        <span class="c1">### 所需变量及它们的值，来达到其展示目的。</span>
        <span class="c1">###</span>
        <span class="c1">### WSGI 必需变量</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.version&#39;</span><span class="p">]</span>      <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.url_scheme&#39;</span><span class="p">]</span>   <span class="o">=</span> <span class="s1">&#39;http&#39;</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.input&#39;</span><span class="p">]</span>        <span class="o">=</span> <span class="n">StringIO</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">request_data</span><span class="p">)</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.errors&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">stderr</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.multithread&#39;</span><span class="p">]</span>  <span class="o">=</span> <span class="kc">False</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.multiprocess&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;wsgi.run_once&#39;</span><span class="p">]</span>     <span class="o">=</span> <span class="kc">False</span>
        <span class="c1">### CGI 必需变量</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;REQUEST_METHOD&#39;</span><span class="p">]</span>    <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">request_method</span>    <span class="c1"># GET</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;PATH_INFO&#39;</span><span class="p">]</span>         <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">path</span>              <span class="c1"># /hello</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;SERVER_NAME&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">server_name</span>       <span class="c1"># localhost</span>
        <span class="n">env</span><span class="p">[</span><span class="s1">&#39;SERVER_PORT&#39;</span><span class="p">]</span>       <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">server_port</span><span class="p">)</span>  <span class="c1"># 8888</span>
        <span class="k">return</span> <span class="n">env</span>

    <span class="k">def</span> <span class="nf">start_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1">### 添加必要的服务器头部字段</span>
        <span class="n">server_headers</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;Date&#39;</span><span class="p">,</span> <span class="s1">&#39;Tue, 31 Mar 2015 12:54:48 GMT&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;Server&#39;</span><span class="p">,</span> <span class="s1">&#39;WSGIServer 0.2&#39;</span><span class="p">),</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span> <span class="o">=</span> <span class="p">[</span><span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">+</span> <span class="n">server_headers</span><span class="p">]</span>
        <span class="c1">### 为了遵循 WSGI 协议，start_response 函数必须返回一个 &#39;write&#39;</span>
        <span class="c1">### 可调用对象（返回值.write 可以作为函数调用）。为了简便，我们</span>
        <span class="c1">### 在这里无视这个细节。</span>
        <span class="c1">### return self.finish_response</span>

    <span class="k">def</span> <span class="nf">finish_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">result</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">status</span><span class="p">,</span> <span class="n">response_headers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers_set</span>
            <span class="n">response</span> <span class="o">=</span> <span class="s1">&#39;HTTP/1.1 </span><span class="si">{status}</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">status</span><span class="o">=</span><span class="n">status</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="n">response_headers</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="si">{0}</span><span class="s1">: </span><span class="si">{1}</span><span class="se">\r\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">header</span><span class="p">)</span>
            <span class="n">response</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\r\n</span><span class="s1">&#39;</span>
            <span class="k">for</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">result</span><span class="p">:</span>
                <span class="n">response</span> <span class="o">+=</span> <span class="n">data</span>
            <span class="c1">### 以 &#39;curl -v&#39; 的风格输出格式化请求数据</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="s1">&#39;&gt; </span><span class="si">{line}</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="n">line</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">response</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
            <span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">sendall</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">client_connection</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

<span class="n">SERVER_ADDRESS</span> <span class="o">=</span> <span class="p">(</span><span class="n">HOST</span><span class="p">,</span> <span class="n">PORT</span><span class="p">)</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="mi">8888</span>

<span class="k">def</span> <span class="nf">make_server</span><span class="p">(</span><span class="n">server_address</span><span class="p">,</span> <span class="n">application</span><span class="p">):</span>
    <span class="n">server</span> <span class="o">=</span> <span class="n">WSGIServer</span><span class="p">(</span><span class="n">server_address</span><span class="p">)</span>
    <span class="n">server</span><span class="o">.</span><span class="n">set_app</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">server</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">exit</span><span class="p">(</span><span class="s1">&#39;Provide a WSGI application object as module:callable&#39;</span><span class="p">)</span>
    <span class="n">app_path</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">module</span><span class="p">,</span> <span class="n">application</span> <span class="o">=</span> <span class="n">app_path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
    <span class="n">module</span> <span class="o">=</span> <span class="nb">__import__</span><span class="p">(</span><span class="n">module</span><span class="p">)</span>
    <span class="n">application</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">module</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>
    <span class="n">httpd</span> <span class="o">=</span> <span class="n">make_server</span><span class="p">(</span><span class="n">SERVER_ADDRESS</span><span class="p">,</span> <span class="n">application</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;WSGIServer: Serving HTTP on port </span><span class="si">{port}</span><span class="s1"> ...</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">port</span><span class="o">=</span><span class="n">PORT</span><span class="p">))</span>
    <span class="n">httpd</span><span class="o">.</span><span class="n">serve_forever</span><span class="p">()</span>
</code></pre></div>

<p>当然，这段代码要比第一部分的服务器代码长不少，但它仍然很短（只有不到 150 行），你可以轻松理解它，而不需要深究细节。上面的服务器代码还可以做更多——它可以用来运行一些你喜欢的框架写出的 Web 应用，可以是 Pyramid，Flask，Django 或其它 Python WSGI 框架。</p>
<p>不相信吗？自己来试试看吧。把以上的代码保存为 <code>webserver2.py</code>，或直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/webserver2.py">Github</a> 上下载它。如果你打算不加任何参数而直接运行它，它会抱怨一句，然后退出。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>python<span class="w"> </span>webserver2.py
Provide<span class="w"> </span>a<span class="w"> </span>WSGI<span class="w"> </span>application<span class="w"> </span>object<span class="w"> </span>as<span class="w"> </span>module:callable
</code></pre></div>

<p>它想做的其实是为你的 Web 应用服务，而这才是重头戏。为了运行这个服务器，你唯一需要的就是安装好 Python。不过，如果你希望运行 Pyramid，Flask 或 Django 应用，你还需要先安装那些框架。那我们把这三个都装上吧。我推荐的安装方式是通过 <code>virtualenv</code> 安装。按照以下几步来做，你就可以创建并激活一个虚拟环境，并在其中安装以上三个 Web 框架。</p>
<div class="highlight"><pre><span></span><code><span class="err">$</span><span class="w"> </span><span class="o">[</span><span class="n">sudo</span><span class="o">]</span><span class="w"> </span><span class="n">pip</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">virtualenv</span>
<span class="err">$</span><span class="w"> </span><span class="n">mkdir</span><span class="w"> </span><span class="o">~/</span><span class="n">envs</span>
<span class="err">$</span><span class="w"> </span><span class="n">virtualenv</span><span class="w"> </span><span class="o">~/</span><span class="n">envs</span><span class="o">/</span><span class="n">lsbaws</span><span class="o">/</span>
<span class="err">$</span><span class="w"> </span><span class="n">cd</span><span class="w"> </span><span class="o">~/</span><span class="n">envs</span><span class="o">/</span><span class="n">lsbaws</span><span class="o">/</span>
<span class="err">$</span><span class="w"> </span><span class="n">ls</span>
<span class="n">bin</span><span class="w">  </span><span class="k">include</span><span class="w">  </span><span class="n">lib</span>
<span class="err">$</span><span class="w"> </span><span class="n">source</span><span class="w"> </span><span class="n">bin</span><span class="o">/</span><span class="n">activate</span>
<span class="p">(</span><span class="n">lsbaws</span><span class="p">)</span><span class="w"> </span><span class="err">$</span><span class="w"> </span><span class="n">pip</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">pyramid</span>
<span class="p">(</span><span class="n">lsbaws</span><span class="p">)</span><span class="w"> </span><span class="err">$</span><span class="w"> </span><span class="n">pip</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">flask</span>
<span class="p">(</span><span class="n">lsbaws</span><span class="p">)</span><span class="w"> </span><span class="err">$</span><span class="w"> </span><span class="n">pip</span><span class="w"> </span><span class="n">install</span><span class="w"> </span><span class="n">django</span>
</code></pre></div>

<p>现在，你需要创建一个 Web 应用。我们先从 Pyramid 开始吧。把以下代码保存为 <code>pyramidapp.py</code>，并与刚刚的 <code>webserver2.py</code> 放置在同一目录，或直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/pyramidapp.py">Github</a> 下载该文件：</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">pyramid.config</span> <span class="kn">import</span> <span class="n">Configurator</span>
<span class="kn">from</span> <span class="nn">pyramid.response</span> <span class="kn">import</span> <span class="n">Response</span>

<span class="k">def</span> <span class="nf">hello_world</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span>
        <span class="s1">&#39;Hello world from Pyramid!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">content_type</span><span class="o">=</span><span class="s1">&#39;text/plain&#39;</span><span class="p">,</span>
    <span class="p">)</span>

<span class="n">config</span> <span class="o">=</span> <span class="n">Configurator</span><span class="p">()</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_route</span><span class="p">(</span><span class="s1">&#39;hello&#39;</span><span class="p">,</span> <span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="n">config</span><span class="o">.</span><span class="n">add_view</span><span class="p">(</span><span class="n">hello_world</span><span class="p">,</span> <span class="n">route_name</span><span class="o">=</span><span class="s1">&#39;hello&#39;</span><span class="p">)</span>
<span class="n">app</span> <span class="o">=</span> <span class="n">config</span><span class="o">.</span><span class="n">make_wsgi_app</span><span class="p">()</span>
</code></pre></div>

<p>现在，你可以用你自己的 Web 服务器来运行你的 Pyramid 应用了：</p>
<div class="highlight"><pre><span></span><code>(lsbaws) $ python webserver2.py pyramidapp:app
WSGIServer: Serving HTTP on port 8888 ...
</code></pre></div>

<p>你刚刚让你的服务器去加载 Python 模块 <code>pyramidapp</code> 中的可执行对象 <code>app</code>。现在你的服务器可以接收请求，并将它们转发到你的 Pyramid 应用中了。在浏览器中输入 http://localhost:8888/hello ，敲一下回车，然后看看结果：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225605psna77izlooqt9s7.png"></p>
<p>你也可以使用命令行工具 <code>curl</code> 来测试服务器：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>-v<span class="w"> </span>http://localhost:8888/hello
...
</code></pre></div>

<p>看看服务器和 <code>curl</code> 向标准输出流打印的内容吧。</p>
<p>现在来试试 <code>Flask</code>。运行步骤跟上面的一样。</p>
<div class="highlight"><pre><span></span><code><span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Flask</span>
<span class="kn">from</span> <span class="nn">flask</span> <span class="kn">import</span> <span class="n">Response</span>
<span class="n">flask_app</span> <span class="o">=</span> <span class="n">Flask</span><span class="p">(</span><span class="s1">&#39;flaskapp&#39;</span><span class="p">)</span>

<span class="nd">@flask_app</span><span class="o">.</span><span class="n">route</span><span class="p">(</span><span class="s1">&#39;/hello&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">hello_world</span><span class="p">():</span>
    <span class="k">return</span> <span class="n">Response</span><span class="p">(</span>
        <span class="s1">&#39;Hello world from Flask!</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span>
        <span class="n">mimetype</span><span class="o">=</span><span class="s1">&#39;text/plain&#39;</span>
    <span class="p">)</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">flask_app</span><span class="o">.</span><span class="n">wsgi_app</span>
</code></pre></div>

<p>将以上代码保存为 <code>flaskapp.py</code>，或者直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/flaskapp.py">Github</a> 下载，然后输入以下命令运行服务器：</p>
<div class="highlight"><pre><span></span><code>(lsbaws) $ python webserver2.py flaskapp:app
WSGIServer: Serving HTTP on port 8888 ...
</code></pre></div>

<p>现在在浏览器中输入 http://localhost:8888/hello ，敲一下回车：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225606t68disvs7hpm6mzy.png"></p>
<p>同样，尝试一下 <code>curl</code>，然后你会看到服务器返回了一条 <code>Flask</code> 应用生成的信息：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>-v<span class="w"> </span>http://localhost:8888/hello
...
</code></pre></div>

<p>这个服务器能处理 Django 应用吗？试试看吧！不过这个任务可能有点复杂，所以我建议你将整个仓库克隆下来，然后使用 <a href="https://github.com/rspivak/lsbaws/">Github</a> 仓库中的 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/flaskapp.py">djangoapp.py</a> 来完成这个实验。这里的源代码主要是将 Django 的 helloworld 工程（已使用 <code>Django</code> 的 <code>django-admin.py startproject</code> 命令创建完毕）添加到了当前的 Python 路径中，然后导入了这个工程的 WSGI 应用。（LCTT 译注：除了这里展示的代码，还需要一个配合的 helloworld 工程才能工作，代码可以参见 <a href="https://github.com/rspivak/lsbaws/">Github</a> 仓库。）</p>
<div class="highlight"><pre><span></span><code><span class="kn">import</span> <span class="nn">sys</span>
<span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;./helloworld&#39;</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">helloworld</span> <span class="kn">import</span> <span class="n">wsgi</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">wsgi</span><span class="o">.</span><span class="n">application</span>
</code></pre></div>

<p>将以上代码保存为 <code>djangoapp.py</code>，然后用你的 Web 服务器运行这个 Django 应用：</p>
<div class="highlight"><pre><span></span><code>(lsbaws) $ python webserver2.py djangoapp:app
WSGIServer: Serving HTTP on port 8888 ...
</code></pre></div>

<p>输入以下链接，敲回车：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225607c4zjg44hxhbc84j4.png"></p>
<p>你这次也可以在命令行中测试——你之前应该已经做过两次了——来确认 Django 应用处理了你的请求：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>curl<span class="w"> </span>-v<span class="w"> </span>http://localhost:8888/hello
...
</code></pre></div>

<p>你试过了吗？你确定这个服务器可以与那三个框架搭配工作吗？如果没试，请去试一下。阅读固然重要，但这个系列的内容是<strong>重新搭建</strong>，这意味着你需要亲自动手干点活。去试一下吧。别担心，我等着你呢。不开玩笑，你真的需要试一下，亲自尝试每一步，并确保它像预期的那样工作。</p>
<p>好，你已经体验到了 WSGI 的威力：它可以使 Web 服务器及 Web 框架随意搭配。WSGI 在 Python Web 服务器及框架之间提供了一个微型接口。它非常简单，而且在服务器和框架端均可以轻易实现。下面的代码片段展示了 WSGI 接口的服务器及框架端实现：</p>
<div class="highlight"><pre><span></span><code>def run_application(application):
    &quot;&quot;&quot;服务器端代码。&quot;&quot;&quot;
    ### Web 应用/框架在这里存储 HTTP 状态码以及 HTTP 响应头部，
    ### 服务器会将这些信息传递给客户端
    headers_set = []
    ### 用于存储 WSGI/CGI 环境变量的字典
    environ = {}

    def start_response(status, response_headers, exc_info=None):
        headers_set[:] = [status, response_headers]

    ### 服务器唤醒可执行变量“application”，获得响应头部
    result = application(environ, start_response)
    ### 服务器组装一个 HTTP 响应，将其传送至客户端
    …

def app(environ, start_response):
    &quot;&quot;&quot;一个空的 WSGI 应用&quot;&quot;&quot;
    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;, &#39;text/plain&#39;)])
    return [&#39;Hello world!&#39;]

run_application(app)
</code></pre></div>

<p>这是它的工作原理：</p>
<ol>
<li>Web 框架提供一个可调用对象 <code>application</code> （WSGI 规范没有规定它的实现方式）。</li>
<li>Web 服务器每次收到来自客户端的 HTTP 请求后，会唤醒可调用对象 <code>applition</code>。它会向该对象传递一个包含 WSGI/CGI 变量的环境变量字典 <code>environ</code>，以及一个可调用对象 <code>start_response</code>。</li>
<li>Web 框架或应用生成 HTTP 状态码和 HTTP 响应头部，然后将它传给 <code>start_response</code> 函数，服务器会将其存储起来。同时，Web 框架或应用也会返回 HTTP 响应正文。</li>
<li>服务器将状态码、响应头部及响应正文组装成一个 HTTP 响应，然后将其传送至客户端（这一步并不在 WSGI 规范中，但从逻辑上讲，这一步应该包含在工作流程之中。所以为了明确这个过程，我把它写了出来）</li>
</ol>
<p>这是这个接口规范的图形化表达：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225608kq2qdigitju2dqvi.png"></p>
<p>到现在为止，你已经看过了用 Pyramid、Flask 和 Django 写出的 Web 应用的代码，你也看到了一个 Web 服务器如何用代码来实现另一半（服务器端的） WSGI 规范。你甚至还看到了我们如何在不使用任何框架的情况下，使用一段代码来实现一个最简单的 WSGI Web 应用。</p>
<p>其实，当你使用上面的框架编写一个 Web 应用时，你只是在较高的层面工作，而不需要直接与 WSGI 打交道。但是我知道你一定也对 WSGI 接口的框架部分感兴趣，因为你在看这篇文章呀。所以，我们不用 Pyramid、Flask 或 Django，而是自己动手来创造一个最朴素的 WSGI Web 应用（或 Web 框架），然后将它和你的服务器一起运行：</p>
<div class="highlight"><pre><span></span><code><span class="nx">def</span><span class="w"> </span><span class="nx">app</span><span class="p">(</span><span class="nx">environ</span><span class="p">,</span><span class="w"> </span><span class="nx">start_response</span><span class="p">):</span>
<span class="w">    </span><span class="s">&quot;&quot;&quot;一个最简单的 WSGI 应用。</span>

<span class="s">    这是你自己的 Web 框架的起点 ^_^</span>
<span class="s">    &quot;&quot;&quot;</span>
<span class="w">    </span><span class="nx">status</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="err">&#39;</span><span class="mi">200</span><span class="w"> </span><span class="nx">OK</span><span class="err">&#39;</span>
<span class="w">    </span><span class="nx">response_headers</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="p">[(</span><span class="err">&#39;</span><span class="nx">Content</span><span class="o">-</span><span class="nx">Type</span><span class="err">&#39;</span><span class="p">,</span><span class="w"> </span><span class="err">&#39;</span><span class="nx">text</span><span class="o">/</span><span class="nx">plain</span><span class="err">&#39;</span><span class="p">)]</span>
<span class="w">    </span><span class="nx">start_response</span><span class="p">(</span><span class="nx">status</span><span class="p">,</span><span class="w"> </span><span class="nx">response_headers</span><span class="p">)</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="p">[</span><span class="err">&#39;</span><span class="nx">Hello</span><span class="w"> </span><span class="nx">world</span><span class="w"> </span><span class="nx">from</span><span class="w"> </span><span class="nx">a</span><span class="w"> </span><span class="nx">simple</span><span class="w"> </span><span class="nx">WSGI</span><span class="w"> </span><span class="nx">application</span><span class="p">!</span><span class="err">\</span><span class="nx">n</span><span class="err">&#39;</span><span class="p">]</span>
</code></pre></div>

<p>同样，将上面的代码保存为 <code>wsgiapp.py</code> 或直接从 <a href="https://github.com/rspivak/lsbaws/blob/master/part2/wsgiapp.py">Github</a> 上下载该文件，然后在 Web 服务器上运行这个应用，像这样：</p>
<div class="highlight"><pre><span></span><code>(lsbaws) $ python webserver2.py wsgiapp:app
WSGIServer: Serving HTTP on port 8888 ...
</code></pre></div>

<p>在浏览器中输入下面的地址，然后按下回车。这是你应该看到的结果：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225610rhag2g994fv92zf0.png"></p>
<p>你刚刚在学习如何创建一个 Web 服务器的过程中自己编写了一个最朴素的 WSGI Web 框架！棒极了！</p>
<p>现在，我们再回来看看服务器传给客户端的那些东西。这是在使用 HTTP 客户端调用你的 Pyramid 应用时，服务器生成的 HTTP 响应内容：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225612v3l3v3a4275j4y24.png"></p>
<p>这个响应和你在本系列第一部分中看到的 HTTP 响应有一部分共同点，但它还多出来了一些内容。比如说，它拥有四个你曾经没见过的 <a href="http://en.wikipedia.org/wiki/List_of_HTTP_header_fields">HTTP 头部</a>：<code>Content-Type</code>, <code>Content-Length</code>, <code>Date</code> 以及 <code>Server</code>。这些头部内容基本上在每个 Web 服务器返回的响应中都会出现。不过，它们都不是被严格要求出现的。这些 HTTP 请求/响应头部字段的目的在于它可以向你传递一些关于 HTTP 请求/响应的额外信息。</p>
<p>既然你对 WSGI 接口了解的更深了一些，那我再来展示一下上面那个 HTTP 响应中的各个部分的信息来源：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225616pfoomiqmrdswrpqz.png"></p>
<p>我现在还没有对上面那个 <code>environ</code> 字典做任何解释，不过基本上这个字典必须包含那些被 WSGI 规范事先定义好的 WSGI 及 CGI 变量值。服务器在解析 HTTP 请求时，会从请求中获取这些变量的值。这是 <code>environ</code> 字典应该有的样子：</p>
<p><img alt="" src="/data/attachment/album/201608/15/225618aptoggjttuzrovvg.png"></p>
<p>Web 框架会利用以上字典中包含的信息，通过字典中的请求路径、请求动作等等来决定使用哪个视图来处理响应、在哪里读取请求正文、在哪里输出错误信息（如果有的话）。</p>
<p>现在，你已经创造了属于你自己的 WSGI Web 服务器，你也使用不同 Web 框架做了几个 Web 应用。而且，你在这个过程中也自己创造出了一个朴素的 Web 应用及框架。这个过程真是累人。现在我们来回顾一下，你的 WSGI Web 服务器在服务请求时，需要针对 WSGI 应用做些什么：</p>
<ul>
<li>首先，服务器开始工作，然后会加载一个可调用对象 <code>application</code>，这个对象由你的 Web 框架或应用提供</li>
<li>然后，服务器读取一个请求</li>
<li>然后，服务器会解析这个请求</li>
<li>然后，服务器会使用请求数据来构建一个 <code>environ</code> 字典</li>
<li>然后，它会用 <code>environ</code> 字典及一个可调用对象 <code>start_response</code> 作为参数，来调用 <code>application</code>，并获取响应体内容。</li>
<li>然后，服务器会使用 <code>application</code> 返回的响应体，和 <code>start_response</code> 函数设置的状态码及响应头部内容，来构建一个 HTTP 响应。</li>
<li>最终，服务器将 HTTP 响应回送给客户端。</li>
</ul>
<p><img alt="" src="/data/attachment/album/201608/15/225622yi7gzgztyezr42z7.png"></p>
<p>这基本上是服务器要做的全部内容了。你现在有了一个可以正常工作的 WSGI 服务器，它可以为使用任何遵循 WSGI 规范的 Web 框架（如 Django、Flask、Pyramid，还有你刚刚自己写的那个框架）构建出的 Web 应用服务。最棒的部分在于，它可以在不用更改任何服务器代码的情况下，与多个不同的 Web 框架一起工作。真不错。</p>
<p>在结束之前，你可以想想这个问题：“你该如何让你的服务器在同一时间处理多个请求呢？”</p>
<p>敬请期待，我会在第三部分向你展示一种解决这个问题的方法。干杯！</p>
<p>顺便，我在撰写一本名为《搭个 Web 服务器：从头开始》的书。这本书讲解了如何从头开始编写一个基本的 Web 服务器，里面包含本文中没有的更多细节。<a href="https://ruslanspivak.com/lsbaws-part2/">订阅邮件列表</a>，你就可以获取到这本书的最新进展，以及发布日期。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>