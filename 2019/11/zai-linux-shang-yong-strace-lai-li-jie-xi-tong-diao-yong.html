<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>在 Linux 上用 strace 来理解系统调用</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Gaurav Kamathe 使用 strace 跟踪用户进程和 Linux 内核之间的交互。 系统调用 system call 是程序从内核请求服务的一种编程方式，而 strace 是一个功 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li class="active"><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2019/11/zai-linux-shang-yong-strace-lai-li-jie-xi-tong-diao-yong.html" rel="bookmark"
           title="Permalink to 在 Linux 上用 strace 来理解系统调用">在 Linux 上用 strace 来理解系统调用</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-11-06T13:13:45+01:00">
                Published: Wed 06 November 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ji-zhu">技术</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Gaurav Kamathe</p>
<blockquote>
<p>使用 strace 跟踪用户进程和 Linux 内核之间的交互。</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/201911/06/131316xf9059emez99a829.jpg"></p>
<p><ruby> 系统调用 <rt>  system call </rt></ruby>是程序从内核请求服务的一种编程方式，而 <code>strace</code> 是一个功能强大的工具，可让你跟踪用户进程与 Linux 内核之间的交互。</p>
<p>要了解操作系统的工作原理，首先需要了解系统调用的工作原理。操作系统的主要功能之一是为用户程序提供抽象机制。</p>
<p>操作系统可以大致分为两种模式：</p>
<ul>
<li>内核模式：操作系统内核使用的一种强大的特权模式</li>
<li>用户模式：大多数用户应用程序运行的地方 用户大多使用命令行实用程序和图形用户界面（GUI）来执行日常任务。系统调用在后台静默运行，与内核交互以完成工作。</li>
</ul>
<p>系统调用与函数调用非常相似，这意味着它们都接受并处理参数然后返回值。唯一的区别是系统调用进入内核，而函数调用不进入。从用户空间切换到内核空间是使用特殊的 <a href="https://en.wikipedia.org/wiki/Trap_(computing)">trap</a> 机制完成的。</p>
<p>通过使用系统库（在 Linux 系统上又称为 glibc），大部分系统调用对用户隐藏了。尽管系统调用本质上是通用的，但是发出系统调用的机制在很大程度上取决于机器（架构）。</p>
<p>本文通过使用一些常规命令并使用 <code>strace</code> 分析每个命令进行的系统调用来探索一些实际示例。这些示例使用 Red Hat Enterprise Linux，但是这些命令运行在其他 Linux 发行版上应该也是相同的：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span><span class="w"> </span><span class="o">/</span><span class="n">etc</span><span class="o">/</span><span class="n">redhat</span><span class="o">-</span><span class="k">release</span>
<span class="n">Red</span><span class="w"> </span><span class="n">Hat</span><span class="w"> </span><span class="n">Enterprise</span><span class="w"> </span><span class="n">Linux</span><span class="w"> </span><span class="n">Server</span><span class="w"> </span><span class="k">release</span><span class="w"> </span><span class="mf">7.7</span><span class="w"> </span><span class="p">(</span><span class="n">Maipo</span><span class="p">)</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">uname</span><span class="w"> </span><span class="o">-</span><span class="n">r</span>
<span class="mf">3.10.0</span><span class="o">-</span><span class="mf">1062.</span><span class="n">el7</span><span class="p">.</span><span class="n">x86_64</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>首先，确保在系统上安装了必需的工具。你可以使用下面的 <code>rpm</code> 命令来验证是否安装了 <code>strace</code>。如果安装了，则可以使用 <code>-V</code> 选项检查 <code>strace</code> 实用程序的版本号：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">rpm</span><span class="w"> </span><span class="o">-</span><span class="n">qa</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="o">-</span><span class="n">i</span><span class="w"> </span><span class="n">strace</span>
<span class="n">strace</span><span class="o">-</span><span class="mf">4.12</span><span class="o">-</span><span class="mf">9.</span><span class="n">el7</span><span class="p">.</span><span class="n">x86_64</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="o">-</span><span class="n">V</span>
<span class="n">strace</span><span class="w"> </span><span class="o">--</span><span class="w"> </span><span class="n">version</span><span class="w"> </span><span class="mf">4.12</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>如果没有安装，运行命令安装：</p>
<div class="highlight"><pre><span></span><code>yum install strace
</code></pre></div>

<p>出于本示例的目的，在 <code>/tmp</code> 中创建一个测试目录，并使用 <code>touch</code> 命令创建两个文件：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">cd</span><span class="w"> </span><span class="o">/</span><span class="n">tmp</span><span class="o">/</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">mkdir</span><span class="w"> </span><span class="n">testdir</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">touch</span><span class="w"> </span><span class="n">testdir</span><span class="o">/</span><span class="n">file1</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">touch</span><span class="w"> </span><span class="n">testdir</span><span class="o">/</span><span class="n">file2</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>（我使用 <code>/tmp</code> 目录是因为每个人都可以访问它，但是你可以根据需要选择另一个目录。）</p>
<p>在 <code>testdir</code> 目录下使用 <code>ls</code> 命令验证该文件已经创建：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="n">testdir</span><span class="o">/</span>
<span class="n">file1</span><span class="w">  </span><span class="n">file2</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>你可能每天都在使用 <code>ls</code> 命令，而没有意识到系统调用在其下面发挥的作用。抽象地来说，该命令的工作方式如下：</p>
<blockquote>
<p>命令行工具 -&gt; 从系统库（glibc）调用函数 -&gt; 调用系统调用</p>
</blockquote>
<p><code>ls</code> 命令内部从 Linux 上的系统库（即 glibc）调用函数。这些库去调用完成大部分工作的系统调用。</p>
<p>如果你想知道从 glibc 库中调用了哪些函数，请使用 <code>ltrace</code> 命令，然后跟上常规的 <code>ls testdir/</code>命令：</p>
<div class="highlight"><pre><span></span><code>ltrace ls testdir/
</code></pre></div>

<p>如果没有安装 <code>ltrace</code>，键入如下命令安装：</p>
<div class="highlight"><pre><span></span><code>yum install ltrace
</code></pre></div>

<p>大量的输出会被堆到屏幕上；不必担心，只需继续就行。<code>ltrace</code> 命令输出中与该示例有关的一些重要库函数包括：</p>
<div class="highlight"><pre><span></span><code><span class="nv">opendir</span><span class="ss">(</span><span class="s2">&quot;testdir/&quot;</span><span class="ss">)</span><span class="w">                                  </span><span class="o">=</span><span class="w"> </span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}
<span class="nv">readdir</span><span class="ss">(</span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}<span class="ss">)</span><span class="w">                                       </span><span class="o">=</span><span class="w"> </span>{<span class="w"> </span><span class="mi">101879119</span>,<span class="w"> </span><span class="s2">&quot;.&quot;</span><span class="w"> </span>}
<span class="nv">readdir</span><span class="ss">(</span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}<span class="ss">)</span><span class="w">                                       </span><span class="o">=</span><span class="w"> </span>{<span class="w"> </span><span class="mi">134</span>,<span class="w"> </span><span class="s2">&quot;..&quot;</span><span class="w"> </span>}
<span class="nv">readdir</span><span class="ss">(</span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}<span class="ss">)</span><span class="w">                                       </span><span class="o">=</span><span class="w"> </span>{<span class="w"> </span><span class="mi">101879120</span>,<span class="w"> </span><span class="s2">&quot;file1&quot;</span><span class="w"> </span>}
<span class="k">strlen</span><span class="ss">(</span><span class="s2">&quot;file1&quot;</span><span class="ss">)</span><span class="w">                                      </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="nv">memcpy</span><span class="ss">(</span><span class="mi">0</span><span class="nv">x1665be0</span>,<span class="w"> </span><span class="s2">&quot;file1\0&quot;</span>,<span class="w"> </span><span class="mi">6</span><span class="ss">)</span><span class="w">                      </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="nv">x1665be0</span>
<span class="nv">readdir</span><span class="ss">(</span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}<span class="ss">)</span><span class="w">                                       </span><span class="o">=</span><span class="w"> </span>{<span class="w"> </span><span class="mi">101879122</span>,<span class="w"> </span><span class="s2">&quot;file2&quot;</span><span class="w"> </span>}
<span class="k">strlen</span><span class="ss">(</span><span class="s2">&quot;file2&quot;</span><span class="ss">)</span><span class="w">                                      </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="nv">memcpy</span><span class="ss">(</span><span class="mi">0</span><span class="nv">x166dcb0</span>,<span class="w"> </span><span class="s2">&quot;file2\0&quot;</span>,<span class="w"> </span><span class="mi">6</span><span class="ss">)</span><span class="w">                      </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="nv">x166dcb0</span>
<span class="nv">readdir</span><span class="ss">(</span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}<span class="ss">)</span><span class="w">                                       </span><span class="o">=</span><span class="w"> </span><span class="nv">nil</span>
<span class="nv">closedir</span><span class="ss">(</span>{<span class="w"> </span><span class="mi">3</span><span class="w"> </span>}<span class="ss">)</span><span class="w">                                         </span>
</code></pre></div>

<p>通过查看上面的输出，你或许可以了解正在发生的事情。<code>opendir</code> 库函数打开一个名为 <code>testdir</code> 的目录，然后调用 <code>readdir</code> 函数，该函数读取目录的内容。最后，有一个对 <code>closedir</code> 函数的调用，该函数将关闭先前打开的目录。现在请先忽略其他 <code>strlen</code> 和 <code>memcpy</code> 功能。</p>
<p>你可以看到正在调用哪些库函数，但是本文将重点介绍由系统库函数调用的系统调用。</p>
<p>与上述类似，要了解调用了哪些系统调用，只需将 <code>strace</code> 放在 <code>ls testdir</code> 命令之前，如下所示。 再次，一堆乱码丢到了你的屏幕上，你可以按照以下步骤进行操作：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">sandbox</span><span class="w"> </span><span class="n">tmp</span><span class="p">]</span><span class="c1"># strace ls testdir/</span>
<span class="n">execve</span><span class="p">(</span><span class="s2">&quot;/usr/bin/ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">/*</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="o">*/</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">brk</span><span class="p">(</span><span class="n">NULL</span><span class="p">)</span><span class="w">                               </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1f12000</span>
<span class="o">&lt;&lt;&lt;</span><span class="w"> </span><span class="n">truncated</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="n">output</span><span class="w"> </span><span class="o">&gt;&gt;&gt;</span>
<span class="n">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;file1  file2</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="n">file1</span><span class="w">  </span><span class="n">file2</span>
<span class="p">)</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span>
<span class="n">close</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="w">                                </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">munmap</span><span class="p">(</span><span class="mh">0x7fd002c8d000</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">)</span><span class="w">            </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">close</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="w">                                </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">exit_group</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">                           </span><span class="o">=</span><span class="w"> </span><span class="err">?</span>
<span class="o">+++</span><span class="w"> </span><span class="n">exited</span><span class="w"> </span><span class="n">with</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+++</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">sandbox</span><span class="w"> </span><span class="n">tmp</span><span class="p">]</span><span class="c1">#</span>
</code></pre></div>

<p>运行 <code>strace</code> 命令后屏幕上的输出就是运行 <code>ls</code> 命令的系统调用。每个系统调用都为操作系统提供了特定的用途，可以将它们大致分为以下几个部分：</p>
<ul>
<li>进程管理系统调用</li>
<li>文件管理系统调用</li>
<li>目录和文件系统管理系统调用</li>
<li>其他系统调用</li>
</ul>
<p>分析显示到屏幕上的信息的一种更简单的方法是使用 <code>strace</code> 方便的 <code>-o</code> 标志将输出记录到文件中。在 <code>-o</code> 标志后添加一个合适的文件名，然后再次运行命令：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="o">-</span><span class="n">o</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="n">testdir</span><span class="o">/</span>
<span class="n">file1</span><span class="w">  </span><span class="n">file2</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>这次，没有任何输出干扰屏幕显示，<code>ls</code> 命令如预期般工作，显示了文件名并将所有输出记录到文件 <code>trace.log</code> 中。仅仅是一个简单的 <code>ls</code> 命令，该文件就有近 100 行内容：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="o">-</span><span class="n">l</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span>
<span class="o">-</span><span class="n">rw</span><span class="o">-</span><span class="n">r</span><span class="o">--</span><span class="n">r</span><span class="o">--</span><span class="p">.</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="n">root</span><span class="w"> </span><span class="mi">7809</span><span class="w"> </span><span class="n">Oct</span><span class="w"> </span><span class="mi">12</span><span class="w"> </span><span class="mi">13</span><span class="err">:</span><span class="mi">52</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">wc</span><span class="w"> </span><span class="o">-</span><span class="n">l</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span>
<span class="mi">114</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>让我们看一下这个示例的 <code>trace.log</code> 文件的第一行:</p>
<div class="highlight"><pre><span></span><code><span class="n">execve</span><span class="p">(</span><span class="s2">&quot;/usr/bin/ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">/*</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="o">*/</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<ul>
<li>该行的第一个单词 <code>execve</code> 是正在执行的系统调用的名称。</li>
<li>括号内的文本是提供给该系统调用的参数。</li>
<li>符号 <code>=</code> 后的数字（在这种情况下为 <code>0</code>）是 <code>execve</code> 系统调用的返回值。</li>
</ul>
<p>现在的输出似乎还不太吓人，对吧。你可以应用相同的逻辑来理解其他行。</p>
<p>现在，将关注点集中在你调用的单个命令上，即 <code>ls testdir</code>。你知道命令 <code>ls</code> 使用的目录名称，那么为什么不在 <code>trace.log</code> 文件中使用 <code>grep</code> 查找 <code>testdir</code> 并查看得到的结果呢？让我们详细查看一下结果的每一行：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">sandbox</span><span class="w"> </span><span class="n">tmp</span><span class="p">]</span><span class="c1"># grep testdir trace.log</span>
<span class="n">execve</span><span class="p">(</span><span class="s2">&quot;/usr/bin/ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">/*</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="o">*/</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">stat</span><span class="p">(</span><span class="s2">&quot;testdir/&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">{</span><span class="n">st_mode</span><span class="o">=</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="mi">0755</span><span class="p">,</span><span class="w"> </span><span class="n">st_size</span><span class="o">=</span><span class="mi">32</span><span class="p">,</span><span class="w"> </span><span class="o">...</span><span class="p">})</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="n">openat</span><span class="p">(</span><span class="n">AT_FDCWD</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_NONBLOCK</span><span class="o">|</span><span class="n">O_DIRECTORY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">sandbox</span><span class="w"> </span><span class="n">tmp</span><span class="p">]</span><span class="c1">#</span>
</code></pre></div>

<p>回顾一下上面对 <code>execve</code> 的分析，你能说一下这个系统调用的作用吗？</p>
<div class="highlight"><pre><span></span><code><span class="n">execve</span><span class="p">(</span><span class="s2">&quot;/usr/bin/ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">/*</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="o">*/</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
</code></pre></div>

<p>你无需记住所有系统调用或它们所做的事情，因为你可以在需要时参考文档。手册页可以解救你！在运行 <code>man</code> 命令之前，请确保已安装以下软件包：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">rpm</span><span class="w"> </span><span class="o">-</span><span class="n">qa</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="o">-</span><span class="n">i</span><span class="w"> </span><span class="n">man</span><span class="o">-</span><span class="n">pages</span>
<span class="n">man</span><span class="o">-</span><span class="n">pages</span><span class="o">-</span><span class="mf">3.53</span><span class="o">-</span><span class="mf">5.</span><span class="n">el7</span><span class="p">.</span><span class="n">noarch</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>请记住，你需要在 <code>man</code> 命令和系统调用名称之间添加 <code>2</code>。如果使用 <code>man man</code> 阅读 <code>man</code> 命令的手册页，你会看到第 2 节是为系统调用保留的。同样，如果你需要有关库函数的信息，则需要在 <code>man</code> 和库函数名称之间添加一个 <code>3</code>。</p>
<p>以下是手册的章节编号及其包含的页面类型：</p>
<ul>
<li><code>1</code>：可执行的程序或 shell 命令</li>
<li><code>2</code>：系统调用（由内核提供的函数）</li>
<li><code>3</code>：库调用（在程序的库内的函数）</li>
<li><code>4</code>：特殊文件（通常出现在 <code>/dev</code>）</li>
</ul>
<p>使用系统调用名称运行以下 <code>man</code> 命令以查看该系统调用的文档：</p>
<div class="highlight"><pre><span></span><code>man 2 execve
</code></pre></div>

<p>按照 <code>execve</code> 手册页，这将执行在参数中传递的程序（在本例中为 <code>ls</code>）。可以为 <code>ls</code> 提供其他参数，例如本例中的 <code>testdir</code>。因此，此系统调用仅以 <code>testdir</code> 作为参数运行 <code>ls</code>：</p>
<div class="highlight"><pre><span></span><code>execve - execute program

DESCRIPTION
       execve()  executes  the  program  pointed to by filename
</code></pre></div>

<p>下一个系统调用，名为 <code>stat</code>，它使用 <code>testdir</code> 参数：</p>
<div class="highlight"><pre><span></span><code>stat(&quot;testdir/&quot;, {st_mode=S_IFDIR|0755, st_size=32, ...}) = 0
</code></pre></div>

<p>使用 <code>man 2 stat</code> 访问该文档。<code>stat</code> 是获取文件状态的系统调用，请记住，Linux 中的一切都是文件，包括目录。</p>
<p>接下来，<code>openat</code> 系统调用将打开 <code>testdir</code>。密切注意返回的 <code>3</code>。这是一个文件描述符，将在以后的系统调用中使用：</p>
<div class="highlight"><pre><span></span><code>openat(AT_FDCWD, &quot;testdir/&quot;, O_RDONLY|O_NONBLOCK|O_DIRECTORY|O_CLOEXEC) = 3
</code></pre></div>

<p>到现在为止一切都挺好。现在，打开 <code>trace.log</code> 文件，并转到 <code>openat</code> 系统调用之后的行。你会看到 <code>getdents</code> 系统调用被调用，该调用完成了执行 <code>ls testdir</code> 命令所需的大部分操作。现在，从 <code>trace.log</code> 文件中用 <code>grep</code> 获取 <code>getdents</code>：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="n">getdents</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span>
<span class="n">getdents</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 4 entries */</span><span class="p">,</span><span class="w"> </span><span class="mi">32768</span><span class="p">)</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">112</span>
<span class="n">getdents</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 0 entries */</span><span class="p">,</span><span class="w"> </span><span class="mi">32768</span><span class="p">)</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p><code>getdents</code> 的手册页将其描述为 “获取目录项”，这就是你要执行的操作。注意，<code>getdents</code> 的参数是 <code>3</code>，这是来自上面 <code>openat</code> 系统调用的文件描述符。</p>
<p>现在有了目录列表，你需要一种在终端中显示它的方法。因此，在日志中用 <code>grep</code> 搜索另一个用于写入终端的系统调用 <code>write</code>：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="k">write</span><span class="w"> </span><span class="n">trace</span><span class="p">.</span><span class="nf">log</span>
<span class="k">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;file1  file2\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>在这些参数中，你可以看到将要显示的文件名：<code>file1</code> 和 <code>file2</code>。关于第一个参数（<code>1</code>），请记住在 Linux 中，当运行任何进程时，默认情况下会为其打开三个文件描述符。以下是默认的文件描述符：</p>
<ul>
<li><code>0</code>：标准输入</li>
<li><code>1</code>：标准输出</li>
<li><code>2</code>：标准错误</li>
</ul>
<p>因此，<code>write</code> 系统调用将在标准显示（就是这个终端，由 <code>1</code> 所标识的）上显示 <code>file1</code> 和 <code>file2</code>。</p>
<p>现在你知道哪个系统调用完成了 <code>ls testdir/</code> 命令的大部分工作。但是在 <code>trace.log</code> 文件中其它的 100 多个系统调用呢？操作系统必须做很多内务处理才能运行一个进程，因此，你在该日志文件中看到的很多内容都是进程初始化和清理。阅读整个 <code>trace.log</code> 文件，并尝试了解 <code>ls</code> 命令是怎么工作起来的。</p>
<p>既然你知道了如何分析给定命令的系统调用，那么就可以将该知识用于其他命令来了解正在执行哪些系统调用。<code>strace</code> 提供了许多有用的命令行标志，使你更容易使用，下面将对其中一些进行描述。</p>
<p>默认情况下，<code>strace</code> 并不包含所有系统调用信息。但是，它有一个方便的 <code>-v</code> 冗余选项，可以在每个系统调用中提供附加信息：</p>
<div class="highlight"><pre><span></span><code>strace -v ls testdir
</code></pre></div>

<p>在运行 <code>strace</code> 命令时始终使用 <code>-f</code> 选项是一种好的作法。它允许 <code>strace</code> 对当前正在跟踪的进程创建的任何子进程进行跟踪：</p>
<div class="highlight"><pre><span></span><code>strace -f ls testdir
</code></pre></div>

<p>假设你只需要系统调用的名称、运行的次数以及每个系统调用花费的时间百分比。你可以使用 <code>-c</code> 标志来获取这些统计信息：</p>
<div class="highlight"><pre><span></span><code>strace -c ls testdir/
</code></pre></div>

<p>假设你想专注于特定的系统调用，例如专注于 <code>open</code> 系统调用，而忽略其余部分。你可以使用<code>-e</code> 标志跟上系统调用的名称：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="o">-</span><span class="n">e</span><span class="w"> </span><span class="k">open</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="n">testdir</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/etc/ld.so.cache&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libselinux.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libcap.so.2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libacl.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libc.so.6&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libpcre.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libdl.so.2&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libattr.so.1&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/lib64/libpthread.so.0&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="k">open</span><span class="p">(</span><span class="ss">&quot;/usr/lib/locale/locale-archive&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
<span class="n">file1</span><span class="w">  </span><span class="n">file2</span>
<span class="o">+++</span><span class="w"> </span><span class="n">exited</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+++</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>如果你想关注多个系统调用怎么办？不用担心，你同样可以使用 <code>-e</code> 命令行标志，并用逗号分隔开两个系统调用的名称。例如，要查看 <code>write</code> 和 <code>getdents</code> 系统调用：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="o">-</span><span class="n">e</span><span class="w"> </span><span class="k">write</span><span class="p">,</span><span class="n">getdents</span><span class="w"> </span><span class="n">ls</span><span class="w"> </span><span class="n">testdir</span>
<span class="n">getdents</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 4 entries */</span><span class="p">,</span><span class="w"> </span><span class="mi">32768</span><span class="p">)</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">112</span>
<span class="n">getdents</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="cm">/* 0 entries */</span><span class="p">,</span><span class="w"> </span><span class="mi">32768</span><span class="p">)</span><span class="w">     </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="k">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;file1  file2\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">13</span><span class="n">file1</span><span class="w">  </span><span class="n">file2</span>
<span class="p">)</span><span class="w">          </span><span class="o">=</span><span class="w"> </span><span class="mi">13</span>
<span class="o">+++</span><span class="w"> </span><span class="n">exited</span><span class="w"> </span><span class="k">with</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">+++</span>
<span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>到目前为止，这些示例是明确地运行的命令进行了跟踪。但是，要跟踪已经运行并正在执行的命令又怎么办呢？例如，如果要跟踪用来长时间运行进程的守护程序，该怎么办？为此，<code>strace</code> 提供了一个特殊的 <code>-p</code> 标志，你可以向其提供进程 ID。</p>
<p>我们的示例不在守护程序上运行 <code>strace</code>，而是以 <code>cat</code> 命令为例，如果你将文件名作为参数，通常 <code>cat</code> 会显示文件的内容。如果没有给出参数，<code>cat</code> 命令会在终端上等待用户输入文本。输入文本后，它将重复给定的文本，直到用户按下 <code>Ctrl + C</code> 退出为止。</p>
<p>从一个终端运行 <code>cat</code> 命令；它会向你显示一个提示，并等待在那里（记住 <code>cat</code> 仍在运行且尚未退出）：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span>
</code></pre></div>

<p>在另一个终端上，使用 <code>ps</code> 命令找到进程标识符（PID）：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">ps</span><span class="w"> </span><span class="o">-</span><span class="n">ef</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="n">cat</span>
<span class="n">root</span><span class="w">      </span><span class="mi">22443</span><span class="w">  </span><span class="mi">20164</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="mi">14</span><span class="err">:</span><span class="mi">19</span><span class="w"> </span><span class="n">pts</span><span class="o">/</span><span class="mi">0</span><span class="w">    </span><span class="mi">00</span><span class="err">:</span><span class="mi">00</span><span class="err">:</span><span class="mi">00</span><span class="w"> </span><span class="n">cat</span>
<span class="n">root</span><span class="w">      </span><span class="mi">22482</span><span class="w">  </span><span class="mi">20300</span><span class="w">  </span><span class="mi">0</span><span class="w"> </span><span class="mi">14</span><span class="err">:</span><span class="mi">20</span><span class="w"> </span><span class="n">pts</span><span class="o">/</span><span class="mi">1</span><span class="w">    </span><span class="mi">00</span><span class="err">:</span><span class="mi">00</span><span class="err">:</span><span class="mi">00</span><span class="w"> </span><span class="n">grep</span><span class="w"> </span><span class="o">--</span><span class="n">color</span><span class="o">=</span><span class="n">auto</span><span class="w"> </span><span class="n">cat</span>
<span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span>
</code></pre></div>

<p>现在，使用 <code>-p</code> 标志和 PID（在上面使用 <code>ps</code> 找到）对运行中的进程运行 <code>strace</code>。运行 <code>strace</code> 之后，其输出说明了所接驳的进程的内容及其 PID。现在，<code>strace</code> 正在跟踪 <code>cat</code> 命令进行的系统调用。看到的第一个系统调用是 <code>read</code>，它正在等待文件描述符 <code>0</code>（标准输入，这是运行 <code>cat</code> 命令的终端）的输入：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="o">-</span><span class="n">p</span><span class="w"> </span><span class="mi">22443</span>
<span class="nl">strace</span><span class="p">:</span><span class="w"> </span><span class="n">Process</span><span class="w"> </span><span class="mi">22443</span><span class="w"> </span><span class="n">attached</span>
<span class="k">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
</code></pre></div>

<p>现在，返回到你运行 <code>cat</code> 命令的终端，并输入一些文本。我出于演示目的输入了 <code>x0x0</code>。注意 <code>cat</code> 是如何简单地重复我输入的内容的。因此，<code>x0x0</code> 出现了两次。我输入了第一个，第二个是 <code>cat</code> 命令重复的输出：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox tmp</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">cat</span>
<span class="n">x0x0</span>
<span class="n">x0x0</span>
</code></pre></div>

<p>返回到将 <code>strace</code> 接驳到 <code>cat</code> 进程的终端。现在你会看到两个额外的系统调用：较早的 <code>read</code> 系统调用，现在在终端中读取 <code>x0x0</code>，另一个为 <code>write</code>，它将 <code>x0x0</code> 写回到终端，然后是再一个新的 <code>read</code>，正在等待从终端读取。请注意，标准输入（<code>0</code>）和标准输出（<code>1</code>）都在同一终端中：</p>
<div class="highlight"><pre><span></span><code><span class="o">[</span><span class="n">root@sandbox ~</span><span class="o">]</span><span class="err">#</span><span class="w"> </span><span class="n">strace</span><span class="w"> </span><span class="o">-</span><span class="n">p</span><span class="w"> </span><span class="mi">22443</span>
<span class="nl">strace</span><span class="p">:</span><span class="w"> </span><span class="n">Process</span><span class="w"> </span><span class="mi">22443</span><span class="w"> </span><span class="n">attached</span>
<span class="k">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;x0x0\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">65536</span><span class="p">)</span><span class="w">                </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="k">write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="ss">&quot;x0x0\n&quot;</span><span class="p">,</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span><span class="w">                   </span><span class="o">=</span><span class="w"> </span><span class="mi">5</span>
<span class="k">read</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span>
</code></pre></div>

<p>想象一下，对守护进程运行 <code>strace</code> 以查看其在后台执行的所有操作时这有多大帮助。按下 <code>Ctrl + C</code> 杀死 <code>cat</code> 命令；由于该进程不再运行，因此这也会终止你的 <code>strace</code> 会话。</p>
<p>如果要查看所有的系统调用的时间戳，只需将 <code>-t</code> 选项与 <code>strace</code> 一起使用：</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">sandbox</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="c1">#strace -t ls testdir/</span>

<span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">47</span><span class="w"> </span><span class="n">execve</span><span class="p">(</span><span class="s2">&quot;/usr/bin/ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">/*</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="o">*/</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">47</span><span class="w"> </span><span class="n">brk</span><span class="p">(</span><span class="n">NULL</span><span class="p">)</span><span class="w">                      </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1f07000</span>
<span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">47</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7f2530bc8000</span>
<span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">47</span><span class="w"> </span><span class="n">access</span><span class="p">(</span><span class="s2">&quot;/etc/ld.so.preload&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">R_OK</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="n">ENOENT</span><span class="w"> </span><span class="p">(</span><span class="n">No</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">directory</span><span class="p">)</span>
<span class="mi">14</span><span class="p">:</span><span class="mi">24</span><span class="p">:</span><span class="mi">47</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;/etc/ld.so.cache&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>

<p>如果你想知道两次系统调用之间所花费的时间怎么办？<code>strace</code> 有一个方便的 <code>-r</code> 命令，该命令显示执行每个系统调用所花费的时间。非常有用，不是吗？</p>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="n">root</span><span class="err">@</span><span class="n">sandbox</span><span class="w"> </span><span class="o">~</span><span class="p">]</span><span class="c1">#strace -r ls testdir/</span>

<span class="mf">0.000000</span><span class="w"> </span><span class="n">execve</span><span class="p">(</span><span class="s2">&quot;/usr/bin/ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="p">[</span><span class="s2">&quot;ls&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;testdir/&quot;</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="o">/*</span><span class="w"> </span><span class="mi">40</span><span class="w"> </span><span class="n">vars</span><span class="w"> </span><span class="o">*/</span><span class="p">])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span>
<span class="mf">0.000368</span><span class="w"> </span><span class="n">brk</span><span class="p">(</span><span class="n">NULL</span><span class="p">)</span><span class="w">                 </span><span class="o">=</span><span class="w"> </span><span class="mh">0x1966000</span>
<span class="mf">0.000073</span><span class="w"> </span><span class="n">mmap</span><span class="p">(</span><span class="n">NULL</span><span class="p">,</span><span class="w"> </span><span class="mi">4096</span><span class="p">,</span><span class="w"> </span><span class="n">PROT_READ</span><span class="o">|</span><span class="n">PROT_WRITE</span><span class="p">,</span><span class="w"> </span><span class="n">MAP_PRIVATE</span><span class="o">|</span><span class="n">MAP_ANONYMOUS</span><span class="p">,</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mh">0x7fb6b1155000</span>
<span class="mf">0.000047</span><span class="w"> </span><span class="n">access</span><span class="p">(</span><span class="s2">&quot;/etc/ld.so.preload&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">R_OK</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="n">ENOENT</span><span class="w"> </span><span class="p">(</span><span class="n">No</span><span class="w"> </span><span class="n">such</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="ow">or</span><span class="w"> </span><span class="n">directory</span><span class="p">)</span>
<span class="mf">0.000119</span><span class="w"> </span><span class="n">open</span><span class="p">(</span><span class="s2">&quot;/etc/ld.so.cache&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">O_RDONLY</span><span class="o">|</span><span class="n">O_CLOEXEC</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">3</span>
</code></pre></div>

<h3>总结</h3>
<p><code>strace</code> 实用程序非常有助于理解 Linux 上的系统调用。要了解它的其它命令行标志，请参考手册页和在线文档。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>