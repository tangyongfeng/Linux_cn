<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>如何使用 Protobuf 做数据交换</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Marty Kalin 在以不同语言编写并在不同平台上运行的应用程序之间交换数据时，Protobuf 编码可提高效率。 协议缓冲区 Protocol Buffers （Protobufs）像 XML …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2019/11/ru-he-shi-yong-protobuf-zuo-shu-ju-jiao-huan.html" rel="bookmark"
           title="Permalink to 如何使用 Protobuf 做数据交换">如何使用 Protobuf 做数据交换</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2019-11-22T07:59:06+01:00">
                Published: Fri 22 November 2019
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Marty Kalin</p>
<blockquote>
<p>在以不同语言编写并在不同平台上运行的应用程序之间交换数据时，Protobuf 编码可提高效率。</p>
</blockquote>
<p><img alt="" src="/data/attachment/album/201911/22/075757pn2fxfth30ntwefg.jpg"></p>
<p><ruby> 协议缓冲区 <rt>  Protocol Buffers </rt></ruby>（<a href="https://developers.google.com/protocol-buffers/">Protobufs</a>）像 XML 和 JSON 一样，可以让用不同语言编写并在不同平台上运行的应用程序交换数据。例如，用 Go 编写的发送程序可以在 Protobuf 中对以 Go 表示的销售订单数据进行编码，然后用 Java 编写的接收方可以对它进行解码，以获取所接收订单数据的 Java 表示方式。这是在网络连接上的结构示意图：</p>
<blockquote>
<p>Go 销售订单 —&gt; Pbuf 编码 —&gt; 网络 —&gt; Pbuf 界面 —&gt; Java 销售订单</p>
</blockquote>
<p>与 XML 和 JSON 相比，Protobuf 编码是二进制而不是文本，这会使调试复杂化。但是，正如本文中的代码示例所确认的那样，Protobuf 编码在大小上比 XML 或 JSON 编码要有效得多。</p>
<p>Protobuf 以另一种方式提供了这种有效性。在实现级别，Protobuf 和其他编码系统对结构化数据进行<ruby> 序列化 <rt>  serialize </rt></ruby>和<ruby> 反序列化 <rt>  deserialize </rt></ruby>。序列化将特定语言的数据结构转换为字节流，反序列化是将字节流转换回特定语言的数据结构的逆运算。序列化和反序列化可能成为数据交换的瓶颈，因为这些操作会占用大量 CPU。高效的序列化和反序列化是 Protobuf 的另一个设计目标。</p>
<p>最近的编码技术，例如 Protobuf 和 FlatBuffers，源自 1990 年代初期的 <a href="https://en.wikipedia.org/wiki/DCE/RPC">DCE/RPC</a>（<ruby> 分布式计算环境/远程过程调用 <rt>  Distributed Computing Environment/Remote Procedure Call </rt></ruby>）计划。与 DCE/RPC 一样，Protobuf 在数据交换中为 <a href="https://en.wikipedia.org/wiki/Interface_description_language">IDL</a>（接口定义语言）和编码层做出了贡献。</p>
<p>本文将着眼于这两层，然后提供 Go 和 Java 中的代码示例以充实 Protobuf 的细节，并表明 Protobuf 是易于使用的。</p>
<h3>Protobuf 作为一个 IDL 和编码层</h3>
<p>像 Protobuf 一样，DCE/RPC 被设计为与语言和平台无关。适当的库和实用程序允许任何语言和平台用于 DCE/RPC 领域。此外，DCE/RPC 体系结构非常优雅。IDL 文档是一侧的远程过程与另一侧的调用者之间的协定。Protobuf 也是以 IDL 文档为中心的。</p>
<p>IDL 文档是文本，在 DCE/RPC 中，使用基本 C 语法以及元数据的语法扩展（方括号）和一些新的关键字，例如 <code>interface</code>。这是一个例子：</p>
<div class="highlight"><pre><span></span><code><span class="k">[uuid (2d6ead46-05e3-11ca-7dd1-426909beabcd), version(1.0)]</span>
<span class="na">interface echo {</span>
<span class="w">   </span><span class="na">const long int ECHO_SIZE</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">512</span><span class="c1">;</span>
<span class="w">   </span><span class="na">void echo(</span>
<span class="w">      </span><span class="na">[in]          handle_t h,</span>
<span class="w">      </span><span class="na">[in, string]  idl_char from_client[ ],</span>
<span class="w">      </span><span class="k">[out, string] idl_char from_service[ECHO_SIZE]</span>
<span class="w">   </span><span class="na">);</span>
<span class="na">}</span>
</code></pre></div>

<p>该 IDL 文档声明了一个名为 <code>echo</code> 的过程，该过程带有三个参数：类型为 <code>handle_t</code>（实现指针）和 <code>idl_char</code>（ASCII 字符数组）的 <code>[in]</code> 参数被传递给远程过程，而 <code>[out]</code> 参数（也是一个字符串）从该过程中传回。在此示例中，<code>echo</code> 过程不会显式返回值（<code>echo</code> 左侧的 <code>void</code>），但也可以返回值。返回值，以及一个或多个 <code>[out]</code> 参数，允许远程过程任意返回许多值。下一节将介绍 Protobuf IDL，它的语法不同，但同样用作数据交换中的协定。</p>
<p>DCE/RPC 和 Protobuf 中的 IDL 文档是创建用于交换数据的基础结构代码的实用程序的输入：</p>
<blockquote>
<p>IDL 文档 —&gt; DCE/PRC 或 Protobuf 实用程序 —&gt; 数据交换的支持代码</p>
</blockquote>
<p>作为相对简单的文本，IDL 是同样便于人类阅读的关于数据交换细节的文档（特别是交换的数据项的数量和每个项的数据类型）。</p>
<p>Protobuf 可用于现代 RPC 系统，例如 <a href="https://grpc.io/">gRPC</a>；但是 Protobuf 本身仅提供 IDL 层和编码层，用于从发送者传递到接收者的消息。与原本的 DCE/RPC 一样，Protobuf 编码是二进制的，但效率更高。</p>
<p>目前，XML 和 JSON 编码仍在通过 Web 服务等技术进行的数据交换中占主导地位，这些技术利用 Web 服务器、传输协议（例如 TCP、HTTP）以及标准库和实用程序等原有的基础设施来处理 XML 和 JSON 文档。 此外，各种类型的数据库系统可以存储 XML 和 JSON 文档，甚至旧式关系型系统也可以轻松生成查询结果的 XML 编码。现在，每种通用编程语言都具有支持 XML 和 JSON 的库。那么，是什么让我们回到 Protobuf 之类的<strong>二进制</strong>编码系统呢？</p>
<p>让我们看一下负十进制值 <code>-128</code>。以 2 的补码二进制表示形式（在系统和语言中占主导地位）中，此值可以存储在单个 8 位字节中：<code>10000000</code>。此整数值在 XML 或 JSON 中的文本编码需要多个字节。例如，UTF-8 编码需要四个字节的字符串，即 <code>-128</code>，即每个字符一个字节（十六进制，值为 <code>0x2d</code>、<code>0x31</code>、<code>0x32</code> 和 <code>0x38</code>）。XML 和 JSON 还添加了标记字符，例如尖括号和大括号。有关 Protobuf 编码的详细信息下面就会介绍，但现在的关注点是一个通用点：文本编码的压缩性明显低于二进制编码。</p>
<h3>在 Go 中使用 Protobuf 的示例</h3>
<p>我的代码示例着重于 Protobuf 而不是 RPC。以下是第一个示例的概述：</p>
<ul>
<li>名为 <code>dataitem.proto</code> 的 IDL 文件定义了一个 Protobuf 消息，它具有六个不同类型的字段：具有不同范围的整数值、固定大小的浮点值以及两个不同长度的字符串。</li>
<li>Protobuf 编译器使用 IDL 文件生成 Go 版本（以及后面的 Java 版本）的 Protobuf 消息及支持函数。</li>
<li>Go 应用程序使用随机生成的值填充原生的 Go 数据结构，然后将结果序列化为本地文件。为了进行比较， XML 和 JSON 编码也被序列化为本地文件。</li>
<li>作为测试，Go 应用程序通过反序列化 Protobuf 文件的内容来重建其原生数据结构的实例。</li>
<li>作为语言中立性测试，Java 应用程序还会对 Protobuf 文件的内容进行反序列化以获取原生数据结构的实例。</li>
</ul>
<p><a href="http://condor.depaul.edu/mkalin">我的网站</a>上提供了该 IDL 文件以及两个 Go 和一个 Java 源文件，打包为 ZIP 文件。</p>
<p>最重要的 Protobuf IDL 文档如下所示。该文档存储在文件 <code>dataitem.proto</code> 中，并具有常规的<code>.proto</code> 扩展名。</p>
<h4>示例 1、Protobuf IDL 文档</h4>
<div class="highlight"><pre><span></span><code><span class="nx">syntax</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;proto3&quot;</span><span class="p">;</span>

<span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="p">;</span>

<span class="nx">message</span><span class="w"> </span><span class="nx">DataItem</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">int64</span><span class="w">  </span><span class="nx">oddA</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="nx">int64</span><span class="w">  </span><span class="nx">evenA</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">  </span><span class="nx">int32</span><span class="w">  </span><span class="nx">oddB</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">  </span><span class="nx">int32</span><span class="w">  </span><span class="nx">evenB</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">  </span><span class="nx">float</span><span class="w">  </span><span class="nx">small</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">  </span><span class="nx">float</span><span class="w">  </span><span class="nx">big</span><span class="w">   </span><span class="p">=</span><span class="w"> </span><span class="mi">6</span><span class="p">;</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="nx">short</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">7</span><span class="p">;</span>
<span class="w">  </span><span class="kt">string</span><span class="w"> </span><span class="nx">long</span><span class="w">  </span><span class="p">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>该 IDL 使用当前的 proto3 而不是较早的 proto2 语法。软件包名称（在本例中为 <code>main</code>）是可选的，但是惯例使用它以避免名称冲突。这个结构化的消息包含八个字段，每个字段都有一个 Protobuf 数据类型（例如，<code>int64</code>、<code>string</code>）、名称（例如，<code>oddA</code>、<code>short</code>）和一个等号 <code>=</code> 之后的数字标签（即键）。标签（在此示例中为 1 到 8）是唯一的整数标识符，用于确定字段序列化的顺序。</p>
<p>Protobuf 消息可以嵌套到任意级别，而一个消息可以是另外一个消息的字段类型。这是一个使用 <code>DataItem</code> 消息作为字段类型的示例：</p>
<div class="highlight"><pre><span></span><code>message DataItems {
  repeated DataItem item = 1;
}
</code></pre></div>

<p>单个 <code>DataItems</code> 消息由重复的（零个或多个）<code>DataItem</code> 消息组成。</p>
<p>为了清晰起见，Protobuf 还支持枚举类型：</p>
<div class="highlight"><pre><span></span><code><span class="k">enum</span><span class="w"> </span><span class="n">PartnershipStatus</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">reserved</span><span class="w"> </span><span class="s2">&quot;FREE&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;CONSTRAINED&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;OTHER&quot;</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>reserved</code> 限定符确保用于实现这三个符号名的数值不能重复使用。</p>
<p>为了生成一个或多个声明 Protobuf 消息结构的特定于语言的版本，包含这些结构的 IDL 文件被传递到<code>protoc</code> 编译器（可在 <a href="https://github.com/protocolbuffers/protobuf">Protobuf GitHub 存储库</a>中找到）。对于 Go 代码，可以以通常的方式安装支持的 Protobuf 库（这里以 <code>％</code> 作为命令行提示符）：</p>
<div class="highlight"><pre><span></span><code><span class="c">% go get github.com/golang/protobuf/proto</span>
</code></pre></div>

<p>将 Protobuf IDL 文件 <code>dataitem.proto</code> 编译为 Go 源代码的命令是：</p>
<div class="highlight"><pre><span></span><code><span class="c">% protoc --go_out=. dataitem.proto</span>
</code></pre></div>

<p>标志 <code>--go_out</code> 指示编译器生成 Go 源代码。其他语言也有类似的标志。在这种情况下，结果是一个名为 <code>dataitem.pb.go</code> 的文件，该文件足够小，可以将其基本内容复制到 Go 应用程序中。以下是生成的代码的主要部分：</p>
<div class="highlight"><pre><span></span><code><span class="k">var</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proto</span><span class="o">.</span><span class="n">Marshal</span>

<span class="n">type</span><span class="w"> </span><span class="n">DataItem</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">OddA</span><span class="w">  </span><span class="n">int64</span><span class="w">   </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;varint,1,opt,name=oddA&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;oddA,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">EvenA</span><span class="w"> </span><span class="n">int64</span><span class="w">   </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;varint,2,opt,name=evenA&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;evenA,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">OddB</span><span class="w">  </span><span class="n">int32</span><span class="w">   </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;varint,3,opt,name=oddB&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;oddB,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">EvenB</span><span class="w"> </span><span class="n">int32</span><span class="w">   </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;varint,4,opt,name=evenB&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;evenB,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">Small</span><span class="w"> </span><span class="n">float32</span><span class="w"> </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;fixed32,5,opt,name=small&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;small,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">Big</span><span class="w">   </span><span class="n">float32</span><span class="w"> </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;fixed32,6,opt,name=big&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;big,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">Short</span><span class="w"> </span><span class="n">string</span><span class="w">  </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;bytes,7,opt,name=short&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;short,omitempty&quot;</span><span class="err">`</span>
<span class="w">   </span><span class="n">Long</span><span class="w">  </span><span class="n">string</span><span class="w">  </span><span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;bytes,8,opt,name=long&quot;</span><span class="w"> </span><span class="n">json</span><span class="p">:</span><span class="s2">&quot;long,omitempty&quot;</span><span class="err">`</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="n">DataItem</span><span class="p">)</span><span class="w"> </span><span class="n">Reset</span><span class="p">()</span><span class="w">         </span><span class="p">{</span><span class="w"> </span><span class="o">*</span><span class="n">m</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">DataItem</span><span class="p">{}</span><span class="w"> </span><span class="p">}</span>
<span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">m</span><span class="w"> </span><span class="o">*</span><span class="n">DataItem</span><span class="p">)</span><span class="w"> </span><span class="nb nb-Type">String</span><span class="p">()</span><span class="w"> </span><span class="n">string</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="k">return</span><span class="w"> </span><span class="n">proto</span><span class="o">.</span><span class="n">CompactTextString</span><span class="p">(</span><span class="n">m</span><span class="p">)</span><span class="w"> </span><span class="p">}</span>
<span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">DataItem</span><span class="p">)</span><span class="w"> </span><span class="n">ProtoMessage</span><span class="p">()</span><span class="w">    </span><span class="p">{}</span>
<span class="k">func</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">{}</span>
</code></pre></div>

<p>编译器生成的代码具有 Go 结构 <code>DataItem</code>，该结构导出 Go 字段（名称现已大写开头），该字段与 Protobuf IDL 中声明的名称匹配。该结构字段具有标准的 Go 数据类型：<code>int32</code>、<code>int64</code>、<code>float32</code> 和 <code>string</code>。在每个字段行的末尾，是描述 Protobuf 类型的字符串，提供 Protobuf IDL 文档中的数字标签及有关 JSON 信息的元数据，这将在后面讨论。</p>
<p>此外也有函数；最重要的是 <code>Proto.Marshal</code>，用于将 <code>DataItem</code> 结构的实例序列化为 Protobuf 格式。辅助函数包括：清除 <code>DataItem</code> 结构的 <code>Reset</code>，生成 <code>DataItem</code> 的单行字符串表示的 <code>String</code>。</p>
<p>描述 Protobuf 编码的元数据应在更详细地分析 Go 程序之前进行仔细研究。</p>
<h3>Protobuf 编码</h3>
<p>Protobuf 消息的结构为键/值对的集合，其中数字标签为键，相应的字段为值。字段名称（例如，<code>oddA</code> 和 <code>small</code>）是供人类阅读的，但是 <code>protoc</code> 编译器的确使用了字段名称来生成特定于语言的对应名称。例如，Protobuf IDL 中的 <code>oddA</code> 和 <code>small</code> 名称在 Go 结构中分别成为字段 <code>OddA</code> 和 <code>Small</code>。</p>
<p>键和它们的值都被编码，但是有一个重要的区别：一些数字值具有固定大小的 32 或 64 位的编码，而其他数字（包括消息标签）则是 <code>varint</code> 编码的，位数取决于整数的绝对值。例如，整数值 1 到 15 需要 8 位 <code>varint</code> 编码，而值 16 到 2047 需要 16 位。<code>varint</code> 编码在本质上与 UTF-8 编码类似（但细节不同），它偏爱较小的整数值而不是较大的整数值。（有关详细分析，请参见 Protobuf <a href="https://developers.google.com/protocol-buffers/docs/encoding">编码指南</a>）结果是，Protobuf 消息应该在字段中具有较小的整数值（如果可能），并且键数应尽可能少，但每个字段至少得有一个键。</p>
<p>下表 1 列出了 Protobuf 编码的要点：</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>示例类型</th>
<th>长度</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>varint</code></td>
<td><code>int32</code>、<code>uint32</code>、<code>int64</code></td>
<td>可变长度</td>
</tr>
<tr>
<td><code>fixed</code></td>
<td><code>fixed32</code>、<code>float</code>、<code>double</code></td>
<td>固定的 32 位或 64 位长度</td>
</tr>
<tr>
<td>字节序列</td>
<td><code>string</code>、<code>bytes</code></td>
<td>序列长度</td>
</tr>
</tbody>
</table>
<p><em>表 1. Protobuf 数据类型</em></p>
<p>未明确固定长度的整数类型是 <code>varint</code> 编码的；因此，在 <code>varint</code> 类型中，例如 <code>uint32</code>（<code>u</code> 代表无符号），数字 32 描述了整数的范围（在这种情况下为 0 到 2<sup> 32</sup> - 1），而不是其位的大小，该位大小取决于值。相比之下，对于固定长度类型（例如 <code>fixed32</code> 或 <code>double</code>），Protobuf 编码分别需要 32 位和 64 位。Protobuf 中的字符串是字节序列；因此，字段编码的大小就是字节序列的长度。</p>
<p>另一个高效的方法值得一提。回想一下前面的示例，其中的 <code>DataItems</code> 消息由重复的 <code>DataItem</code> 实例组成：</p>
<div class="highlight"><pre><span></span><code>message DataItems {
  repeated DataItem item = 1;
}
</code></pre></div>

<p><code>repeated</code> 表示 <code>DataItem</code> 实例是<em>打包的</em>：集合具有单个标签，在这里是 1。因此，具有重复的 <code>DataItem</code> 实例的 <code>DataItems</code> 消息比具有多个但单独的 <code>DataItem</code> 字段、每个字段都需要自己的标签的消息的效率更高。</p>
<p>了解了这一背景，让我们回到 Go 程序。</p>
<h3>dataItem 程序的细节</h3>
<p><code>dataItem</code> 程序创建一个 <code>DataItem</code> 实例，并使用适当类型的随机生成的值填充字段。Go 有一个 <code>rand</code> 包，带有用于生成伪随机整数和浮点值的函数，而我的 <code>randString</code> 函数可以从字符集中生成指定长度的伪随机字符串。设计目标是要有一个具有不同类型和位大小的字段值的 <code>DataItem</code> 实例。例如，<code>OddA</code> 和 <code>EvenA</code> 值分别是 64 位非负整数值的奇数和偶数；但是 <code>OddB</code> 和 <code>EvenB</code> 变体的大小为 32 位，并存放 0 到 2047 之间的小整数值。随机浮点值的大小为 32 位，字符串为 16（<code>Short</code>）和 32（<code>Long</code>）字符的长度。这是用随机值填充 <code>DataItem</code> 结构的代码段：</p>
<div class="highlight"><pre><span></span><code><span class="c1">// 可变长度整数</span>
<span class="n">n1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="nb">rand</span><span class="p">.</span><span class="n">Int63</span><span class="p">()</span><span class="w">        </span><span class="c1">// 大整数</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n1</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n1</span><span class="o">++</span><span class="w"> </span><span class="p">}</span><span class="w"> </span><span class="c1">// 确保其是奇数</span>
<span class="p">...</span>
<span class="n">n3</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="nb">rand</span><span class="p">.</span><span class="n">Int31</span><span class="p">()</span><span class="w"> </span>%<span class="w"> </span><span class="n">UpperBound</span><span class="w"> </span><span class="c1">// 小整数</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n3</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mi">1</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">n3</span><span class="o">++</span><span class="w"> </span><span class="p">}</span><span class="w">       </span><span class="c1">// 确保其是奇数</span>

<span class="c1">// 固定长度浮点数</span>
<span class="p">...</span>
<span class="n">t1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="nb">rand</span><span class="p">.</span><span class="n">Float32</span><span class="p">()</span>
<span class="n">t2</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="nb">rand</span><span class="p">.</span><span class="n">Float32</span><span class="p">()</span>
<span class="p">...</span>
<span class="c1">// 字符串</span>
<span class="n">str1</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">randString</span><span class="p">(</span><span class="n">StrShort</span><span class="p">)</span>
<span class="n">str2</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="n">randString</span><span class="p">(</span><span class="n">StrLong</span><span class="p">)</span>

<span class="c1">// 消息</span>
<span class="n">dataItem</span><span class="w"> </span><span class="p">:=</span><span class="w"> </span><span class="o">&amp;</span><span class="n">DataItem</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">OddA</span><span class="p">:</span><span class="w">  </span><span class="n">n1</span><span class="p">,</span>
<span class="w">   </span><span class="n">EvenA</span><span class="p">:</span><span class="w"> </span><span class="n">n2</span><span class="p">,</span>
<span class="w">   </span><span class="n">OddB</span><span class="p">:</span><span class="w">  </span><span class="n">n3</span><span class="p">,</span>
<span class="w">   </span><span class="n">EvenB</span><span class="p">:</span><span class="w"> </span><span class="n">n4</span><span class="p">,</span>
<span class="w">   </span><span class="n">Big</span><span class="p">:</span><span class="w">   </span><span class="n">f1</span><span class="p">,</span>
<span class="w">   </span><span class="n">Small</span><span class="p">:</span><span class="w"> </span><span class="n">f2</span><span class="p">,</span>
<span class="w">   </span><span class="n">Short</span><span class="p">:</span><span class="w"> </span><span class="n">str1</span><span class="p">,</span>
<span class="w">   </span><span class="n">Long</span><span class="p">:</span><span class="w">  </span><span class="n">str2</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div>

<p>创建并填充值后，<code>DataItem</code> 实例将以 XML、JSON 和 Protobuf 进行编码，每种编码均写入本地文件：</p>
<div class="highlight"><pre><span></span><code><span class="k">func</span><span class="w"> </span><span class="n">encodeAndserialize</span><span class="p">(</span><span class="n">dataItem</span><span class="w"> </span><span class="o">*</span><span class="n">DataItem</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">xml</span><span class="o">.</span><span class="n">MarshalIndent</span><span class="p">(</span><span class="n">dataItem</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Xml</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">dataitem</span><span class="o">.</span><span class="n">xml</span>
<span class="w">   </span><span class="n">ioutil</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="n">XmlFile</span><span class="p">,</span><span class="w"> </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">0644</span><span class="p">)</span><span class="w">            </span><span class="o">//</span><span class="w"> </span><span class="mi">0644</span><span class="w"> </span><span class="k">is</span><span class="w"> </span><span class="n">file</span><span class="w"> </span><span class="n">access</span><span class="w"> </span><span class="n">permissions</span>

<span class="w">   </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">json</span><span class="o">.</span><span class="n">MarshalIndent</span><span class="p">(</span><span class="n">dataItem</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot; &quot;</span><span class="p">)</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">Json</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">dataitem</span><span class="o">.</span><span class="n">json</span>
<span class="w">   </span><span class="n">ioutil</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="n">JsonFile</span><span class="p">,</span><span class="w"> </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">0644</span><span class="p">)</span>

<span class="w">   </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">proto</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="n">dataItem</span><span class="p">)</span><span class="w">                </span><span class="o">//</span><span class="w"> </span><span class="n">Protobuf</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">dataitem</span><span class="o">.</span><span class="n">pbuf</span>
<span class="w">   </span><span class="n">ioutil</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="n">PbufFile</span><span class="p">,</span><span class="w"> </span><span class="n">bytes</span><span class="p">,</span><span class="w"> </span><span class="mi">0644</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>这三个序列化函数使用术语 <code>marshal</code>，它与 <code>serialize</code> 意思大致相同。如代码所示，三个 <code>Marshal</code> 函数均返回一个字节数组，然后将其写入文件。（为简单起见，忽略可能的错误处理。）在示例运行中，文件大小为：</p>
<div class="highlight"><pre><span></span><code><span class="n">dataitem.xml:  262 bytes</span>
<span class="n">dataitem.json: 212 bytes</span>
<span class="n">dataitem.pbuf:  88 bytes</span>
</code></pre></div>

<p>Protobuf 编码明显小于其他两个编码方案。通过消除缩进字符（在这种情况下为空白和换行符），可以稍微减小 XML 和 JSON 序列化的大小。</p>
<p>以下是 <code>dataitem.json</code> 文件，该文件最终是由 <code>json.MarshalIndent</code> 调用产生的，并添加了以 <code>##</code> 开头的注释：</p>
<div class="highlight"><pre><span></span><code>{
<span class="w"> </span><span class="s2">&quot;oddA&quot;</span>:<span class="w">  </span><span class="mi">4744002665212642479</span>,<span class="w">                </span>##<span class="w"> </span><span class="mi">64</span><span class="o">-</span><span class="nv">bit</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span>
<span class="w"> </span><span class="s2">&quot;evenA&quot;</span>:<span class="w"> </span><span class="mi">2395006495604861128</span>,<span class="w">                </span>##<span class="w"> </span><span class="nv">ditto</span>
<span class="w"> </span><span class="s2">&quot;oddB&quot;</span>:<span class="w">  </span><span class="mi">57</span>,<span class="w">                                 </span>##<span class="w"> </span><span class="mi">32</span><span class="o">-</span><span class="nv">bit</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="nv">but</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="mi">2048</span>
<span class="w"> </span><span class="s2">&quot;evenB&quot;</span>:<span class="w"> </span><span class="mi">468</span>,<span class="w">                                </span>##<span class="w"> </span><span class="nv">ditto</span>
<span class="w"> </span><span class="s2">&quot;small&quot;</span>:<span class="w"> </span><span class="mi">0</span>.<span class="mi">7562016</span>,<span class="w">                          </span>##<span class="w"> </span><span class="mi">32</span><span class="o">-</span><span class="nv">bit</span><span class="w"> </span><span class="nv">floating</span><span class="o">-</span><span class="nv">point</span>
<span class="w"> </span><span class="s2">&quot;big&quot;</span>:<span class="w">   </span><span class="mi">0</span>.<span class="mi">85202795</span>,<span class="w">                         </span>##<span class="w"> </span><span class="nv">ditto</span>
<span class="w"> </span><span class="s2">&quot;short&quot;</span>:<span class="w"> </span><span class="s2">&quot;ClH1oDaTtoX$HBN5&quot;</span>,<span class="w">                 </span>##<span class="w"> </span><span class="mi">16</span><span class="w"> </span><span class="k">random</span><span class="w"> </span><span class="nv">chars</span>
<span class="w"> </span><span class="s2">&quot;long&quot;</span>:<span class="w">  </span><span class="s2">&quot;xId0rD3Cri%3Wt%^QjcFLJgyXBu9^DZI&quot;</span><span class="w">  </span>##<span class="w"> </span><span class="mi">32</span><span class="w"> </span><span class="k">random</span><span class="w"> </span><span class="nv">chars</span>
}
</code></pre></div>

<p>尽管这些序列化的数据写入到本地文件中，但是也可以使用相同的方法将数据写入网络连接的输出流。</p>
<h3>测试序列化和反序列化</h3>
<p>Go 程序接下来通过将先前写入 <code>dataitem.pbuf</code> 文件的字节反序列化为 <code>DataItem</code> 实例来运行基本测试。这是代码段，其中去除了错误检查部分：</p>
<div class="highlight"><pre><span></span><code><span class="nv">filebytes</span><span class="p">,</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">ioutil</span><span class="o">.</span><span class="nf">ReadFile</span><span class="p">(</span><span class="nv">PbufFile</span><span class="p">)</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nv">get</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">bytes</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">file</span>
<span class="o">...</span>
<span class="nv">testItem</span><span class="o">.</span><span class="nf">Reset</span><span class="p">()</span><span class="w">                            </span><span class="o">//</span><span class="w"> </span><span class="nv">clear</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">DataItem</span><span class="w"> </span><span class="nv">structure</span>
<span class="nv">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">proto</span><span class="o">.</span><span class="nf">Unmarshal</span><span class="p">(</span><span class="nv">filebytes</span><span class="p">,</span><span class="w"> </span><span class="nv">testItem</span><span class="p">)</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nv">deserialize</span><span class="w"> </span><span class="nv">into</span><span class="w"> </span><span class="nv">a</span><span class="w"> </span><span class="nv">DataItem</span><span class="w"> </span><span class="nv">instance</span>
</code></pre></div>

<p>用于 Protbuf 反序列化的 <code>proto.Unmarshal</code> 函数与 <code>proto.Marshal</code> 函数相反。原始的 <code>DataItem</code> 和反序列化的副本将被打印出来以确认完全匹配：</p>
<div class="highlight"><pre><span></span><code><span class="n">Original</span><span class="o">:</span>
<span class="mi">2041519981506242154</span><span class="w"> </span><span class="mi">3041486079683013705</span><span class="w"> </span><span class="mi">1192</span><span class="w"> </span><span class="mi">1879</span>
<span class="mf">0.572123</span><span class="w"> </span><span class="mf">0.326855</span>
<span class="n">boPb</span><span class="err">#</span><span class="n">T0O8Xd</span><span class="o">&amp;</span><span class="n">Ps5EnSZqDg4Qztvo7IIs</span><span class="w"> </span><span class="mi">9</span><span class="n">vH66AiGSQgCDxk</span><span class="o">&amp;</span>

<span class="n">Deserialized</span><span class="o">:</span>
<span class="mi">2041519981506242154</span><span class="w"> </span><span class="mi">3041486079683013705</span><span class="w"> </span><span class="mi">1192</span><span class="w"> </span><span class="mi">1879</span>
<span class="mf">0.572123</span><span class="w"> </span><span class="mf">0.326855</span>
<span class="n">boPb</span><span class="err">#</span><span class="n">T0O8Xd</span><span class="o">&amp;</span><span class="n">Ps5EnSZqDg4Qztvo7IIs</span><span class="w"> </span><span class="mi">9</span><span class="n">vH66AiGSQgCDxk</span><span class="o">&amp;</span>
</code></pre></div>

<h3>一个 Java Protobuf 客户端</h3>
<p>用 Java 写的示例是为了确认 Protobuf 的语言中立性。原始 IDL 文件可用于生成 Java 支持代码，其中涉及嵌套类。但是，为了抑制警告信息，可以进行一些补充。这是修订版，它指定了一个 <code>DataMsg</code> 作为外部类的名称，内部类在该 Protobuf 消息后面自动命名为 <code>DataItem</code>：</p>
<div class="highlight"><pre><span></span><code><span class="nx">syntax</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;proto3&quot;</span><span class="p">;</span>

<span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="p">;</span>

<span class="nx">option</span><span class="w"> </span><span class="nx">java_outer_classname</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;DataMsg&quot;</span><span class="p">;</span>

<span class="nx">message</span><span class="w"> </span><span class="nx">DataItem</span><span class="w"> </span><span class="p">{</span>
<span class="o">...</span>
</code></pre></div>

<p>进行此更改后，<code>protoc</code> 编译与以前相同，只是所期望的输出现在是 Java 而不是 Go：</p>
<div class="highlight"><pre><span></span><code><span class="c">% protoc --java_out=. dataitem.proto</span>
</code></pre></div>

<p>生成的源文件（在名为 <code>main</code> 的子目录中）为 <code>DataMsg.java</code>，长度约为 1,120 行：Java 并不简洁。编译然后运行 Java 代码需要具有 Protobuf 库支持的 JAR 文件。该文件位于 <a href="https://mvnrepository.com/artifact/com.google.protobuf/protobuf-java">Maven 存储库</a>中。</p>
<p>放置好这些片段后，我的测试代码相对较短（并且在 ZIP 文件中以 <code>Main.java</code> 形式提供）：</p>
<div class="highlight"><pre><span></span><code><span class="n">package</span> <span class="n">main</span><span class="p">;</span>
<span class="kn">import</span> <span class="nn">java.io.FileInputStream</span><span class="p">;</span>

<span class="n">public</span> <span class="k">class</span> <span class="nc">Main</span> <span class="p">{</span>
   <span class="n">public</span> <span class="n">static</span> <span class="n">void</span> <span class="n">main</span><span class="p">(</span><span class="n">String</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">String</span> <span class="n">path</span> <span class="o">=</span> <span class="s2">&quot;dataitem.pbuf&quot;</span><span class="p">;</span>  <span class="o">//</span> <span class="kn">from</span> <span class="nn">the</span> <span class="n">Go</span> <span class="n">program</span><span class="s1">&#39;s serialization</span>
      <span class="k">try</span> <span class="p">{</span>
         <span class="n">DataMsg</span><span class="o">.</span><span class="n">DataItem</span> <span class="n">deserial</span> <span class="o">=</span>
           <span class="n">DataMsg</span><span class="o">.</span><span class="n">DataItem</span><span class="o">.</span><span class="n">newBuilder</span><span class="p">()</span><span class="o">.</span><span class="n">mergeFrom</span><span class="p">(</span><span class="n">new</span> <span class="n">FileInputStream</span><span class="p">(</span><span class="n">path</span><span class="p">))</span><span class="o">.</span><span class="n">build</span><span class="p">();</span>

         <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">deserial</span><span class="o">.</span><span class="n">getOddA</span><span class="p">());</span> <span class="o">//</span> <span class="mi">64</span><span class="o">-</span><span class="n">bit</span> <span class="n">odd</span>
         <span class="n">System</span><span class="o">.</span><span class="n">out</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">deserial</span><span class="o">.</span><span class="n">getLong</span><span class="p">());</span> <span class="o">//</span> <span class="mi">32</span><span class="o">-</span><span class="n">character</span> <span class="n">string</span>
      <span class="p">}</span>
      <span class="n">catch</span><span class="p">(</span><span class="ne">Exception</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span> <span class="n">System</span><span class="o">.</span><span class="n">err</span><span class="o">.</span><span class="n">println</span><span class="p">(</span><span class="n">e</span><span class="p">);</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>当然，生产级的测试将更加彻底，但是即使是该初步测试也可以证明 Protobuf 的语言中立性：<code>dataitem.pbuf</code> 文件是 Go 程序对 Go 语言版的 <code>DataItem</code> 进行序列化的结果，并且该文件中的字节被反序列化以产生一个 Java 语言的 <code>DataItem</code> 实例。Java 测试的输出与 Go 测试的输出相同。</p>
<h3>用 numPairs 程序来结束</h3>
<p>让我们以一个示例作为结尾，来突出 Protobuf 效率，但又强调在任何编码技术中都会涉及到的成本。考虑以下 Protobuf IDL 文件：</p>
<div class="highlight"><pre><span></span><code><span class="nx">syntax</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="s">&quot;proto3&quot;</span><span class="p">;</span>
<span class="kn">package</span><span class="w"> </span><span class="nx">main</span><span class="p">;</span>

<span class="nx">message</span><span class="w"> </span><span class="nx">NumPairs</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">repeated</span><span class="w"> </span><span class="nx">NumPair</span><span class="w"> </span><span class="nx">pair</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="nx">message</span><span class="w"> </span><span class="nx">NumPair</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="nx">int32</span><span class="w"> </span><span class="nx">odd</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">  </span><span class="nx">int32</span><span class="w"> </span><span class="nx">even</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p><code>NumPair</code> 消息由两个 <code>int32</code> 值以及每个字段的整数标签组成。<code>NumPairs</code> 消息是嵌入的 <code>NumPair</code> 消息的序列。</p>
<p>Go 语言的 <code>numPairs</code> 程序（如下）创建了 200 万个 <code>NumPair</code> 实例，每个实例都附加到 <code>NumPairs</code> 消息中。该消息可以按常规方式进行序列化和反序列化。</p>
<h4>示例 2、numPairs 程序</h4>
<div class="highlight"><pre><span></span><code><span class="n">package</span> <span class="n">main</span>

<span class="kn">import</span> <span class="p">(</span>
   <span class="s2">&quot;math/rand&quot;</span>
   <span class="s2">&quot;time&quot;</span>
   <span class="s2">&quot;encoding/xml&quot;</span>
   <span class="s2">&quot;encoding/json&quot;</span>
   <span class="s2">&quot;io/ioutil&quot;</span>
   <span class="s2">&quot;github.com/golang/protobuf/proto&quot;</span>
<span class="p">)</span>

<span class="o">//</span> <span class="n">protoc</span><span class="o">-</span><span class="n">generated</span> <span class="n">code</span><span class="p">:</span> <span class="n">start</span>
<span class="n">var</span> <span class="n">_</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">Marshal</span>
<span class="nb">type</span> <span class="n">NumPairs</span> <span class="n">struct</span> <span class="p">{</span>
   <span class="n">Pair</span> <span class="p">[]</span><span class="o">*</span><span class="n">NumPair</span> <span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;bytes,1,rep,name=pair&quot;</span> <span class="n">json</span><span class="p">:</span><span class="s2">&quot;pair,omitempty&quot;</span><span class="err">`</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">NumPairs</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span>         <span class="p">{</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">NumPairs</span><span class="p">{}</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">NumPairs</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">proto</span><span class="o">.</span><span class="n">CompactTextString</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="o">*</span><span class="n">NumPairs</span><span class="p">)</span> <span class="n">ProtoMessage</span><span class="p">()</span>    <span class="p">{}</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">NumPairs</span><span class="p">)</span> <span class="n">GetPair</span><span class="p">()</span> <span class="p">[]</span><span class="o">*</span><span class="n">NumPair</span> <span class="p">{</span>
   <span class="k">if</span> <span class="n">m</span> <span class="o">!=</span> <span class="n">nil</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m</span><span class="o">.</span><span class="n">Pair</span> <span class="p">}</span>
   <span class="k">return</span> <span class="n">nil</span>
<span class="p">}</span>

<span class="nb">type</span> <span class="n">NumPair</span> <span class="n">struct</span> <span class="p">{</span>
   <span class="n">Odd</span>  <span class="n">int32</span> <span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;varint,1,opt,name=odd&quot;</span> <span class="n">json</span><span class="p">:</span><span class="s2">&quot;odd,omitempty&quot;</span><span class="err">`</span>
   <span class="n">Even</span> <span class="n">int32</span> <span class="err">`</span><span class="n">protobuf</span><span class="p">:</span><span class="s2">&quot;varint,2,opt,name=even&quot;</span> <span class="n">json</span><span class="p">:</span><span class="s2">&quot;even,omitempty&quot;</span><span class="err">`</span>
<span class="p">}</span>

<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">NumPair</span><span class="p">)</span> <span class="n">Reset</span><span class="p">()</span>         <span class="p">{</span> <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">NumPair</span><span class="p">{}</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="n">m</span> <span class="o">*</span><span class="n">NumPair</span><span class="p">)</span> <span class="n">String</span><span class="p">()</span> <span class="n">string</span> <span class="p">{</span> <span class="k">return</span> <span class="n">proto</span><span class="o">.</span><span class="n">CompactTextString</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="p">}</span>
<span class="n">func</span> <span class="p">(</span><span class="o">*</span><span class="n">NumPair</span><span class="p">)</span> <span class="n">ProtoMessage</span><span class="p">()</span>    <span class="p">{}</span>
<span class="n">func</span> <span class="n">init</span><span class="p">()</span> <span class="p">{}</span>
<span class="o">//</span> <span class="n">protoc</span><span class="o">-</span><span class="n">generated</span> <span class="n">code</span><span class="p">:</span> <span class="n">finish</span>

<span class="n">var</span> <span class="n">numPairsStruct</span> <span class="n">NumPairs</span>
<span class="n">var</span> <span class="n">numPairs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">numPairsStruct</span>

<span class="n">func</span> <span class="n">encodeAndserialize</span><span class="p">()</span> <span class="p">{</span>
   <span class="o">//</span> <span class="n">XML</span> <span class="n">encoding</span>
   <span class="n">filename</span> <span class="o">:=</span> <span class="s2">&quot;./pairs.xml&quot;</span>
   <span class="nb">bytes</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">xml</span><span class="o">.</span><span class="n">MarshalIndent</span><span class="p">(</span><span class="n">numPairs</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
   <span class="n">ioutil</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="mi">0644</span><span class="p">)</span>

   <span class="o">//</span> <span class="n">JSON</span> <span class="n">encoding</span>
   <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;./pairs.json&quot;</span>
   <span class="nb">bytes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">MarshalIndent</span><span class="p">(</span><span class="n">numPairs</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot; &quot;</span><span class="p">)</span>
   <span class="n">ioutil</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="mi">0644</span><span class="p">)</span>

   <span class="o">//</span> <span class="n">ProtoBuf</span> <span class="n">encoding</span>
   <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;./pairs.pbuf&quot;</span>
   <span class="nb">bytes</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">proto</span><span class="o">.</span><span class="n">Marshal</span><span class="p">(</span><span class="n">numPairs</span><span class="p">)</span>
   <span class="n">ioutil</span><span class="o">.</span><span class="n">WriteFile</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">,</span> <span class="mi">0644</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">const</span> <span class="n">HowMany</span> <span class="o">=</span> <span class="mi">200</span> <span class="o">*</span> <span class="mi">100</span>  <span class="o">*</span> <span class="mi">100</span> <span class="o">//</span> <span class="n">two</span> <span class="n">million</span>

<span class="n">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">rand</span><span class="o">.</span><span class="n">Seed</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())</span>

   <span class="o">//</span> <span class="n">uncomment</span> <span class="n">the</span> <span class="n">modulus</span> <span class="n">operations</span> <span class="n">to</span> <span class="n">get</span> <span class="n">the</span> <span class="n">more</span> <span class="n">efficient</span> <span class="n">version</span>
   <span class="k">for</span> <span class="n">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">HowMany</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span> <span class="p">{</span>
      <span class="n">n1</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Int31</span><span class="p">()</span> <span class="o">//</span> <span class="o">%</span> <span class="mi">2047</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n1</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="n">n1</span><span class="o">++</span> <span class="p">}</span> <span class="o">//</span> <span class="n">ensure</span> <span class="n">it</span><span class="s1">&#39;s odd</span>
      <span class="n">n2</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">Int31</span><span class="p">()</span> <span class="o">//</span> <span class="o">%</span> <span class="mi">2047</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">n2</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="p">{</span> <span class="n">n2</span><span class="o">++</span> <span class="p">}</span> <span class="o">//</span> <span class="n">ensure</span> <span class="n">it</span><span class="s1">&#39;s even</span>

      <span class="nb">next</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="n">NumPair</span> <span class="p">{</span>
                 <span class="n">Odd</span><span class="p">:</span>  <span class="n">n1</span><span class="p">,</span>
                 <span class="n">Even</span><span class="p">:</span> <span class="n">n2</span><span class="p">,</span>
              <span class="p">}</span>
      <span class="n">numPairs</span><span class="o">.</span><span class="n">Pair</span> <span class="o">=</span> <span class="n">append</span><span class="p">(</span><span class="n">numPairs</span><span class="o">.</span><span class="n">Pair</span><span class="p">,</span> <span class="nb">next</span><span class="p">)</span>
   <span class="p">}</span>
   <span class="n">encodeAndserialize</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<p>每个 <code>NumPair</code> 中随机生成的奇数和偶数值的范围在 0 到 20 亿之间变化。就原始数据（而非编码数据）而言，Go 程序中生成的整数总共为 16MB：每个 <code>NumPair</code> 为两个整数，总计为 400 万个整数，每个值的大小为四个字节。</p>
<p>为了进行比较，下表列出了 XML、JSON 和 Protobuf 编码的示例 <code>NumsPairs</code> 消息的 200 万个 <code>NumPair</code> 实例。原始数据也包括在内。由于 <code>numPairs</code> 程序生成随机值，因此样本运行的输出有所不同，但接近表中显示的大小。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>文件</th>
<th>字节大小</th>
<th>Pbuf/其它 比例</th>
</tr>
</thead>
<tbody>
<tr>
<td>无</td>
<td>pairs.raw</td>
<td>16MB</td>
<td>169%</td>
</tr>
<tr>
<td>Protobuf</td>
<td>pairs.pbuf</td>
<td>27MB</td>
<td>—</td>
</tr>
<tr>
<td>JSON</td>
<td>pairs.json</td>
<td>100MB</td>
<td>27%</td>
</tr>
<tr>
<td>XML</td>
<td>pairs.xml</td>
<td>126MB</td>
<td>21%</td>
</tr>
</tbody>
</table>
<p><em>表 2. 16MB 整数的编码开销</em></p>
<p>不出所料，Protobuf 和之后的 XML 和 JSON 差别明显。Protobuf 编码大约是 JSON 的四分之一，是 XML 的五分之一。但是原始数据清楚地表明 Protobuf 也会产生编码开销：序列化的 Protobuf 消息比原始数据大 11MB。包括 Protobuf 在内的任何编码都涉及结构化数据，这不可避免地会增加字节。</p>
<p>序列化的 200 万个 <code>NumPair</code> 实例中的每个实例都包含<strong>四</strong>个整数值：Go 结构中的 <code>Even</code> 和 <code>Odd</code> 字段分别一个，而 Protobuf 编码中的每个字段、每个标签一个。对于原始数据（而不是编码数据），每个实例将达到 16 个字节，样本 <code>NumPairs</code> 消息中有 200 万个实例。但是 Protobuf 标记（如 <code>NumPair</code> 字段中的 <code>int32</code> 值）使用 <code>varint</code> 编码，因此字节长度有所不同。特别是，小的整数值（在这种情况下，包括标签在内）需要不到四个字节进行编码。</p>
<p>如果对 <code>numPairs</code> 程序进行了修改，以使两个 <code>NumPair</code> 字段的值小于 2048，且其编码为一或两个字节，则 Protobuf 编码将从 27MB 下降到 16MB，这正是原始数据的大小。下表总结了样本运行中的新编码大小。</p>
<table>
<thead>
<tr>
<th>编码</th>
<th>文件</th>
<th>字节大小</th>
<th>Pbuf/其它 比例</th>
</tr>
</thead>
<tbody>
<tr>
<td>None</td>
<td>pairs.raw</td>
<td>16MB</td>
<td>100%</td>
</tr>
<tr>
<td>Protobuf</td>
<td>pairs.pbuf</td>
<td>16MB</td>
<td>—</td>
</tr>
<tr>
<td>JSON</td>
<td>pairs.json</td>
<td>77MB</td>
<td>21%</td>
</tr>
<tr>
<td>XML</td>
<td>pairs.xml</td>
<td>103MB</td>
<td>15%</td>
</tr>
</tbody>
</table>
<p><em>表 3. 编码 16MB 的小于 2048 的整数</em></p>
<p>总之，修改后的 <code>numPairs</code> 程序的字段值小于 2048，可减少原始数据中每个四字节整数值的大小。但是 Protobuf 编码仍然需要标签，这些标签会在 Protobuf 消息中添加字节。Protobuf 编码确实会增加消息大小，但是如果要编码相对较小的整数值（无论是字段还是键），则可以通过 <code>varint</code> 因子来减少此开销。</p>
<p>对于包含混合类型的结构化数据（且整数值相对较小）的中等大小的消息，Protobuf 明显优于 XML 和 JSON 等选项。在其他情况下，数据可能不适合 Protobuf 编码。例如，如果两个应用程序需要共享大量文本记录或大整数值，则可以采用压缩而不是编码技术。</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>