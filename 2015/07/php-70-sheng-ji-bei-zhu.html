<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>PHP 7.0 升级备注</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: '' PHP 7.0.0 beta1 发布了，在带来了引人注目的性能提升的同时，也带来了不少语言特性方面的改变。以下由 LCTT 翻译自对官方 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li class="active"><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2015/07/php-70-sheng-ji-bei-zhu.html" rel="bookmark"
           title="Permalink to PHP 7.0 升级备注">PHP 7.0 升级备注</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2015-07-20T07:31:00+02:00">
                Published: Mon 20 July 2015
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ji-zhu">技术</a>.</p>

</footer><!-- /.post-info -->      <p>Author: ''</p>
<p>PHP 7.0.0 beta1 发布了，在带来了引人注目的性能提升的同时，也带来了不少语言特性方面的改变。以下由 LCTT 翻译自对官方的<a href="https://github.com/php/php-src/blob/php-7.0.0beta1/UPGRADING">升级备注</a>，虽然目前还不是正式发布版，不过想必距离正式发布的特性已经差别不大了。（本文会持续追踪更新）</p>
<p><img alt="" src="/data/attachment/album/201507/18/180247oz05zwm8py7mw8zq.png"></p>
<h2>1. 向后不兼容的变化</h2>
<h3>语言变化</h3>
<h4>变量处理的变化</h4>
<ul>
<li>间接变量、属性和方法引用现在以从左到右的语义进行解释。一些例子：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="err">$$</span><span class="n">foo</span><span class="p">[</span><span class="s">&#39;bar&#39;</span><span class="p">][</span><span class="s">&#39;baz&#39;</span><span class="p">]</span><span class="w"> </span><span class="c1">// 解释做 ($$foo)[&#39;bar&#39;][&#39;baz&#39;]   </span>
<span class="err">$</span><span class="n">foo</span><span class="o">-&gt;</span><span class="err">$</span><span class="n">bar</span><span class="p">[</span><span class="s">&#39;baz&#39;</span><span class="p">]</span><span class="w">   </span><span class="c1">// 解释做 ($foo-&gt;$bar)[&#39;baz&#39;]</span>
<span class="err">$</span><span class="n">foo</span><span class="o">-&gt;</span><span class="err">$</span><span class="n">bar</span><span class="p">[</span><span class="s">&#39;baz&#39;</span><span class="p">]()</span><span class="w"> </span><span class="c1">// 解释做 ($foo-&gt;$bar)[&#39;baz&#39;]()</span>
<span class="n">Foo</span><span class="o">::</span><span class="err">$</span><span class="n">bar</span><span class="p">[</span><span class="s">&#39;baz&#39;</span><span class="p">]()</span><span class="w">  </span><span class="c1">// 解释做 (Foo::$bar)[&#39;baz&#39;]()</span>
</code></pre></div>

<p>要恢复以前的行为，需要显式地加大括号：</p>
<div class="highlight"><pre><span></span><code><span class="cp">${</span><span class="err">$</span><span class="n">foo</span><span class="p">[</span><span class="s1">&#39;bar&#39;</span><span class="p">][</span><span class="s1">&#39;baz&#39;</span><span class="p">]</span><span class="cp">}</span>
<span class="nv">$foo</span>-&gt;{<span class="nv">$bar</span>[&#39;baz&#39;]}
<span class="nv">$foo</span>-&gt;{<span class="nv">$bar</span>[&#39;baz&#39;]}()
Foo::{<span class="nv">$bar</span>[&#39;baz&#39;]}()
</code></pre></div>

<ul>
<li>全局关键字现在只接受简单变量。像以前的</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="kr">global</span><span class="w"> </span><span class="err">$$</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="p">;</span>
</code></pre></div>

<p>现在要求如下写法：</p>
<div class="highlight"><pre><span></span><code>global<span class="w"> </span><span class="cp">${</span><span class="err">$</span><span class="n">foo</span><span class="o">-&gt;</span><span class="n">bar</span><span class="cp">}</span>;
</code></pre></div>

<ul>
<li>变量或函数调用的前后加上括号不再有任何影响。例如下列代码，函数调用结果以引用的方式传给一个函数</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="nt">function</span><span class="w"> </span><span class="nt">getArray</span><span class="o">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="err">return</span><span class="w"> </span><span class="cp">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="cp">]</span><span class="p">;</span><span class="w"> </span><span class="p">}</span>

<span class="o">$</span><span class="nt">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">array_pop</span><span class="o">(</span><span class="nt">getArray</span><span class="o">());</span>
<span class="o">//</span><span class="w"> </span><span class="nt">Strict</span><span class="w"> </span><span class="nt">Standards</span><span class="o">:</span><span class="w"> </span><span class="nt">只有变量可以用引用方式传递</span>
<span class="o">$</span><span class="nt">last</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nt">array_pop</span><span class="o">((</span><span class="nt">getArray</span><span class="o">()));</span>
<span class="o">//</span><span class="w"> </span><span class="nt">Strict</span><span class="w"> </span><span class="nt">Standards</span><span class="o">:</span><span class="w"> </span><span class="nt">只有变量可以用引用方式传递</span>
</code></pre></div>

<p>现在无论是否使用括号，都会抛出一个严格标准错误。以前在第二种调用方式下不会有提示。
* 数组元素或对象属性自动安装引用顺序创建，现在的结果顺序将不同。例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[];</span>
<span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;a&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">];</span>
<span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="s2">&quot;b&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
</code></pre></div>

<p>现在结果是 ["a" =&gt; 1, "b" =&gt; 1]，而以前的结果是 ["b" =&gt; 1, "a" =&gt; 1]。</p>
<p>相关的 RFC：</p>
<ul>
<li><a href="https://wiki.php.net/rfc/uniform_variable_syntax">https://wiki.php.net/rfc/uniform_variable_syntax</a></li>
<li><a href="https://wiki.php.net/rfc/abstract_syntax_tree">https://wiki.php.net/rfc/abstract_syntax_tree</a></li>
</ul>
<h4>list() 的变化</h4>
<ul>
<li>list() 不再以反序赋值，例如：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">list</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[],</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">[],</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">[])</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">];</span>
<span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">);</span>
</code></pre></div>

<p>现在结果是 $array == [1, 2, 3] ，而不是 [3, 2, 1]。注意仅赋值<strong>顺序</strong>变化了，而赋值仍然一致（LCTT 译注：即以前的 list()行为是从后面的变量开始逐一赋值，这样对与上述用法就会产生 [3,2,1] 这样的结果了。）。例如，类似如下的常规用法</p>
<div class="highlight"><pre><span></span><code>list($a, $b, $c) = [1, 2, 3];
// $a = 1; $b = 2; $c = 3;
</code></pre></div>

<p>仍然保持当前的行为。
* 不再允许对空的 list() 赋值。如下全是无效的：</p>
<div class="highlight"><pre><span></span><code>list() = $a;
list(,,) = $a;
list($x, list(), $y) = $a;
</code></pre></div>

<ul>
<li>list() 不再支持对字符串的拆分（以前也只在某些情况下支持）。如下代码：</li>
</ul>
<div class="highlight"><pre><span></span><code>$string = &quot;xy&quot;;
list($x, $y) = $string;
</code></pre></div>

<p>现在的结果是： $x == null 和 $y == null （没有提示），而以前的结果是： $x == "x" 和 $y == "y" 。此外， list() 现在总是可以处理实现了 ArrayAccess 的对象，例如：</p>
<div class="highlight"><pre><span></span><code>list($a, $b) = (object) new ArrayObject([0, 1]);
</code></pre></div>

<p>现在的结果是： $a == 0 和 $b == 1。 以前 $a 和 $b 都是 null。</p>
<p>相关 RFC:</p>
<ul>
<li><a href="https://wiki.php.net/rfc/abstract_syntax_tree#changes_to_list">https://wiki.php.net/rfc/abstract_syntax_tree#changes_to_list</a></li>
<li><a href="https://wiki.php.net/rfc/fix_list_behavior_inconsistency">https://wiki.php.net/rfc/fix_list_behavior_inconsistency</a></li>
</ul>
<h4>foreach 的变化</h4>
<ul>
<li>foreach() 迭代不再影响数组内部指针，数组指针可通过 current()/next() 等系列的函数访问。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">current</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<p>现在将指向值 int(0) 三次。以前的输出是 int(1)、int(2) 和 bool(false)。
* 在对数组按值迭代时，foreach 总是在对数组副本进行操作，在迭代中任何对数组的操作都不会影响到迭代行为。例如：</p>
<div class="highlight"><pre><span></span><code><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">];</span>
<span class="o">$</span><span class="n">ref</span><span class="w"> </span><span class="o">=&amp;</span><span class="w"> </span><span class="o">$</span><span class="n">array</span><span class="p">;</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">Necessary</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">trigger</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">old</span><span class="w"> </span><span class="n">behavior</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="n">unset</span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
<span class="p">}</span>
</code></pre></div>

<p>现在将打印出全部三个元素 (0 1 2)，而以前第二个元素 1 会跳过 (0 2)。
* 在对数组按引用迭代时，对数组的修改将继续会影响到迭代。不过，现在 PHP 在使用数字作为键时可以更好的维护数组内的位置。例如，在按引用迭代过程中添加数组元素：</p>
<div class="highlight"><pre><span></span><code><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="n">foreach</span><span class="w"> </span><span class="p">(</span><span class="o">$</span><span class="n">array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="o">&amp;$</span><span class="n">val</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">val</span><span class="p">);</span>
<span class="w">    </span><span class="o">$</span><span class="n">array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>现在迭代会正确的添加了元素。如上代码输出是 "int(0) int(1)"，而以前只是 "int(0)"。
* 对普通（不可遍历的）对象按值或按引用迭代的行为类似于对数组进行按引用迭代。这符合以前的行为，除了如上一点所述的更精确的位置管理的改进。
* 对可遍历对象的迭代行为保持不变。</p>
<p>相关 RFC: <a href="https://wiki.php.net/rfc/php7_foreach">https://wiki.php.net/rfc/php7_foreach</a></p>
<h4>参数处理的变化</h4>
<ul>
<li>不能定义两个同名的函数参数。例如，下面的方法将会触发编译时错误：</li>
</ul>
<div class="highlight"><pre><span></span><code>public function foo($a, $b, $unused, $unused) {
    // ...
}
</code></pre></div>

<p>如上的代码应该修改使用不同的参数名，如：</p>
<div class="highlight"><pre><span></span><code>public function foo($a, $b, $unused1, $unused2) {
    // ...
}
</code></pre></div>

<ul>
<li>func_get_arg() 和 func_get_args() 函数不再返回传递给参数的原始值，而是返回其当前值（也许会被修改）。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="o">$</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">$</span><span class="n">x</span><span class="o">++</span><span class="p">;</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">func_get_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
</code></pre></div>

<p>将会打印 "2" 而不是 "1"。代码应该改成仅在调用 func_get_arg(s) 后进行修改操作。</p>
<div class="highlight"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="o">$</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">func_get_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="w">    </span><span class="o">$</span><span class="n">x</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>

<p>或者应该避免修改参数：</p>
<div class="highlight"><pre><span></span><code><span class="n">function</span><span class="w"> </span><span class="n">foo</span><span class="p">(</span><span class="o">$</span><span class="n">x</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="o">$</span><span class="n">newX</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">$</span><span class="n">x</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">var_dump</span><span class="p">(</span><span class="n">func_get_arg</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div>

<ul>
<li>类似的，异常回溯也不再显示传递给函数的原始值，而是修改后的值。例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>function foo($x) {
    $x = 42;
    throw new Exception;
}
foo(&quot;string&quot;);
</code></pre></div>

<p>现在堆栈跟踪的结果是：</p>
<div class="highlight"><pre><span></span><code>Stack trace:
#0 file.php(4): foo(42)
#1 {main}
</code></pre></div>

<p>而以前是：</p>
<div class="highlight"><pre><span></span><code>Stack trace:
#0 file.php(4): foo(&#39;string&#39;)
#1 {main}
</code></pre></div>

<p>这并不会影响到你的代码的运行时行为，值得注意的是在调试时会有所不同。</p>
<p>同样的限制也会影响到 debug_backtrace() 及其它检查函数参数的函数。</p>
<p>相关 RFC: <a href="https://wiki.php.net/phpng">https://wiki.php.net/phpng</a></p>
<h4>整数处理的变化</h4>
<ul>
<li>无效的八进制表示（包含大于7的数字）现在会产生编译错误。例如，下列代码不再有效：</li>
</ul>
<div class="highlight"><pre><span></span><code>$i = 0781; // 8 不是一个有效的八进制数字！
</code></pre></div>

<p>以前，无效的数字（以及无效数字后的任何数字）会简单的忽略。以前如上 $i 的值是 7，因为后两位数字会被悄悄丢弃。
* 二进制以负数镜像位移现在会抛出一个算术错误：</p>
<div class="highlight"><pre><span></span><code><span class="n">var_dump</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="o">//</span><span class="w"> </span><span class="n">ArithmeticError</span><span class="p">:</span><span class="w"> </span><span class="err">以负数进行位移</span>
</code></pre></div>

<ul>
<li>向左位移的位数超出了整型宽度时，结果总是 0。</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">var_dump</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&lt;&lt;</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
</code></pre></div>

<p>以前上述代码的结果依赖于所用的 CPU 架构。例如，在 x86（包括 x86-64） 上结果是 int(1)，因为其位移操作数在范围内。
* 类似的，向右位移的位数超出了整型宽度时，其结果总是 0 或 -1 （依赖于符号）：</p>
<div class="highlight"><pre><span></span><code><span class="n">var_dump</span><span class="p">(</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
<span class="n">var_dump</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="w"> </span><span class="o">&gt;&gt;</span><span class="w"> </span><span class="mi">64</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>

<p>相关 RFC: <a href="https://wiki.php.net/rfc/integer_semantics">https://wiki.php.net/rfc/integer_semantics</a></p>
<h4>字符串处理的变化</h4>
<ul>
<li>包含十六进制数字的字符串不会再被当做数字，也不会被特殊处理。参见例子中的新行为：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="n">var_dump</span><span class="p">(</span><span class="s2">&quot;0x123&quot;</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s2">&quot;291&quot;</span><span class="p">);</span><span class="w">     </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="p">(</span><span class="bp">false</span><span class="p">)</span><span class="w">     </span><span class="p">(</span><span class="err">以前是</span><span class="w"> </span><span class="bp">true</span><span class="p">)</span>
<span class="n">var_dump</span><span class="p">(</span><span class="n">is_numeric</span><span class="p">(</span><span class="s2">&quot;0x123&quot;</span><span class="p">));</span><span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">bool</span><span class="p">(</span><span class="bp">false</span><span class="p">)</span><span class="w">     </span><span class="p">(</span><span class="err">以前是</span><span class="w"> </span><span class="bp">true</span><span class="p">)</span>
<span class="n">var_dump</span><span class="p">(</span><span class="s2">&quot;0xe&quot;</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="s2">&quot;0x1&quot;</span><span class="p">);</span><span class="w">        </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="w">          </span><span class="p">(</span><span class="err">以前是</span><span class="w"> </span><span class="mi">16</span><span class="p">)</span>

<span class="n">var_dump</span><span class="p">(</span><span class="n">substr</span><span class="p">(</span><span class="s2">&quot;foo&quot;</span><span class="p">,</span><span class="w"> </span><span class="s2">&quot;0x1&quot;</span><span class="p">));</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">string</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="w"> </span><span class="s2">&quot;foo&quot;</span><span class="w"> </span><span class="p">(</span><span class="err">以前是</span><span class="w"> </span><span class="s2">&quot;oo&quot;</span><span class="p">)</span>
<span class="o">//</span><span class="w"> </span><span class="err">注意：遇到了一个非正常格式的数字</span>
</code></pre></div>

<p>filter_var() 可以用来检查一个字符串是否包含了十六进制数字，或这个字符串是否能转换为整数：</p>
<div class="highlight"><pre><span></span><code><span class="o">$</span><span class="nb">str</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s2">&quot;0xffff&quot;</span><span class="p">;</span>
<span class="o">$</span><span class="nb nb-Type">int</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">filter_var</span><span class="p">(</span><span class="o">$</span><span class="nb">str</span><span class="p">,</span><span class="w"> </span><span class="n">FILTER_VALIDATE_INT</span><span class="p">,</span><span class="w"> </span><span class="n">FILTER_FLAG_ALLOW_HEX</span><span class="p">);</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="bp">false</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="o">$</span><span class="nb nb-Type">int</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">throw</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">Exception</span><span class="p">(</span><span class="s2">&quot;Invalid integer!&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="nb nb-Type">int</span><span class="p">);</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="nb nb-Type">int</span><span class="p">(</span><span class="mi">65535</span><span class="p">)</span>
</code></pre></div>

<ul>
<li>由于给双引号字符串和 HERE 文档增加了 Unicode 码点转义格式（Unicode Codepoint Escape Syntax）， 所以带有无效序列的 "\u{" 现在会造成错误：</li>
</ul>
<div class="highlight"><pre><span></span><code>$str = &quot;\u{xyz}&quot;; // 致命错误：无效的 UTF-8 码点转义序列
</code></pre></div>

<p>要避免这种情况，需要转义开头的反斜杠：</p>
<div class="highlight"><pre><span></span><code>$str = &quot;\\u{xyz}&quot;; // 正确
</code></pre></div>

<p>不过，不跟随 { 的 "\u" 不受影响。如下代码不会生成错误，和前面的一样工作：</p>
<div class="highlight"><pre><span></span><code>$str = &quot;\u202e&quot;; // 正确
</code></pre></div>

<p>相关 RFC:</p>
<ul>
<li><a href="https://wiki.php.net/rfc/remove_hex_support_in_numeric_strings">https://wiki.php.net/rfc/remove_hex_support_in_numeric_strings</a></li>
<li><a href="https://wiki.php.net/rfc/unicode_escape">https://wiki.php.net/rfc/unicode_escape</a></li>
</ul>
<h4>错误处理的变化</h4>
<ul>
<li>现在有两个异常类： Exception 和 Error 。这两个类都实现了一个新接口： Throwable 。在异常处理代码中的类型指示也许需要修改来处理这种情况。</li>
<li>一些致命错误和可恢复的致命错误现在改为抛出一个 Error 。由于 Error 是一个独立于 Exception 的类，这些异常不会被已有的 try/catch 块捕获。</li>
</ul>
<p>可恢复的致命错误被转换为一个异常，所以它们不能在错误处理里面悄悄的忽略。部分情况下，类型指示失败不再能忽略。
* 解析错误现在会生成一个 Error 扩展的 ParseError 。除了以前的基于返回值 / error<em>get</em>last() 的处理，对某些可能无效的代码的 eval() 的错误处理应该改为捕获 ParseError 。
* 内部类的构造函数在失败时总是会抛出一个异常。以前一些构造函数会返回 NULL 或一个不可用的对象。
* 一些 E_STRICT 提示的错误级别改变了。</p>
<p>相关 RFC:</p>
<ul>
<li><a href="https://wiki.php.net/rfc/engine_exceptions_for_php7">https://wiki.php.net/rfc/engine_exceptions_for_php7</a></li>
<li><a href="https://wiki.php.net/rfc/throwable-interface">https://wiki.php.net/rfc/throwable-interface</a></li>
<li><a href="https://wiki.php.net/rfc/internal_constructor_behaviour">https://wiki.php.net/rfc/internal_constructor_behaviour</a></li>
<li><a href="https://wiki.php.net/rfc/reclassify_e_strict">https://wiki.php.net/rfc/reclassify_e_strict</a></li>
</ul>
<h4>其它的语言变化</h4>
<ul>
<li>静态调用一个不兼容的 $this 上下文的非静态调用的做法不再支持。这种情况下，$this 是没有定义的，但是对它的调用是允许的，并带有一个废弃提示。例子：</li>
</ul>
<div class="highlight"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">test</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">var_dump</span><span class="p">(</span><span class="o">$</span><span class="n">this</span><span class="p">);</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="o">//</span><span class="w"> </span><span class="err">注意：没有从类</span><span class="w"> </span><span class="n">A</span><span class="w"> </span><span class="err">进行扩展</span>
<span class="k">class</span><span class="w"> </span><span class="n">B</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">public</span><span class="w"> </span><span class="n">function</span><span class="w"> </span><span class="n">callNonStaticMethodOfA</span><span class="p">()</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="n">A</span><span class="p">::</span><span class="n">test</span><span class="p">();</span><span class="w"> </span><span class="p">}</span>
<span class="p">}</span>

<span class="p">(</span><span class="n">new</span><span class="w"> </span><span class="n">B</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">callNonStaticMethodOfA</span><span class="p">();</span>

<span class="o">//</span><span class="w"> </span><span class="err">废弃：非静态方法</span><span class="w"> </span><span class="n">A</span><span class="p">::</span><span class="n">test</span><span class="p">()</span><span class="w"> </span><span class="err">不应该被静态调用</span>
<span class="o">//</span><span class="w"> </span><span class="err">提示：未定义的变量</span><span class="w"> </span><span class="o">$</span><span class="n">this</span>
<span class="n">NULL</span>
</code></pre></div>

<p>注意，这仅出现在来自不兼容上下文的调用上。如果类 B 扩展自类 A ，调用会被允许，没有任何提示。
* 不能使用下列类名、接口名和特殊名（大小写敏感）：</p>
<div class="highlight"><pre><span></span><code>bool
int
float
string
null
false
true
</code></pre></div>

<p>这用于 class/interface/trait 声明、 class_alias() 和 use 语句中。</p>
<p>此外，下列类名、接口名和特殊名保留做将来使用，但是使用时尚不会抛出错误：</p>
<div class="highlight"><pre><span></span><code>resource
object
mixed
numeric
</code></pre></div>

<ul>
<li>yield 语句结构当用在一个表达式上下文时，不再要求括号。它现在是一个优先级在 “print” 和 “=&gt;” 之间的右结合操作符。在某些情况下这会导致不同的行为，例如：</li>
</ul>
<div class="highlight"><pre><span></span><code>echo yield -1;
// 以前被解释如下
echo (yield) - 1;
// 现在被解释如下
echo yield (-1);

yield $foo or die;
// 以前被解释如下
yield ($foo or die);
// 现在被解释如下
(yield $foo) or die;
</code></pre></div>

<p>这种情况可以通过增加括号来解决。
* 移除了 ASP (&lt;%) 和 script (<script language=php>) 标签。</p>
<p>RFC: <a href="https://wiki.php.net/rfc/remove_alternative_php_tags">https://wiki.php.net/rfc/remove_alternative_php_tags</a>
* 不支持以引用的方式对 new 的结果赋值。
* 不支持对一个来自非兼容的 $this 上下文的非静态方法的域内调用。细节参见： <a href="https://wiki.php.net/rfc/incompat_ctx">https://wiki.php.net/rfc/incompat_ctx</a> 。
* 不支持 ini 文件中的 # 风格的备注。使用 ; 风格的备注替代。
* $HTTP_RAW_POST_DATA 不再可用，使用 php://input 流替代。</p>
<h3>标准库的变化</h3>
<ul>
<li>call_user_method() 和 call_user_method_array() 不再存在。</li>
<li>在一个输出缓冲区被创建在输出缓冲处理器里时， ob_start() 不再发出 E_ERROR，而是 E_RECOVERABLE_ERROR。</li>
<li>改进的 zend_qsort （使用 hybrid 排序算法）性能更好，并改名为 zend_sort。</li>
<li>增加静态排序算法 zend_insert_sort。</li>
<li>移除 fpm-fcgi 的 dl() 函数。</li>
<li>setcookie() 如果 cookie 名为空会触发一个 WARNING ，而不是发出一个空的 set-cookie 头。</li>
</ul>
<h3>其它</h3>
<ul>
<li>
<p>Curl:</p>
<ul>
<li>去除对禁用 CURLOPT_SAFE_UPLOAD 选项的支持。所有的 curl 文件上载必须使用 curl_file / CURLFile API。</li>
<li>
<p>Date:</p>
</li>
<li>
<p>从 mktime() 和 gmmktime() 中移除 $is_dst 参数</p>
</li>
<li>
<p>DBA</p>
</li>
<li>
<p>如果键也没有出现在 inifile 处理器中，dba_delete() 现在会返回 false。</p>
</li>
<li>
<p>GMP</p>
</li>
<li>
<p>现在要求 libgmp 版本 4.2 或更新。</p>
</li>
<li>gmp_setbit() 和 gmp_clrbit() 对于负指标返回 FALSE，和其它的 GMP 函数一致。</li>
<li>
<p>Intl:</p>
</li>
<li>
<p>移除废弃的别名 datefmt_set_timezone_id() 和 IntlDateFormatter::setTimeZoneID()。替代使用 datefmt_set_timezone() 和 IntlDateFormatter::setTimeZone()。</p>
</li>
<li>
<p>libxml:</p>
</li>
<li>
<p>增加 LIBXML_BIGLINES 解析器选项。从 libxml 2.9.0 开始可用，并增加了在错误报告中行号大于 16 位的支持。</p>
</li>
<li>
<p>Mcrypt</p>
</li>
<li>
<p>移除等同于 mcrypt_generic_deinit() 的废弃别名 mcrypt_generic_end()。</p>
</li>
<li>移除废弃的 mcrypt_ecb()、 mcrypt_cbc()、 mcrypt_cfb() 和 mcrypt_ofb() 函数，它们等同于使用 MCRYPT_MODE_* 标志的 mcrypt_encrypt() 和 mcrypt_decrypt() 。</li>
<li>
<p>Session</p>
</li>
<li>
<p>session_start() 以数组方式接受所有的 INI 设置。例如， ['cache_limiter'=&gt;'private'] 会设置 session.cache_limiter=private 。也支持 'read_and_close' 以在读取数据后立即关闭会话数据。</p>
</li>
<li>会话保存处理器接受使用 validate_sid() 和 update_timestamp() 来校验会话 ID 是否存在、更新会话时间戳。对旧式的用户定义的会话保存处理器继续兼容。</li>
<li>增加了 SessionUpdateTimestampHandlerInterface 。 validateSid()、 updateTimestamp() 定义在接口里面。</li>
<li>session.lazy_write(默认是 On) 的 INI 设置支持仅在会话数据更新时写入。</li>
<li>
<p>Opcache</p>
</li>
<li>
<p>移除 opcache.load_comments 配置语句。现在文件内备注载入无成本，并且总是启用的。</p>
</li>
<li>
<p>OpenSSL:</p>
</li>
<li>
<p>移除 "rsa_key_size" SSL 上下文选项，按给出的协商的加密算法自动设置适当的大小。</p>
</li>
<li>移除 "CN_match" 和 "SNI_server_name" SSL 上下文选项。使用自动侦测或 "peer_name" 选项替代。</li>
<li>
<p>PCRE:</p>
</li>
<li>
<p>移除对 /e (PREG_REPLACE_EVAL) 修饰符的支持，使用 preg_replace_callback() 替代。</p>
</li>
<li>
<p>PDO_pgsql:</p>
</li>
<li>
<p>移除 PGSQL_ATTR_DISABLE_NATIVE_PREPARED_STATEMENT 属性，等同于 ATTR_EMULATE_PREPARES。</p>
</li>
<li>
<p>Standard:</p>
</li>
<li>
<p>移除 setlocale() 中的字符串类目支持。使用 LC_* 常量替代。 instead.</p>
</li>
<li>移除 set_magic_quotes_runtime() 及其别名 magic_quotes_runtime()。</li>
<li>
<p>JSON:</p>
</li>
<li>
<p>拒绝 json_decode 中的 RFC 7159 不兼容数字格式 - 顶层 (07, 0xff, .1, -.1) 和所有层的 ([1.], [1.e1])</p>
</li>
<li>用一个参数调用 json_decode 等价于用空的 PHP 字符串或值调用，转换为空字符串（NULL, FALSE）的结果是 JSON 格式错误。</li>
<li>
<p>Stream:</p>
</li>
<li>
<p>移除 set_socket_blocking() ，等同于其别名 stream_set_blocking()。</p>
</li>
<li>
<p>XSL:</p>
</li>
<li>
<p>移除 xsl.security_prefs ini 选项，使用 XsltProcessor::setSecurityPrefs() 替代。</p>
</li>
</ul>
</li>
</ul>
<h2>2. 新功能</h2>
<ul>
<li>
<p>Core</p>
<ul>
<li>增加了组式 use 声明。 (RFC: <a href="https://wiki.php.net/rfc/group_use_declarations">https://wiki.php.net/rfc/group_use_declarations</a>)</li>
<li>增加了 null 合并操作符 (??)。 (RFC: <a href="https://wiki.php.net/rfc/isset_ternary">https://wiki.php.net/rfc/isset_ternary</a>)</li>
<li>在 64 位架构上支持长度 &gt;= 2<sup> 31</sup> 字节的字符串。</li>
<li>增加了 Closure::call() 方法（仅工作在用户侧的类）。</li>
<li>在双引号字符串和 here 文档中增加了 \u{xxxxxx} Unicode 码点转义格式。</li>
<li>define() 现在支持数组作为常量值，修复了一个当 define() 还不支持数组常量值时的疏忽。</li>
<li>增加了比较操作符 (&lt;=&gt;)，即太空船操作符。 (RFC: <a href="https://wiki.php.net/rfc/combined-comparison-operator">https://wiki.php.net/rfc/combined-comparison-operator</a>)</li>
<li>为委托生成器添加了类似协程的 yield from 操作符。 (RFC: <a href="https://wiki.php.net/rfc/generator-delegation">https://wiki.php.net/rfc/generator-delegation</a>)</li>
<li>保留的关键字现在可以用在几种新的上下文中。 (RFC: <a href="https://wiki.php.net/rfc/context_sensitive_lexer">https://wiki.php.net/rfc/context_sensitive_lexer</a>)</li>
<li>增加了标量类型的声明支持，并可以使用 declare(strict_types=1) 的声明严格模式。 (RFC: <a href="https://wiki.php.net/rfc/scalar_type_hints_v5">https://wiki.php.net/rfc/scalar_type_hints_v5</a>)</li>
<li>增加了对加密级安全的用户侧的随机数发生器的支持。 (RFC: <a href="https://wiki.php.net/rfc/easy_userland_csprng">https://wiki.php.net/rfc/easy_userland_csprng</a>)</li>
<li>
<p>Opcache</p>
</li>
<li>
<p>增加了基于文件的二级 opcode 缓存（实验性——默认禁用）。要启用它，PHP 需要使用 --enable-opcache-file 配置和构建，然后 opcache.file_cache=<DIR> 配置指令就可以设置在 php.ini 中。二级缓存也许可以提升服务器重启或 SHM 重置时的性能。此外，也可以设置 opcache.file_cache_only=1 来使用文件缓存而根本不用 SHM（也许对于共享主机有用）；设置 opcache.file_cache_consistency_checks=0 来禁用文件缓存一致性检查，以加速载入过程，有安全风险。</p>
</li>
<li>
<p>OpenSSL</p>
</li>
<li>
<p>当用 OpenSSL 1.0.2 及更新构建时，增加了 "alpn_protocols" SSL 上下文选项来允许加密的客户端/服务器流使用 ALPN TLS 扩展去协商替代的协议。协商后的协议信息可以通过 stream_get_meta_data() 输出访问。</p>
</li>
<li>
<p>Reflection</p>
</li>
<li>
<p>增加了一个 ReflectionGenerator 类（yield from Traces，当前文件/行等等）。</p>
</li>
<li>增加了一个 ReflectionType 类来更好的支持新的返回类型和标量类型声明功能。新的 ReflectionParameter::getType() 和 ReflectionFunctionAbstract::getReturnType() 方法都返回一个 ReflectionType 实例。</li>
<li>
<p>Stream</p>
</li>
<li>
<p>添加了新的仅用于 Windows 的流上下文选项以允许阻塞管道读取。要启用该功能，当创建流上下文时，传递 array("pipe" =&gt; array("blocking" =&gt; true)) 。要注意的是，该选项会导致管道缓冲区的死锁，然而它在几个命令行场景中有用。</p>
</li>
</ul>
</li>
</ul>
<h2>3. SAPI 模块的变化</h2>
<ul>
<li>FPM<ul>
<li>修复错误 #65933 （不能设置超过1024字节的配置行）。</li>
<li>Listen = port 现在监听在所有地址上（IPv6 和 IPv4 映射的）。</li>
</ul>
</li>
</ul>
<h2>4. 废弃的功能</h2>
<ul>
<li>
<p>Core</p>
<ul>
<li>废弃了 PHP 4 风格的构建函数（即构建函数名必须与类名相同）。</li>
<li>废弃了对非静态方法的静态调用。</li>
<li>
<p>OpenSSL</p>
</li>
<li>
<p>废弃了 "capture_session_meta" SSL 上下文选项。 在流资源上活动的加密相关的元数据可以通过 stream_get_meta_data() 的返回值访问。</p>
</li>
</ul>
</li>
</ul>
<h2>5. 函数的变化</h2>
<ul>
<li>parse_ini_file():</li>
<li>
<p>parse_ini_string():</p>
<ul>
<li>添加了扫描模式 INI<em>SCANNER</em>TYPED 来得到 yield 类型的 .ini 值。</li>
<li>
<p>unserialize():</p>
</li>
<li>
<p>给 unserialize 函数添加了第二个参数 (RFC: <a href="https://wiki.php.net/rfc/secure_unserialize">https://wiki.php.net/rfc/secure_unserialize</a>) 来指定可接受的类： unserialize($foo, ["allowed_classes" =&gt; ["MyClass", "MyClass2"]]);</p>
</li>
<li>
<p>proc_open():</p>
</li>
<li>
<p>可以被 proc_open() 使用的最大管道数以前被硬编码地限制为 16。现在去除了这个限制，只受限于 PHP 的可用内存大小。</p>
</li>
<li>新添加的仅用于 Windows 的配置选项 "blocking_pipes" 可以用于强制阻塞对子进程管道的读取。这可以用于几种命令行应用场景，但是它会导致死锁。此外，这与新的流的管道上下文选项相关。</li>
<li>
<p>array_column():</p>
</li>
<li>
<p>该函数现在支持把对象数组当做二维数组。只有公开属性会被处理，对象里面使用 __get() 的动态属性必须也实现 __isset() 才行。</p>
</li>
<li>
<p>stream_context_create()</p>
</li>
<li>
<p>现在可以接受一个仅 Windows 可用的配置 array("pipe" =&gt; array("blocking" =&gt; <boolean>)) 来强制阻塞管道读取。该选项应该小心使用，该平台有可能导致管道缓冲区的死锁。</p>
</li>
</ul>
</li>
</ul>
<h2>6. 新函数</h2>
<ul>
<li>
<p>GMP</p>
<ul>
<li>添加了 gmp_random_seed()。</li>
<li>
<p>PCRE:</p>
</li>
<li>
<p>添加了 preg_replace_callback_array 函数。 (RFC: <a href="https://wiki.php.net/rfc/preg_replace_callback_array">https://wiki.php.net/rfc/preg_replace_callback_array</a>)</p>
</li>
<li>Standard . 添加了整数除法 intdiv() 函数。 . 添加了重置错误状态的 error_clear_last() 函数。</li>
<li>Zlib: . 添加了 deflate_init()、 deflate_add()、 inflate_init()、 inflate_add() 函数来运行递增和流的压缩/解压。</li>
</ul>
</li>
</ul>
<h2>7. 新的类和接口</h2>
<p>（暂无）</p>
<h2>8. 移除的扩展和 SAPI</h2>
<ul>
<li>sapi/aolserver</li>
<li>sapi/apache</li>
<li>sapi/apache_hooks</li>
<li>sapi/apache2filter</li>
<li>sapi/caudium</li>
<li>sapi/continuity</li>
<li>sapi/isapi</li>
<li>sapi/milter</li>
<li>sapi/nsapi</li>
<li>sapi/phttpd</li>
<li>sapi/pi3web</li>
<li>sapi/roxen</li>
<li>sapi/thttpd</li>
<li>sapi/tux</li>
<li>sapi/webjames</li>
<li>ext/mssql</li>
<li>ext/mysql</li>
<li>ext/sybase_ct</li>
<li>ext/ereg</li>
</ul>
<p>更多细节参见：</p>
<ul>
<li><a href="https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts">https://wiki.php.net/rfc/removal_of_dead_sapis_and_exts</a></li>
<li><a href="https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7">https://wiki.php.net/rfc/remove_deprecated_functionality_in_php7</a></li>
</ul>
<p>注意：NSAPI 没有在 RFC 中投票，不过它会在以后移除。这就是说，它相关的 SDK 今后不可用。</p>
<h2>9. 扩展的其它变化</h2>
<ul>
<li>Mhash<ul>
<li>Mhash 今后不是一个扩展了，使用 function_exists("mhash") 来检查器是否可用。</li>
</ul>
</li>
</ul>
<h2>10. 新的全局常量</h2>
<ul>
<li>Core . 添加 PHP_INT_MIN</li>
<li>
<p>Zlib</p>
<ul>
<li>添加的这些常量用于控制新的增量deflate_add() 和 inflate_add() 函数的刷新行为：</li>
<li>ZLIB_NO_FLUSH</li>
<li>ZLIB_PARTIAL_FLUSH</li>
<li>ZLIB_SYNC_FLUSH</li>
<li>ZLIB_FULL_FLUSH</li>
<li>ZLIB_BLOCK</li>
<li>ZLIB_FINISH</li>
<li>
<p>GD</p>
</li>
<li>
<p>移除了 T1Lib 支持，这样由于对 T1Lib 的可选依赖，如下将来不可用：函数：</p>
</li>
<li>
<p>imagepsbbox()</p>
</li>
<li>imagepsencodefont()</li>
<li>imagepsextendedfont()</li>
<li>imagepsfreefont()</li>
<li>imagepsloadfont()</li>
<li>imagepsslantfont()</li>
<li>
<p>imagepstext()资源：</p>
</li>
<li>
<p>'gd PS font'</p>
</li>
<li>'gd PS encoding'</li>
</ul>
</li>
</ul>
<h2>11. INI 文件处理的变化</h2>
<ul>
<li>Core<ul>
<li>移除了 asp_tags ini 指令。如果启用它会导致致命错误。</li>
<li>移除了 always_populate_raw_post_data ini 指令。</li>
</ul>
</li>
</ul>
<h2>12. Windows 支持</h2>
<ul>
<li>
<p>Core</p>
<ul>
<li>在 64 位系统上支持原生的 64 位整数。</li>
<li>在 64 位系统上支持大文件。</li>
<li>支持 getrusage()。</li>
<li>
<p>ftp</p>
</li>
<li>
<p>所带的 ftp 扩展总是共享库的。</p>
</li>
<li>对于 SSL 支持，取消了对 openssl 扩展的依赖，取而代之仅依赖 openssl 库。如果在编译时需要，会自动启用 ftp_ssl_connect()。</li>
<li>
<p>odbc</p>
</li>
<li>
<p>所带的 odbc 扩展总是共享库的。</p>
</li>
</ul>
</li>
</ul>
<h2>13. 其它变化</h2>
<ul>
<li>Core<ul>
<li>NaN 和 Infinity 转换为整数时总是 0，而不是未定义和平台相关的。</li>
<li>对非对象调用方法会触发一个可捕获错误，而不是致命错误；参见： <a href="https://wiki.php.net/rfc/catchable-call-to-member-of-non-object">https://wiki.php.net/rfc/catchable-call-to-member-of-non-object</a></li>
<li>zend_parse_parameters、类型提示和转换，现在总是用 "integer" 和 "float"，而不是 "long" 和 "double"。</li>
<li>如果 ignore_user_abort 设置为 true ，对应中断的连接，输出缓存会继续工作。</li>
</ul>
</li>
</ul>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>