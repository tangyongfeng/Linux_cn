<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>Btrfs 详解：快照</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Andreas Hartmann 这篇文章会探讨什么是 Btrfs 快照，它们如何工作的，你在日常生活中进行快照的好处。这篇文章是《Btrfs 详解》系列文章中 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li class="active"><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2023/10/btrfs-xiang-jie-kuai-zhao.html" rel="bookmark"
           title="Permalink to Btrfs 详解：快照">Btrfs 详解：快照</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2023-10-16T09:24:00+02:00">
                Published: Mon 16 October 2023
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ji-zhu">技术</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Andreas Hartmann</p>
<p><img alt="" src="/data/attachment/album/202310/16/092244yog42vb0l3v5h33h.jpg"></p>
<p>这篇文章会探讨什么是 Btrfs 快照，它们如何工作的，你在日常生活中进行快照的好处。这篇文章是《Btrfs 详解》系列文章中的一篇。从 Fedora Linux 33 开始，Btrfs 就是 Fedora Workstation 和 Fedora Silverblue 的默认文件系统。</p>
<p>如果你错过了，这里是本系列的上一篇文章：<a href="/article-16250-1.html">Btrfs 详解：子卷</a></p>
<h3>简介</h3>
<p>想象一下，你长时间处理一个文件，反复添加和撤销修改。然后，在某个时刻你意识到：两小时前你撤销的部分修改，现在会非常有用。而昨天在你销毁那个设计之前，你也已经修改了这个特殊的部分。当然，由于你会定期保存文件，所以旧的改动会丢失。很多人可能都遇到过这样的情况。如果能恢复旧版本的文件，而无需定期手动复制，岂不美哉？</p>
<p>这是一个 Btrfs 快照可以帮助你的特别场景。当你使用正确的话，快照同时也为你的电脑提供了很好的备份方案。</p>
<p>下面你会找到一些关于快照的例子。如果你想跟着操作，你必须拥有访问某些 Btrfs 文件系统的权限和 root 权限。你可以通过下面命令来验证一个目录的文件系统。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>findmnt<span class="w"> </span>-no<span class="w"> </span>FSTYPE<span class="w"> </span>/home
btrfs
</code></pre></div>

<p>这个命令会输出你 <code>/home/</code> 目录的文件系统名称。如果它是 <code>btrfs</code>，那就可以了。让我们创建一个新的目录去做实验：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>mkdir<span class="w"> </span>~/btrfs-snapshot-test
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>~/btrfs-snapshot-test
</code></pre></div>

<p>在下面的文本中，你会看到很多像上面显示的那样的命令输出框。请在阅读/比较命令输出时请记住，<strong>框中的内容在行末会被换行</strong>。这使得识别跨多行的长行变得困难，降低了可读性。如果有疑问，试着调整浏览器窗口的大小，看看文本的变化！</p>
<h3>Btrfs 快照</h3>
<p>让我们从一个基本的问题开始：什么是 Btrfs 快照？如果你在文档 <sup class="footnote-ref"> <a href="#fn1" id="fnref1">  [1] </a></sup> 和维基 <sup class="footnote-ref"> <a href="#fn2" id="fnref2">  [2] </a></sup> 中查找，你不会立刻找到这个问题的答案。事实上，从“功能”一节里是找不到的。如果你搜索一下，你会发现快照和 Btrfs 子卷一起被大量地提及 <sup class="footnote-ref"> <a href="#fn3" id="fnref3">  [3] </a></sup>。所以现在做什么呢？</p>
<p>还记得快照在系列前面的文章里两次被提到吗？是这样说的：</p>
<blockquote>
<p>CoW 的优势在哪里？简单的说：文件被修改和编辑的历史被保存了下来。Btrfs 保存文件旧版本的引用（inode）可以轻易地被访问。这个引用就是快照：文件系统在某个时间点的状态镜像。这将是这系列文章里的单独的一篇，所以暂时留到后面介绍。</p>
<p>—— <a href="/article-16189-1.html">Btrfs 详解：基础概念</a></p>
</blockquote>
<p>以及：</p>
<blockquote>
<p>另外一个分离 <code>/</code> 和 <code>/home</code> 的优势是我们可以分别进行 <em>快照</em> 。子卷是快照的边界，对一个子卷的快照永远不会包含该子卷下面的其他子卷的内容。快照的更多细节会在后续的文章中介绍。</p>
<p>—— <a href="/article-16250-1.html">Btrfs 详解：子卷</a></p>
</blockquote>
<p>看起来快照是和 Btrfs 子卷相关的。你可能之前在其他地方听到过快照，比如说 LVM（逻辑卷管理器）。虽然技术角度上它们都是为了同一个目的，但它们在实现方面有所不同。</p>
<p>每个 Btrfs 快照是一个子卷。但是，不是每个子卷都是一份快照。区别在于子卷里面包含的内容。一个快照是子卷加上一些内容：它包含对现在和过去版本的文件的引用（inode）。让我们看看快照是从哪来的！</p>
<h3>创建 Btrfs 快照</h3>
<p>想使用快照功能，你需要一个 Btrfs 子卷来进行快照。让我们在测试目录（<code>~/btrfs-snapshot-test</code>）里创建一个：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>~/btrfs-snapshot-test
$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>create<span class="w"> </span>demo
Create<span class="w"> </span>subvolume<span class="w"> </span><span class="s1">&#39;./demo&#39;</span>
$<span class="w"> </span>sudo<span class="w"> </span>chown<span class="w"> </span>-R<span class="w"> </span><span class="k">$(</span>id<span class="w"> </span>-u<span class="k">)</span>:<span class="k">$(</span>id<span class="w"> </span>-g<span class="k">)</span><span class="w"> </span>demo/
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>demo
</code></pre></div>

<p>因为 Btrfs 子卷默认是被 root 所有的，你必须用 <code>chown</code> 去修改子卷里的文件的所有权到普通用户上。现在我们在里面新加一些文件：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>touch<span class="w"> </span>foo<span class="w"> </span>bar<span class="w"> </span>baz
$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;Lorem ipsum dolor sit amet, &quot;</span><span class="w"> </span>&gt;<span class="w"> </span>foo
</code></pre></div>

<p>你的目录现在看起来像这样：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>ls<span class="w"> </span>-l
total<span class="w"> </span><span class="m">4</span>
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">  </span><span class="m">0</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>bar
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">  </span><span class="m">0</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>baz
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w"> </span><span class="m">29</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>foo
</code></pre></div>

<p>让我们从这里创建第一次快照：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>..
$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>demo<span class="w"> </span>demo-1
Create<span class="w"> </span>a<span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;./demo-1&#39;</span>
</code></pre></div>

<p>这就好了。让我们看看发生了什么：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>ls<span class="w"> </span>-l
total<span class="w"> </span><span class="m">0</span>
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w"> </span><span class="m">18</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>demo
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w"> </span><span class="m">18</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>demo-1
$<span class="w"> </span>tree
.
├──<span class="w"> </span>demo
│<span class="w">   </span>├──<span class="w"> </span>bar
│<span class="w">   </span>├──<span class="w"> </span>baz
│<span class="w">   </span>└──<span class="w"> </span>foo
└──<span class="w"> </span>demo-1
<span class="w">    </span>├──<span class="w"> </span>bar
<span class="w">    </span>├──<span class="w"> </span>baz
<span class="w">    </span>└──<span class="w"> </span>foo

<span class="m">2</span><span class="w"> </span>directories,<span class="w"> </span><span class="m">6</span><span class="w"> </span>files
</code></pre></div>

<p>这看起来是一份拷贝！为了验证，我们从快照里读取 <code>foo</code> 的内容：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>cat<span class="w"> </span>demo/foo
Lorem<span class="w"> </span>ipsum<span class="w"> </span>dolor<span class="w"> </span>sit<span class="w"> </span>amet,
$<span class="w"> </span>cat<span class="w"> </span>demo-1/foo
Lorem<span class="w"> </span>ipsum<span class="w"> </span>dolor<span class="w"> </span>sit<span class="w"> </span>amet,
</code></pre></div>

<p>当我们修改原始文件时，真正的效果变得明显：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;consectetur adipiscing elit, &quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>demo/foo
$<span class="w"> </span>cat<span class="w"> </span>demo/foo
Lorem<span class="w"> </span>ipsum<span class="w"> </span>dolor<span class="w"> </span>sit<span class="w"> </span>amet,
consectetur<span class="w"> </span>adipiscing<span class="w"> </span>elit,
$<span class="w"> </span>cat<span class="w"> </span>demo-1/foo
Lorem<span class="w"> </span>ipsum<span class="w"> </span>dolor<span class="w"> </span>sit<span class="w"> </span>amet,
</code></pre></div>

<p>这表明快照仍然持有“旧”版本的数据：<code>foo</code> 的内容没有改变。到目前为止，你可以通过一个简单的文件复制来实现完全相同的目标。现在你也可以继续处理旧文件了。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;sed do eiusmod tempor incididunt&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>demo-1/foo
$<span class="w"> </span>cat<span class="w"> </span>demo-1/foo
Lorem<span class="w"> </span>ipsum<span class="w"> </span>dolor<span class="w"> </span>sit<span class="w"> </span>amet,
sed<span class="w"> </span><span class="k">do</span><span class="w"> </span>eiusmod<span class="w"> </span>tempor<span class="w"> </span>incididunt
</code></pre></div>

<p>但是在底层，我们的快照实际上是一个新的 Btrfs 子卷。你可以通过下面的命令来验证这一点：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>list<span class="w"> </span>-o<span class="w"> </span>.
ID<span class="w"> </span><span class="m">259</span><span class="w"> </span>gen<span class="w"> </span><span class="m">265</span><span class="w"> </span>top<span class="w"> </span>level<span class="w"> </span><span class="m">256</span><span class="w"> </span>path<span class="w"> </span>home/hartan/btrfs-snapshot-test/demo
ID<span class="w"> </span><span class="m">260</span><span class="w"> </span>gen<span class="w"> </span><span class="m">264</span><span class="w"> </span>top<span class="w"> </span>level<span class="w"> </span><span class="m">256</span><span class="w"> </span>path<span class="w"> </span>home/hartan/btrfs-snapshot-test/demo-1
</code></pre></div>

<h3>Btrfs 子卷 vs. 文件复制</h3>
<p>这一切有什么意义呢？到目前为止快照看起来是一个更加复杂的复制文件的方式。事实上，快照不仅仅是表面上看起来那么简单。让我们来创建一个更大的文件：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>dd<span class="w"> </span><span class="k">if</span><span class="o">=</span>/dev/urandom<span class="w"> </span><span class="nv">of</span><span class="o">=</span>demo/bigfile<span class="w"> </span><span class="nv">bs</span><span class="o">=</span>1M<span class="w"> </span><span class="nv">count</span><span class="o">=</span><span class="m">512</span>
<span class="m">512</span>+0<span class="w"> </span>records<span class="w"> </span><span class="k">in</span>
<span class="m">512</span>+0<span class="w"> </span>records<span class="w"> </span>out
<span class="m">536870912</span><span class="w"> </span>bytes<span class="w"> </span><span class="o">(</span><span class="m">537</span><span class="w"> </span>MB,<span class="w"> </span><span class="m">512</span><span class="w"> </span>MiB<span class="o">)</span><span class="w"> </span>copied,<span class="w"> </span><span class="m">1</span>.3454<span class="w"> </span>s,<span class="w"> </span><span class="m">399</span><span class="w"> </span>MB/s
</code></pre></div>

<p>现在有一个512 MB 大小的新文件 <code>demo/bigfile</code> 。让我们创建另一个快照，这样在你修改数据的时候就不会丢失：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>demo<span class="w"> </span>demo-2
Create<span class="w"> </span>a<span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;./demo-2&#39;</span>
</code></pre></div>

<p>现在我们通过追加少量字符串到文件来模拟变化：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;small changes&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>demo/bigfile
</code></pre></div>

<p>这是生效后的文件结构：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>tree
.
├──<span class="w"> </span>demo
│<span class="w">   </span>├──<span class="w"> </span>bar
│<span class="w">   </span>├──<span class="w"> </span>baz
│<span class="w">   </span>├──<span class="w"> </span>bigfile
│<span class="w">   </span>└──<span class="w"> </span>foo
├──<span class="w"> </span>demo-1
│<span class="w">   </span>├──<span class="w"> </span>bar
│<span class="w">   </span>├──<span class="w"> </span>baz
│<span class="w">   </span>└──<span class="w"> </span>foo
└──<span class="w"> </span>demo-2
<span class="w">    </span>├──<span class="w"> </span>bar
<span class="w">    </span>├──<span class="w"> </span>baz
<span class="w">    </span>├──<span class="w"> </span>bigfile
<span class="w">    </span>└──<span class="w"> </span>foo

<span class="m">3</span><span class="w"> </span>directories,<span class="w"> </span><span class="m">11</span><span class="w"> </span>files
</code></pre></div>

<p>但是真正的神奇的发生在其他地方。你已经复制了 <code>demo/bigfile</code> ，你现在拥有了两个大约 512 MiB 的文件。但是，因为它们是不同的拷贝，它们应该会占据共 1 GiB 的空间。记住两个文件的差异不超过 10 字节 —— 和原文件大小相比这几乎没什么差别。</p>
<p>Btrfs 快照工作原理与文件复制不同：而是它们保持对当前和过去的 inode 的引用。当你在文件追加更新时，在底层 Btrfs 分配更多的空间去存储更新，同时在原来的 inode 增加对新数据的引用。之前的内容保持不变。为了便于理解，你可以认为这是仅仅“存储”原文件和修改版本的差异。</p>
<p>让我们看看这个效果：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>compsize<span class="w"> </span>.
Processed<span class="w"> </span><span class="m">11</span><span class="w"> </span>files,<span class="w"> </span><span class="m">5</span><span class="w"> </span>regular<span class="w"> </span>extents<span class="w"> </span><span class="o">(</span><span class="m">9</span><span class="w"> </span>refs<span class="o">)</span>,<span class="w"> </span><span class="m">3</span><span class="w"> </span>inline.
Type<span class="w">       </span>Perc<span class="w">     </span>Disk<span class="w"> </span>Usage<span class="w">   </span>Uncompressed<span class="w"> </span>Referenced
TOTAL<span class="w">      </span><span class="m">100</span>%<span class="w">      </span>512M<span class="w">         </span>512M<span class="w">         </span><span class="m">1</span>.0G
none<span class="w">       </span><span class="m">100</span>%<span class="w">      </span>512M<span class="w">         </span>512M<span class="w">         </span><span class="m">1</span>.0G
</code></pre></div>

<p>这个有趣的数字出现在 <code>TOTAL</code> 一行：</p>
<ul>
<li><code>Referenced</code> 是当前目录下所有文件大小的总和</li>
<li><code>Disk Usage</code> 是用于在磁盘上存储文件分配空间的大小</li>
</ul>
<p>你有一共 1 GiB 的文件，但存储它们仅仅占据了 512 MiB。</p>
<h3>Btrfs 快照和备份</h3>
<p>目前为止，在这篇文章中，你已经看到如何创建 Btrfs 快照和它们的特别之处。有人可能会想：如果我在我的 PC 本地进行一系列的快照，我就有一个可靠的备份策略。 <strong>其实不是这样的</strong> 。如果 Btrfs 子卷共享的底层数据被偶然破坏了（被 Btrfs 之外的东西影响，比如宇宙射线），所有指向这些数据的子卷都会存在相同的错误。</p>
<p>为了让快照成为真正的备份，你应该将它们存储到一个不同的 Btrfs 系统上，例如在一个外部驱动器上。为了本文的目的，让我们在一个文件里创建一个新的 Btrfs 系统，并挂载它来模拟一个外部驱动。如果你有一个格式为 Btrfs 的外部驱动器，请随意替换以下命令中提到的所有路径来试试！让我们创建一个新的 Btrfs 文件系统：</p>
<p><strong>注意</strong>：下面的命令会在你的文件系统上创建一个 8 GB 大小的新文件。如果你想跟着下面的步骤，请确保你的磁盘空间至少有 8 GB 剩余。请不要分配小于 8 GB 到这个文件，否则 Btrfs 可能在挂载时会遇到问题。</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>truncate<span class="w"> </span>-s<span class="w"> </span>8G<span class="w"> </span>btrfs_filesystem.img
$<span class="w"> </span>sudo<span class="w"> </span>mkfs.btrfs<span class="w"> </span>-L<span class="w"> </span><span class="s2">&quot;backup-drive&quot;</span><span class="w"> </span>btrfs_filesystem.img
btrfs-progs<span class="w"> </span>v5.18
See<span class="w"> </span>http://btrfs.wiki.kernel.org<span class="w"> </span><span class="k">for</span><span class="w"> </span>more<span class="w"> </span>information.

<span class="o">[</span><span class="w"> </span>...<span class="w"> </span><span class="o">]</span>

Devices:
<span class="w">    </span>ID<span class="w">        </span>SIZE<span class="w">  </span>PATH
<span class="w">    </span><span class="m">1</span><span class="w">     </span><span class="m">8</span>.00GiB<span class="w">  </span>btrfs_filesystem.img
</code></pre></div>

<p>这些命令创建了名为 <code>btrfs_filesystem.img</code> 的 8 GB 新文件，同时在上面格式化了一个 Btrfs 文件系统。现在你可以像外部驱动器一样挂载它：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>mkdir<span class="w"> </span>backup-drive
$<span class="w"> </span>sudo<span class="w"> </span>mount<span class="w"> </span>btrfs_filesystem.img<span class="w"> </span>backup-drive
$<span class="w"> </span>sudo<span class="w"> </span>chown<span class="w"> </span>-R<span class="w"> </span><span class="k">$(</span>id<span class="w"> </span>-u<span class="k">)</span>:<span class="k">$(</span>id<span class="w"> </span>-g<span class="k">)</span><span class="w"> </span>backup-drive
$<span class="w"> </span>ls<span class="w"> </span>-lh
total<span class="w"> </span><span class="m">4</span>.7M
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">    </span><span class="m">0</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:35<span class="w"> </span>backup-drive
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w"> </span><span class="m">8</span>.0G<span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:37<span class="w"> </span>btrfs_filesystem.img
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">   </span><span class="m">32</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:14<span class="w"> </span>demo
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">   </span><span class="m">18</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>demo-1
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">   </span><span class="m">32</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:14<span class="w"> </span>demo-2
</code></pre></div>

<p>妙，现在挂载在 <code>backup-drive</code> 下面有一个独立的 Btrfs 文件系统！让我们尝试进行快照并且把快照放进去：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>demo<span class="w"> </span>backup-drive/demo-3
Create<span class="w"> </span>a<span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;backup-drive/demo-3&#39;</span>
ERROR:<span class="w"> </span>cannot<span class="w"> </span>snapshot<span class="w"> </span><span class="s1">&#39;demo&#39;</span>:<span class="w"> </span>Invalid<span class="w"> </span>cross-device<span class="w"> </span>link
</code></pre></div>

<p>发生了什么？噢，你尝试对 <code>demo</code> 进行一次快照并把它存在不同的 Btrfs 文件系统里（从 Btrfs 视角来看是一个不同的设备）。还记得一个 Btrfs 子卷仅持有对文件和内容的引用（inode）？这正是问题所在：文件和内容存在于我们的 <code>home</code> 文件系统，但不在新创建的 <code>backup-drive</code> 。你得找到一种方式去传输子卷和其内容到新的文件系统里。</p>
<h4>在不同的 Btrfs 文件系统存储快照</h4>
<p>针对这个目的 Btrfs 工具有两个特殊的命令。让我们首先来看看它们是如何工作的：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>send<span class="w"> </span>demo<span class="w"> </span><span class="p">|</span><span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>receive<span class="w"> </span>backup-drive/
ERROR:<span class="w"> </span>subvolume<span class="w"> </span>/home/hartan/btrfs-snapshot-test/demo<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>read-only
ERROR:<span class="w"> </span>empty<span class="w"> </span>stream<span class="w"> </span>is<span class="w"> </span>not<span class="w"> </span>considered<span class="w"> </span>valid
</code></pre></div>

<p>另一个错误！这时它告诉你我们想要传输的子卷不是只读的。这是对的：你可以写入新内容到所有目前为止创建的快照/子卷。你可以像这样创建一个只读的快照：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>-r<span class="w"> </span>demo<span class="w"> </span>demo-3-ro
Create<span class="w"> </span>a<span class="w"> </span><span class="nb">readonly</span><span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;./demo-3-ro&#39;</span>
</code></pre></div>

<p>不像之前那样，这里 <code>-r</code> 选项被加到了 <code>snapshot</code> 子命令里。这创建一个只读的快照，这很容易去验证：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>touch<span class="w"> </span>demo-3-ro/another-file
touch:<span class="w"> </span>cannot<span class="w"> </span>touch<span class="w"> </span><span class="s1">&#39;demo-3-ro/another-file&#39;</span>:<span class="w"> </span>Read-only<span class="w"> </span>file<span class="w"> </span>system
</code></pre></div>

<p>现在你可以重新尝试传输子卷：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>send<span class="w"> </span>demo-3-ro<span class="w"> </span><span class="p">|</span><span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>receive<span class="w"> </span>backup-drive/
At<span class="w"> </span>subvol<span class="w"> </span>demo-3-ro
At<span class="w"> </span>subvol<span class="w"> </span>demo-3-ro
$<span class="w"> </span>tree

├──<span class="w"> </span>backup-drive
│<span class="w">   </span>└──<span class="w"> </span>demo-3-ro
│<span class="w">       </span>├──<span class="w"> </span>bar
│<span class="w">       </span>├──<span class="w"> </span>baz
│<span class="w">       </span>├──<span class="w"> </span>bigfile
│<span class="w">       </span>└──<span class="w"> </span>foo
├──<span class="w"> </span>btrfs_filesystem.img
├──<span class="w"> </span>demo
<span class="o">[</span><span class="w"> </span>...<span class="w"> </span><span class="o">]</span>
└──<span class="w"> </span>demo-3-ro
<span class="w">    </span>├──<span class="w"> </span>bar
<span class="w">    </span>├──<span class="w"> </span>baz
<span class="w">    </span>├──<span class="w"> </span>bigfile
<span class="w">    </span>└──<span class="w"> </span>foo

<span class="m">6</span><span class="w"> </span>directories,<span class="w"> </span><span class="m">20</span><span class="w"> </span>files
</code></pre></div>

<p>成功了！你成功传输原来子卷 <code>demo</code> 的一个只读快照到一个外部的 Btrfs 文件系统。</p>
<h4>在非 Btrfs 文件系统存储快照</h4>
<p>上面你已经看到你如何能存储 Btrfs 子卷/快照到其他的 Btrfs 文件系统。但如果你没有其他的 Btrfs 文件系统并且不能新创建一个，比如说外部驱动器需要一个和 Windows 或 MacOS 兼容的文件系统，你可以做什么呢？在这种情况下你可以存储子卷在文件里：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>send<span class="w"> </span>-f<span class="w"> </span>demo-3-ro-subvolume.btrfs<span class="w"> </span>demo-3-ro
At<span class="w"> </span>subvol<span class="w"> </span>demo-3-ro
$<span class="w"> </span>ls<span class="w"> </span>-lh<span class="w"> </span>demo-3-ro-subvolume.btrfs
-rw-------.<span class="w"> </span><span class="m">1</span><span class="w"> </span>root<span class="w"> </span>root<span class="w"> </span>513M<span class="w"> </span>Dec<span class="w"> </span><span class="m">21</span><span class="w"> </span><span class="m">10</span>:39<span class="w"> </span>demo-3-ro-subvolume.btrfs
</code></pre></div>

<p>文件 <code>demo-3-ro-subvolume.btrfs</code> 现在包含了随后重建 <code>demo-3-ro</code> 子卷需要的所有东西。</p>
<h4>增量地发送快照</h4>
<p>如果你对不同的子卷重复执行这个操作，你会发现在某些时间点不同的子卷不再共享它们的文件内容。这是因为像上面一样发送一个子卷，去重建这个单独的子卷的所有数据将被传送到目标位置。但是，你可以引导 Btrfs 只向目标位置发送不同子卷的差异！所谓的增量发送将保证共享的引用在子卷中仍然共享。为了展示这一点，新增一些变动到我们原来的子卷：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span><span class="nb">echo</span><span class="w"> </span><span class="s2">&quot;a few more changes&quot;</span><span class="w"> </span>&gt;&gt;<span class="w"> </span>demo/bigfile
</code></pre></div>

<p>然后创建另一个只读子卷：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>-r<span class="w"> </span>demo<span class="w"> </span>demo-4-ro
Create<span class="w"> </span>a<span class="w"> </span><span class="nb">readonly</span><span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;./demo-4-ro&#39;</span>
</code></pre></div>

<p>然后现在发送它：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>send<span class="w"> </span>-p<span class="w"> </span>demo-3-ro<span class="w"> </span>demo-4-ro<span class="w"> </span><span class="p">|</span><span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>receive<span class="w"> </span>backup-drive
At<span class="w"> </span>subvol<span class="w"> </span>demo-4-ro
At<span class="w"> </span>snapshot<span class="w"> </span>demo-4-ro
</code></pre></div>

<p>在上面的命令，<code>-p</code> 选项指定了一个父子卷用来计算差异。重要的是记住原 Btrfs 文件系统和目标 Btrfs 文件系统都必须包含相同的、未被修改过的父子卷！确保新的子卷真的在那里：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>ls<span class="w"> </span>backup-drive/
demo-3-ro<span class="w">  </span>demo-4-ro
$<span class="w"> </span>ls<span class="w"> </span>-lR<span class="w"> </span>backup-drive/demo-4-ro/
backup-drive/demo-4-ro/:
total<span class="w"> </span><span class="m">524296</span>
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">         </span><span class="m">0</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>bar
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">         </span><span class="m">0</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:11<span class="w"> </span>baz
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w"> </span><span class="m">536870945</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">21</span><span class="w"> </span><span class="m">10</span>:49<span class="w"> </span>bigfile
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">        </span><span class="m">59</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:13<span class="w"> </span>foo
</code></pre></div>

<p>但你怎样知道增量发送只传输了子卷间的差异呢？让我们传输数据流到一个文件里然后看看它有多大：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>send<span class="w"> </span>-f<span class="w"> </span>demo-4-ro-diff.btrfs<span class="w"> </span>-p<span class="w"> </span>demo-3-ro<span class="w"> </span>demo-4-ro
At<span class="w"> </span>subvol<span class="w"> </span>demo-4-ro
$<span class="w"> </span>ls<span class="w"> </span>-l<span class="w"> </span>demo-4-ro-diff.btrfs
-rw-------.<span class="w"> </span><span class="m">1</span><span class="w"> </span>root<span class="w"> </span>root<span class="w"> </span><span class="m">315</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">21</span><span class="w"> </span><span class="m">10</span>:55<span class="w"> </span>demo-4-ro-diff.btrfs
</code></pre></div>

<p>根据 <code>ls</code> ，这个文件仅仅只有 315 字节大小！这意味着增量传输只传输子卷间的差异，和额外的 Btrfs 相关的元数据。</p>
<h4>从快照中恢复子卷</h4>
<p>在继续之前，让我们清理掉这时候不再需要的东西：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>demo-4-ro-diff.btrfs<span class="w"> </span>demo-3-ro-subvolume.btrfs
$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>delete<span class="w"> </span>demo-1<span class="w"> </span>demo-2<span class="w"> </span>demo-3-ro<span class="w"> </span>demo-4-ro
$<span class="w"> </span>ls<span class="w"> </span>-l
total<span class="w"> </span><span class="m">531516</span>
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">         </span><span class="m">36</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">21</span><span class="w"> </span><span class="m">10</span>:50<span class="w"> </span>backup-drive
-rw-r--r--.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w"> </span><span class="m">8589934592</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">21</span><span class="w"> </span><span class="m">10</span>:51<span class="w"> </span>btrfs_filesystem.img
drwxr-xr-x.<span class="w"> </span><span class="m">1</span><span class="w"> </span>hartan<span class="w"> </span>hartan<span class="w">         </span><span class="m">32</span><span class="w"> </span>Dec<span class="w"> </span><span class="m">20</span><span class="w"> </span><span class="m">08</span>:14<span class="w"> </span>demo
</code></pre></div>

<p>到目前为止你已经成功创建了可读/写和只读的 Btrfs 子卷快照，并把它们发送到外部。但是，为了把这作为备份策略，还要有一种方式去发送子卷回原来的文件系统和让它们再次变为可写。出于这个目的，我们移动 <code>demo</code> 子卷到其他地方并且尝试从最近的快照中重建它。第一步：重命名为 <code>broken</code> 子卷。一旦恢复成功它会被删除：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>mv<span class="w"> </span>demo<span class="w"> </span>demo-broken
</code></pre></div>

<p>第二步: 传回最近的快照到这个文件系统：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>send<span class="w"> </span>backup-drive/demo-4-ro<span class="w"> </span><span class="p">|</span><span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>receive<span class="w"> </span>.
At<span class="w"> </span>subvol<span class="w"> </span>backup-drive/demo-4-ro
At<span class="w"> </span>subvol<span class="w"> </span>demo-4-ro
<span class="o">[</span>hartan@fedora<span class="w"> </span>btrfs-snapshot-test<span class="o">]</span>$<span class="w"> </span>ls
backup-drive<span class="w">  </span>btrfs_filesystem.img<span class="w">  </span>demo-4-ro<span class="w">  </span>demo-broken
</code></pre></div>

<p>第三步: 从快照创建一个可读写的子卷：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>demo-4-ro<span class="w"> </span>demo
Create<span class="w"> </span>a<span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo-4-ro&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;./demo&#39;</span>
$<span class="w"> </span>ls
backup-drive<span class="w">  </span>btrfs_filesystem.img<span class="w">  </span>demo<span class="w">  </span>demo-4-ro<span class="w">  </span>demo-broken
</code></pre></div>

<p>上一步非常重要：你不能重命名 <code>demo-4-ro</code> 为 <code>demo</code> ，因为这仍然是一个只读子卷！最后你可以检查你所有你想要的东西是不是在那里：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>tree<span class="w"> </span>demo
demo
├──<span class="w"> </span>bar
├──<span class="w"> </span>baz
├──<span class="w"> </span>bigfile
└──<span class="w"> </span>foo

<span class="m">0</span><span class="w"> </span>directories,<span class="w"> </span><span class="m">4</span><span class="w"> </span>files
$<span class="w"> </span>tail<span class="w"> </span>-c<span class="w"> </span>-19<span class="w"> </span>demo/bigfile
a<span class="w"> </span>few<span class="w"> </span>more<span class="w"> </span>changes
</code></pre></div>

<p>最后的命令告诉你 <code>bigfile</code> 的最后 19 个字符实际上是上次变更执行的结果。这个时候，你可能想从 <code>demo-broken</code> 复制最近的更新到新的 <code>demo</code> 子卷。因为你没有执行任何更新，你可以过时的子卷：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>delete<span class="w"> </span>demo-4-ro<span class="w"> </span>demo-broken
Delete<span class="w"> </span>subvolume<span class="w"> </span><span class="o">(</span>no-commit<span class="o">)</span>:<span class="w"> </span><span class="s1">&#39;/home/hartan/btrfs-snapshot-test/demo-4-ro&#39;</span>
Delete<span class="w"> </span>subvolume<span class="w"> </span><span class="o">(</span>no-commit<span class="o">)</span>:<span class="w"> </span><span class="s1">&#39;/home/hartan/btrfs-snapshot-test/demo-broken&#39;</span>
</code></pre></div>

<p>就是这样！你成功从一个之前存在不同 Btrfs 文件系统（外部介质）的快照中恢复 <code>demo</code> 子卷。</p>
<h3>子卷作为快照的边界</h3>
<p>在本系列的第二篇文章中我提到子卷作为快照的边界，但这到底是什么意思呢？简单来说，子卷的一份快照仅包含这个子卷的内容，而不是下面嵌套的子卷。让我们来看看这个：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>create<span class="w"> </span>demo/nested
Create<span class="w"> </span>subvolume<span class="w"> </span><span class="s1">&#39;demo/nested&#39;</span>
$<span class="w"> </span>sudo<span class="w"> </span>chown<span class="w"> </span>-R<span class="w"> </span><span class="k">$(</span>id<span class="w"> </span>-u<span class="k">)</span>:<span class="k">$(</span>id<span class="w"> </span>-g<span class="k">)</span><span class="w"> </span>demo/nested
$<span class="w"> </span>touch<span class="w"> </span>demo/nested/another_file
</code></pre></div>

<p>让我们像以前一样进行一次快照：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>snapshot<span class="w"> </span>demo<span class="w"> </span>demo-nested
Create<span class="w"> </span>a<span class="w"> </span>snapshot<span class="w"> </span>of<span class="w"> </span><span class="s1">&#39;demo&#39;</span><span class="w"> </span><span class="k">in</span><span class="w"> </span><span class="s1">&#39;./demo-nested&#39;</span>
</code></pre></div>

<p>然后查看里面的内容：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>tree<span class="w"> </span>demo-nested
demo-nested
├──<span class="w"> </span>bar
├──<span class="w"> </span>baz
├──<span class="w"> </span>bigfile
├──<span class="w"> </span>foo
└──<span class="w"> </span>nested

<span class="m">1</span><span class="w"> </span>directory,<span class="w"> </span><span class="m">4</span><span class="w"> </span>files

$<span class="w"> </span>tree<span class="w"> </span>demo
demo
├──<span class="w"> </span>bar
├──<span class="w"> </span>baz
├──<span class="w"> </span>bigfile
├──<span class="w"> </span>foo
└──<span class="w"> </span>nested
<span class="w">    </span>└──<span class="w"> </span>another_file

<span class="m">1</span><span class="w"> </span>directory,<span class="w"> </span><span class="m">5</span><span class="w"> </span>files
</code></pre></div>

<p>注意到 <code>another_file</code> 不见了，仅仅是目录 <code>nested</code> 还在。这是因为 <code>nested</code> 是一个子卷：<code>demo</code> 的快照包含嵌套子卷的目录（挂载点），但里面的内容是缺失的。目前没有方法递归地执行快照去包含嵌套子卷。但是，我们可以利用这个优势去从快照中排除一些目录！这通常对那些你容易再现的数据有用，或者它们很少变化。例子有虚拟机或者容器镜像，电影，游戏文件等等。</p>
<p>在总结之前，我们移除所有测试过程中创建的东西：</p>
<div class="highlight"><pre><span></span><code>$<span class="w"> </span>sudo<span class="w"> </span>btrfs<span class="w"> </span>subvolume<span class="w"> </span>delete<span class="w"> </span>demo/nested<span class="w"> </span>demo<span class="w"> </span>demo-nested
Delete<span class="w"> </span>subvolume<span class="w"> </span><span class="o">(</span>no-commit<span class="o">)</span>:<span class="w"> </span><span class="s1">&#39;/home/hartan/btrfs-snapshot-test/demo/nested&#39;</span>
Delete<span class="w"> </span>subvolume<span class="w"> </span><span class="o">(</span>no-commit<span class="o">)</span>:<span class="w"> </span><span class="s1">&#39;/home/hartan/btrfs-snapshot-test/demo&#39;</span>
Delete<span class="w"> </span>subvolume<span class="w"> </span><span class="o">(</span>no-commit<span class="o">)</span>:<span class="w"> </span><span class="s1">&#39;/home/hartan/btrfs-snapshot-test/demo-nested&#39;</span>
$<span class="w"> </span>sudo<span class="w"> </span>umount<span class="w"> </span>backup-drive
$<span class="w"> </span><span class="nb">cd</span><span class="w"> </span>..
$<span class="w"> </span>rm<span class="w"> </span>-rf<span class="w"> </span>btrfs-snapshot-test/
</code></pre></div>

<h3>基于 Btrfs 备份最后思考</h3>
<p>如果你决定使用 Btrfs 来执行数据的定期备份，那么你可能需要使用一个工具来自动完成这项任务。Btrfs 维基有一个专门针对 Btrfs <sup class="footnote-ref"> <a href="#fn4" id="fnref4">  [4] </a></sup> 的备份工具列表。在那里，你还将看到另一个手动执行 Btrfs 备份步骤的摘要。就我个人而言，我对 <code>btrbk</code> <sup class="footnote-ref"> <a href="#fn5" id="fnref5">  [5] </a></sup> 有很多很好的体验，我正在使用它来执行我自己的备份。除了备份之外，<code>btrbk</code> 还可以在你的 PC 本地保存 Btrfs 快照列表。我使用它来防止意外的数据删除。</p>
<p>如果你想要了解更多有关使用 Btrfs 进行备份的内容，欢迎在下面评论，我会考虑写一篇专门讨论这个话题的后续文章。</p>
<h3>总结</h3>
<p>本文研究了 Btrfs 快照，它们本质上是 Btrfs 子卷。你了解了如何创建可读写和只读快照，以及这种机制如何有助于防止数据丢失。</p>
<p>本系列的后续文章将讨论:</p>
<ul>
<li>压缩 - 透明地节省存储空间</li>
<li>配额组 - 限制文件系统大小</li>
<li>RAID - 替代 mdadm 配置</li>
</ul>
<p>如果你还想了解与 Btrfs 相关的其他主题，请查看 Btrfs 维基 <sup class="footnote-ref"> <a href="#fn2" id="fnref2:1">  [2:1] </a></sup> 和文档 <sup class="footnote-ref"> <a href="#fn1" id="fnref1:1">  [1:1] </a></sup>。不要忘记查看本系列的前两篇文章！如果你认为本文缺少了一些内容，请在下面的评论中告诉我们。再会！</p>
<h3>参考资料</h3>
<ol>
<li><a href="https://btrfs.readthedocs.io/en/latest/Introduction.html">https://btrfs.readthedocs.io/en/latest/Introduction.html</a> <a href="#fnref1">↩︎</a> <a href="#fnref1:1">↩︎</a></li>
<li><a href="https://btrfs.wiki.kernel.org/index.php/Main_Page">https://btrfs.wiki.kernel.org/index.php/Main_Page</a> <a href="#fnref2">↩︎</a> <a href="#fnref2:1">↩︎</a></li>
<li><a href="https://btrfs.readthedocs.io/en/latest/Subvolumes.html">https://btrfs.readthedocs.io/en/latest/Subvolumes.html</a> <a href="#fnref3">↩︎</a></li>
<li><a href="https://btrfs.wiki.kernel.org/index.php/Incremental_Backup#Available_Backup_Tools">https://btrfs.wiki.kernel.org/index.php/Incremental_Backup#Available_Backup_Tools</a> <a href="#fnref4">↩︎</a></li>
<li><a href="https://github.com/digint/btrbk">https://github.com/digint/btrbk</a> <a href="#fnref5">↩︎</a></li>
</ol>
<p><em>（题图：MJ/ad8a61ed-ce6f-409e-b503-69104dd71149）</em></p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>