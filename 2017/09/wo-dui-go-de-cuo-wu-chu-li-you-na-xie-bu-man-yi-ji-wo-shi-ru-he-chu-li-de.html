<!DOCTYPE html>
<html lang="zh">
<head>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <meta name="generator" content="Pelican" />
        <title>我对 Go 的错误处理有哪些不满，以及我是如何处理的</title>
        <link rel="stylesheet" href="/theme/css/main.css" />
        <meta name="description" content="Author: Andrew Morgan 写 Go 的人往往对它的错误处理模式有一定的看法。按不同的语言经验，人们可能有不同的习惯处理方法。这就是为 …" />
</head>

<body id="index" class="home">
        <header id="banner" class="body">
                <h1><a href="/">linux_cn</a></h1>
                <nav><ul>
                    <li><a href="/category/chuan-shan-jia-zhuan-fang">穿山甲专访</a></li>
                    <li><a href="/category/dai-ma-ying-xiong">代码英雄</a></li>
                    <li><a href="/category/fen-xiang">分享</a></li>
                    <li><a href="/category/guan-dian">观点</a></li>
                    <li><a href="/category/huo-dong">活动</a></li>
                    <li><a href="/category/ji-ke-man-hua">极客漫画</a></li>
                    <li><a href="/category/ji-zhu">技术</a></li>
                    <li><a href="/category/kai-yuan-zhi-hui">开源智慧</a></li>
                    <li><a href="/category/linux-fa-xing-ban">Linux 发行版</a></li>
                    <li><a href="/category/mei-ri-an-quan-zi-xun">每日安全资讯</a></li>
                    <li><a href="/category/misc">Misc</a></li>
                    <li><a href="/category/qu-kuai-lian">区块链</a></li>
                    <li><a href="/category/rong-qi-yu-yun">容器与云</a></li>
                    <li class="active"><a href="/category/ruan-jian-kai-fa">软件开发</a></li>
                    <li><a href="/category/shu-mei-pai">树莓派</a></li>
                    <li><a href="/category/xi-tong-yun-wei">系统运维</a></li>
                    <li><a href="/category/xin-wen">新闻</a></li>
                    <li><a href="/category/ying-he-guan-cha">硬核观察</a></li>
                    <li><a href="/category/zhi-ye-sheng-ya">职业生涯</a></li>
                    <li><a href="/category/zhong-jiang-ming-dan">中奖名单</a></li>
                    <li><a href="/category/zhuo-mian-ying-yong">桌面应用</a></li>
                </ul></nav>
        </header><!-- /#banner -->
<section id="content" class="body">
  <article>
    <header>
      <h1 class="entry-title">
        <a href="/2017/09/wo-dui-go-de-cuo-wu-chu-li-you-na-xie-bu-man-yi-ji-wo-shi-ru-he-chu-li-de.html" rel="bookmark"
           title="Permalink to 我对 Go 的错误处理有哪些不满，以及我是如何处理的">我对 Go 的错误处理有哪些不满，以及我是如何处理的</a></h1>
    </header>

    <div class="entry-content">
<footer class="post-info">
        <abbr class="published" title="2017-09-06T09:36:00+02:00">
                Published: Wed 06 September 2017
        </abbr>

        <address class="vcard author">
                By                         <a class="url fn" href="/author/linux-fans-from-china.html">linux fans from china</a>
        </address>
<p>In <a href="/category/ruan-jian-kai-fa">软件开发</a>.</p>

</footer><!-- /.post-info -->      <p>Author: Andrew Morgan</p>
<p><img alt="" src="/data/attachment/album/201709/06/093641llo033walz5k70pk.png"></p>
<p>写 Go 的人往往对它的错误处理模式有一定的看法。按不同的语言经验，人们可能有不同的习惯处理方法。这就是为什么我决定要写这篇文章，尽管有点固执己见，但我认为听取我的经验是有用的。我想要讲的主要问题是，很难去强制执行良好的错误处理实践，错误经常没有堆栈追踪，并且错误处理本身太冗长。不过，我已经看到了一些潜在的解决方案，或许能帮助解决一些问题。</p>
<h3>与其他语言的快速比较</h3>
<p><a href="https://blog.golang.org/errors-are-values">在 Go 中，所有的错误都是值</a>。因为这点，相当多的函数最后会返回一个 <code>error</code>, 看起来像这样：</p>
<div class="highlight"><pre><span></span><code><span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">s</span><span class="w"> </span><span class="o">*</span><span class="n">SomeStruct</span><span class="p">)</span><span class="w"> </span><span class="n">Function</span><span class="p">()</span><span class="w"> </span><span class="p">(</span><span class="n">string</span><span class="p">,</span><span class="w"> </span><span class="n">error</span><span class="p">)</span>
</code></pre></div>

<p>因此这导致调用代码通常会使用 <code>if</code> 语句来检查它们：</p>
<div class="highlight"><pre><span></span><code><span class="nv">bytes</span><span class="p">,</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">someStruct</span><span class="o">.</span><span class="nf">Function</span><span class="p">()</span>
<span class="k">if</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nv">Process</span><span class="w"> </span><span class="nv">error</span>
<span class="p">}</span>
</code></pre></div>

<p>另外一种方法，是在其他语言中，如 Java、C#、Javascript、Objective C、Python 等使用的 <code>try-catch</code> 模式。如下你可以看到与先前的 Go 示例类似的 Java 代码，声明 <code>throws</code> 而不是返回 <code>error</code>：</p>
<div class="highlight"><pre><span></span><code>public String function() throws Exception
</code></pre></div>

<p>它使用的是 <code>try-catch</code> 而不是 <code>if err != nil</code>：</p>
<div class="highlight"><pre><span></span><code><span class="nv">try</span><span class="w"> </span>{
<span class="w">  </span><span class="nv">String</span><span class="w"> </span><span class="nb">result</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nv">someObject</span>.<span class="nv">function</span><span class="ss">()</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="k">continue</span><span class="w"> </span><span class="nv">logic</span>
}
<span class="nv">catch</span><span class="w"> </span><span class="ss">(</span><span class="nv">Exception</span><span class="w"> </span><span class="nv">e</span><span class="ss">)</span><span class="w"> </span>{
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nv">process</span><span class="w"> </span><span class="nv">exception</span>
}
</code></pre></div>

<p>当然，还有其他的不同。例如，<code>error</code> 不会使你的程序崩溃，然而 <code>Exception</code> 会。还有其他的一些，在本篇中会专门提到这些。</p>
<h3>实现集中式错误处理</h3>
<p>退一步，让我们看看为什么要在一个集中的地方处理错误，以及如何做到。</p>
<p>大多数人或许会熟悉的一个例子是 web 服务 - 如果出现了一些未预料的的服务端错误，我们会生成一个 5xx 错误。在 Go 中，你或许会这么实现：</p>
<div class="highlight"><pre><span></span><code><span class="k">func</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s2">&quot;/users&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">viewUsers</span><span class="p">)</span>
<span class="w">    </span><span class="n">http</span><span class="o">.</span><span class="n">HandleFunc</span><span class="p">(</span><span class="s2">&quot;/companies&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">viewCompanies</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="n">viewUsers</span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">user</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">code</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">userTemplate</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p">);</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">http</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">(),</span><span class="w"> </span><span class="mi">500</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="n">viewCompanies</span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">companies</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="o">//</span><span class="w"> </span><span class="n">some</span><span class="w"> </span><span class="n">code</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">companiesTemplate</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">companies</span><span class="p">);</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">http</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">(),</span><span class="w"> </span><span class="mi">500</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>这并不是一个好的解决方案，因为我们不得不重复地在所有的处理函数中处理错误。为了能更好地维护，最好能在一处地方处理错误。幸运的是，<a href="https://blog.golang.org/error-handling-and-go">在 Go 语言的官方博客中，Andrew Gerrand 提供了一个替代方法</a>，可以完美地实现。我们可以创建一个处理错误的 Type：</p>
<div class="highlight"><pre><span></span><code><span class="n">type</span><span class="w"> </span><span class="n">appHandler</span><span class="w"> </span><span class="k">func</span><span class="p">(</span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="n">error</span>

<span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">fn</span><span class="w"> </span><span class="n">appHandler</span><span class="p">)</span><span class="w"> </span><span class="n">ServeHTTP</span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">fn</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">);</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">http</span><span class="o">.</span><span class="n">Error</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="o">.</span><span class="n">Error</span><span class="p">(),</span><span class="w"> </span><span class="mi">500</span><span class="p">)</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div>

<p>这可以作为一个封装器来修饰我们的处理函数：</p>
<div class="highlight"><pre><span></span><code><span class="k">func</span><span class="w"> </span><span class="n">init</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">http</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="s2">&quot;/users&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">appHandler</span><span class="p">(</span><span class="n">viewUsers</span><span class="p">))</span>
<span class="w">    </span><span class="n">http</span><span class="o">.</span><span class="n">Handle</span><span class="p">(</span><span class="s2">&quot;/companies&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">appHandler</span><span class="p">(</span><span class="n">viewCompanies</span><span class="p">))</span>
<span class="p">}</span>
</code></pre></div>

<p>接着我们需要做的是修改处理函数的签名来使它们返回 <code>errors</code>。这个方法很好，因为我们做到了 <a href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a> 原则，并且没有重复使用不必要的代码 - 现在我们可以在单独一个地方返回默认错误了。</p>
<h3>错误上下文</h3>
<p>在先前的例子中，我们可能会收到许多潜在的错误，它们中的任何一个都可能在调用堆栈的许多环节中生成。这时候事情就变得棘手了。</p>
<p>为了演示这点，我们可以扩展我们的处理函数。它可能看上去像这样，因为模板执行并不是唯一一处会发生错误的地方：</p>
<div class="highlight"><pre><span></span><code><span class="k">func</span><span class="w"> </span><span class="n">viewUsers</span><span class="p">(</span><span class="n">w</span><span class="w"> </span><span class="n">http</span><span class="o">.</span><span class="n">ResponseWriter</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">*</span><span class="n">http</span><span class="o">.</span><span class="n">Request</span><span class="p">)</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">user</span><span class="p">,</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">findUser</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">formValue</span><span class="p">(</span><span class="s2">&quot;id&quot;</span><span class="p">))</span><span class="w"> </span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">err</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">userTemplate</span><span class="o">.</span><span class="n">Execute</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="w"> </span><span class="n">user</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div>

<p>调用链可能会相当深，在整个过程中，各种错误可能在不同的地方实例化。<a href="https://research.swtch.com/go2017">Russ Cox</a>的这篇文章解释了如何避免遇到太多这类问题的最佳实践：</p>
<blockquote>
<p>“在 Go 中错误报告的部分约定是函数包含相关的上下文，包括正在尝试的操作（比如函数名和它的参数）。”</p>
</blockquote>
<p>这个给出的例子是对 OS 包的一个调用：</p>
<div class="highlight"><pre><span></span><code><span class="nv">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">os</span><span class="o">.</span><span class="nf">Remove</span><span class="p">(</span><span class="s">&quot;/tmp/nonexist&quot;</span><span class="p">)</span>
<span class="nv">fmt</span><span class="o">.</span><span class="nf">Println</span><span class="p">(</span><span class="nv">err</span><span class="p">)</span>
</code></pre></div>

<p>它会输出：</p>
<div class="highlight"><pre><span></span><code>remove /tmp/nonexist: no such file or directory
</code></pre></div>

<p>总结一下，执行后，输出的是被调用的函数、给定的参数、特定的出错信息。当在其他语言中创建一个 <code>Exception</code> 消息时，你也可以遵循这个实践。如果我们在 <code>viewUsers</code> 处理中坚持这点，那么几乎总是能明确错误的原因。</p>
<p>问题来自于那些不遵循这个最佳实践的人，并且你经常会在第三方的 Go 库中看到这些消息：</p>
<div class="highlight"><pre><span></span><code>Oh no I broke
</code></pre></div>

<p>这没什么帮助 - 你无法了解上下文，这使得调试很困难。更糟糕的是，当这些错误被忽略或返回时，这些错误会被备份到堆栈中，直到它们被处理为止：</p>
<div class="highlight"><pre><span></span><code><span class="k">if</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span>{
<span class="w">  </span><span class="k">return</span><span class="w"> </span><span class="nv">err</span>
}
</code></pre></div>

<p>这意味着错误何时发生并没有被传递出来。</p>
<p>应该注意的是，所有这些错误都可以在 <code>Exception</code> 驱动的模型中发生 - 糟糕的错误信息、隐藏异常等。那么为什么我认为该模型更有用？</p>
<p>即便我们在处理一个糟糕的异常消息，<em>我们仍然能够了解它发生在调用堆栈中什么地方</em>。因为堆栈跟踪，这引发了一些我对 Go 不了解的部分 - 你知道 Go 的 <code>panic</code> 包含了堆栈追踪，但是 <code>error</code> 没有。我推测可能是 <code>panic</code> 会使你的程序崩溃，因此需要一个堆栈追踪，而处理错误并不会，因为它会假定你在它发生的地方做一些事。</p>
<p>所以让我们回到之前的例子 - 一个有糟糕错误信息的第三方库，它只是输出了调用链。你认为调试会更容易吗？</p>
<div class="highlight"><pre><span></span><code><span class="nl">panic</span><span class="p">:</span><span class="w"> </span><span class="n">Oh</span><span class="w"> </span><span class="k">no</span><span class="w"> </span><span class="n">I</span><span class="w"> </span><span class="n">broke</span>
<span class="o">[</span><span class="n">signal 0xb code=0x1 addr=0x0 pc=0xfc90f</span><span class="o">]</span>

<span class="n">goroutine</span><span class="w"> </span><span class="mi">1103</span><span class="w"> </span><span class="o">[</span><span class="n">running</span><span class="o">]</span><span class="err">:</span>
<span class="n">panic</span><span class="p">(</span><span class="mh">0x4bed00</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc82000c0b0</span><span class="p">)</span>
<span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="k">local</span><span class="o">/</span><span class="k">go</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">runtime</span><span class="o">/</span><span class="n">panic</span><span class="p">.</span><span class="k">go</span><span class="err">:</span><span class="mi">481</span><span class="w"> </span><span class="o">+</span><span class="mh">0x3e6</span>
<span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">core</span><span class="p">.(</span><span class="n">_app</span><span class="p">).</span><span class="n">captureRequest</span><span class="p">(</span><span class="mh">0xc820163340</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x55bd50</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0</span><span class="p">,</span><span class="w"> </span><span class="mh">0x0</span><span class="p">)</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span><span class="p">.</span><span class="n">go_workspace</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">App</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="k">go</span><span class="err">:</span><span class="mi">313</span><span class="w"> </span><span class="o">+</span><span class="mh">0x12cf</span>
<span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">core</span><span class="p">.(</span><span class="n">_app</span><span class="p">).</span><span class="n">processRequest</span><span class="p">(</span><span class="mh">0xc820163340</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc82064e1c0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc82002aab8</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span><span class="p">)</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span><span class="p">.</span><span class="n">go_workspace</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">App</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">main</span><span class="p">.</span><span class="k">go</span><span class="err">:</span><span class="mi">203</span><span class="w"> </span><span class="o">+</span><span class="mh">0xb6</span>
<span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">core</span><span class="p">.</span><span class="n">NewProxy</span><span class="p">.</span><span class="n">func2</span><span class="p">(</span><span class="mh">0xc82064e1c0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc820bb2000</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc820bb2000</span><span class="p">,</span><span class="w"> </span><span class="mh">0x1</span><span class="p">)</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span><span class="p">.</span><span class="n">go_workspace</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">App</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">proxy</span><span class="p">.</span><span class="k">go</span><span class="err">:</span><span class="mi">51</span><span class="w"> </span><span class="o">+</span><span class="mh">0x2a</span>
<span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">vendor</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">rusenask</span><span class="o">/</span><span class="n">goproxy</span><span class="p">.</span><span class="n">FuncReqHandler</span><span class="p">.</span><span class="n">Handle</span><span class="p">(</span><span class="mh">0xc820da36e0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc82064e1c0</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc820bb2000</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc5001</span><span class="p">,</span><span class="w"> </span><span class="mh">0xc820b4a0a0</span><span class="p">)</span>
<span class="o">/</span><span class="n">home</span><span class="o">/</span><span class="n">ubuntu</span><span class="o">/</span><span class="p">.</span><span class="n">go_workspace</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">Org</span><span class="o">/</span><span class="n">app</span><span class="o">/</span><span class="n">core</span><span class="o">/</span><span class="n">vendor</span><span class="o">/</span><span class="n">github</span><span class="p">.</span><span class="n">com</span><span class="o">/</span><span class="n">rusenask</span><span class="o">/</span><span class="n">goproxy</span><span class="o">/</span><span class="n">actions</span><span class="p">.</span><span class="k">go</span><span class="err">:</span><span class="mi">19</span><span class="w"> </span><span class="o">+</span><span class="mh">0x30</span>
</code></pre></div>

<p>我认为这可能是 Go 的设计中被忽略的东西 - 不是所有语言都不会忽视的。</p>
<p>如果我们使用 Java 作为一个随意的例子，其中人们犯的一个最愚蠢的错误是不记录堆栈追踪：</p>
<div class="highlight"><pre><span></span><code>LOGGER.error(ex.getMessage()) // 不记录堆栈追踪
LOGGER.error(ex.getMessage(), ex) // 记录堆栈追踪
</code></pre></div>

<p>但是 Go 似乎在设计中就没有这个信息。</p>
<p>在获取上下文信息方面 - Russ 还提到了社区正在讨论一些潜在的接口用于剥离上下文错误。关于这点，了解更多或许会很有趣。</p>
<h3>堆栈追踪问题解决方案</h3>
<p>幸运的是，在做了一些查找后，我发现了这个出色的 <a href="https://github.com/go-errors/errors">Go 错误</a>库来帮助解决这个问题，来给错误添加堆栈跟踪：</p>
<div class="highlight"><pre><span></span><code>if errors.Is(err, crashy.Crashed) {
  fmt.Println(err.(*errors.Error).ErrorStack())
}
</code></pre></div>

<p>不过，我认为这个功能如果能成为语言的<ruby> 第一类公民 <rt>  first class citizenship </rt></ruby>将是一个改进，这样你就不必做一些类型修改了。此外，如果我们像先前的例子那样使用第三方库，它可能没有使用 <code>crashy</code> - 我们仍有相同的问题。</p>
<h3>我们对错误应该做什么？</h3>
<p>我们还必须考虑发生错误时应该发生什么。<a href="https://davidnix.io/post/error-handling-in-go/">这一定有用，它们不会让你的程序崩溃</a>，通常也会立即处理它们：</p>
<div class="highlight"><pre><span></span><code><span class="nv">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nf">method</span><span class="p">()</span>
<span class="k">if</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="nv">some</span><span class="w"> </span><span class="nv">logic</span><span class="w"> </span><span class="nv">that</span><span class="w"> </span><span class="nv">I</span><span class="w"> </span><span class="nv">must</span><span class="w"> </span><span class="k">do</span><span class="w"> </span><span class="nv">now</span><span class="w"> </span><span class="nv">in</span><span class="w"> </span><span class="nv">the</span><span class="w"> </span><span class="nv">event</span><span class="w"> </span><span class="nv">of</span><span class="w"> </span><span class="nv">an</span><span class="w"> </span><span class="nv">error</span><span class="o">!</span>
<span class="p">}</span>
</code></pre></div>

<p>如果我们想要调用大量方法，它们会产生错误，然后在一个地方处理所有错误，这时会发生什么？看上去像这样：</p>
<div class="highlight"><pre><span></span><code><span class="n">err</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">doSomething</span><span class="p">()</span>
<span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="o">//</span><span class="w"> </span><span class="n">handle</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="n">here</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="n">doSomething</span><span class="p">()</span><span class="w"> </span><span class="n">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="p">:</span><span class="o">=</span><span class="w"> </span><span class="n">someMethod</span><span class="p">()</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">someOther</span><span class="p">()</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">err</span>
<span class="w">  </span><span class="p">}</span>
<span class="w">  </span><span class="n">someOtherMethod</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div>

<p>这感觉有点冗余，在其他语言中你可以将多条语句作为一个整体处理。</p>
<div class="highlight"><pre><span></span><code>try {
  someMethod()
  someOther()
  someOtherMethod()
}
catch (Exception e) {
  // process exception
}
</code></pre></div>

<p>或者只要在方法签名中传递错误：</p>
<div class="highlight"><pre><span></span><code>public void doSomething() throws SomeErrorToPropogate {
  someMethod()
  someOther()
  someOtherMethod()
}
</code></pre></div>

<p>我个人认为这两个例子实现了一件事情，只是 <code>Exception</code> 模式更少冗余，更加弹性。如果有什么的话，我觉得 <code>if err！= nil</code> 感觉像样板。也许有一种方法可以清理？</p>
<h3>将失败的多条语句做为一个整体处理错误</h3>
<p>首先，我做了更多的阅读，并<a href="https://blog.golang.org/errors-are-values">在 Rob Pike 写的 Go 博客中</a>发现了一个比较务实的解决方案。</p>
<p>他定义了一个封装了错误的方法的结构体：</p>
<div class="highlight"><pre><span></span><code><span class="n">type</span><span class="w"> </span><span class="n">errWriter</span><span class="w"> </span><span class="n">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">w</span><span class="w">   </span><span class="n">io</span><span class="o">.</span><span class="n">Writer</span>
<span class="w">    </span><span class="n">err</span><span class="w"> </span><span class="n">error</span>
<span class="p">}</span>

<span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">ew</span><span class="w"> </span><span class="o">*</span><span class="n">errWriter</span><span class="p">)</span><span class="w"> </span><span class="n">write</span><span class="p">(</span><span class="n">buf</span><span class="w"> </span><span class="p">[]</span><span class="n">byte</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">ew</span><span class="o">.</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">ew</span><span class="o">.</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ew</span><span class="o">.</span><span class="n">w</span><span class="o">.</span><span class="n">Write</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div>

<p>让我们这么做：</p>
<div class="highlight"><pre><span></span><code><span class="nv">ew</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>&amp;<span class="nv">errWriter</span><span class="p">{</span><span class="nv">w</span><span class="o">:</span><span class="w"> </span><span class="nv">fd</span><span class="p">}</span>
<span class="nv">ew</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nv">p0</span><span class="p">[</span><span class="nv">a</span><span class="o">:</span><span class="nv">b</span><span class="p">])</span>
<span class="nv">ew</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nv">p1</span><span class="p">[</span><span class="nv">c</span><span class="o">:</span><span class="nv">d</span><span class="p">])</span>
<span class="nv">ew</span><span class="o">.</span><span class="nf">write</span><span class="p">(</span><span class="nv">p2</span><span class="p">[</span><span class="nv">e</span><span class="o">:</span><span class="nv">f</span><span class="p">])</span>
<span class="o">//</span><span class="w"> </span><span class="ow">and</span><span class="w"> </span><span class="nv">so</span><span class="w"> </span><span class="nv">on</span>
<span class="k">if</span><span class="w"> </span><span class="nv">ew</span><span class="o">.</span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nv">return</span><span class="w"> </span><span class="nv">ew</span><span class="o">.</span><span class="nv">err</span>
<span class="p">}</span>
</code></pre></div>

<p>这也是一个很好的方案，但是我感觉缺少了点什么 - 因为我们不能重复使用这个模式。如果我们想要一个含有字符串参数的方法，我们就不得不改变函数签名。或者如果我们不想执行写操作会怎样？我们可以尝试使它更通用：</p>
<div class="highlight"><pre><span></span><code><span class="k">type</span><span class="w"> </span><span class="nx">errWrapper</span><span class="w"> </span><span class="nx">struct</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nx">err</span><span class="w"> </span><span class="nx">error</span>
<span class="p">}</span>
</code></pre></div>

<div class="highlight"><pre><span></span><code><span class="k">func</span><span class="w"> </span><span class="p">(</span><span class="n">ew</span><span class="w"> </span><span class="o">*</span><span class="n">errWrapper</span><span class="p">)</span><span class="w"> </span><span class="n">do</span><span class="p">(</span><span class="n">f</span><span class="w"> </span><span class="k">func</span><span class="p">()</span><span class="w"> </span><span class="n">error</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">ew</span><span class="o">.</span><span class="n">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">nil</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">return</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">ew</span><span class="o">.</span><span class="n">err</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">f</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div>

<p>但是我们有一个相同的问题，如果我们想要调用含有不同参数的函数，它就无法编译了。然而你可以简单地封装这些函数调用：</p>
<div class="highlight"><pre><span></span><code><span class="nv">w</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span>&amp;<span class="nv">errWrapper</span><span class="p">{}</span>

<span class="nv">w</span><span class="o">.</span><span class="k">do</span><span class="p">(</span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nv">return</span><span class="w"> </span><span class="nf">someFunction</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">);</span>
<span class="p">})</span>

<span class="nv">w</span><span class="o">.</span><span class="k">do</span><span class="p">(</span><span class="nf">func</span><span class="p">()</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="nv">return</span><span class="w"> </span><span class="nf">otherFunction</span><span class="p">(</span><span class="s">&quot;foo&quot;</span><span class="p">);</span>
<span class="p">})</span>

<span class="nv">err</span><span class="w"> </span><span class="o">:=</span><span class="w"> </span><span class="nv">w</span><span class="o">.</span><span class="nv">err</span>

<span class="k">if</span><span class="w"> </span><span class="nv">err</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nv">nil</span><span class="w"> </span><span class="p">{</span>
<span class="o">//</span><span class="w"> </span><span class="nv">process</span><span class="w"> </span><span class="nv">error</span><span class="w"> </span><span class="nv">here</span>
<span class="p">}</span>
</code></pre></div>

<p>这可以用，但是并没有太大帮助，因为它最终比标准的 <code>if err != nil</code> 检查带来了更多的冗余。如果有人能提供其他解决方案，我会很有兴趣听。或许这个语言本身需要一些方法来以不那么臃肿的方式传递或者组合错误 - 但是感觉似乎是特意设计成不那么做。</p>
<h3>总结</h3>
<p>看完这些之后，你可能会认为我在对 <code>error</code> 挑刺儿，由此推论我反对 Go。事实并非如此，我只是将它与我使用 <code>try catch</code> 模型的经验进行比较。它是一个用于系统编程很好的语言，并且已经出现了一些优秀的工具。仅举几例，有 <a href="https://kubernetes.io/">Kubernetes</a>、<a href="https://www.docker.com/">Docker</a>、<a href="https://www.terraform.io/">Terraform</a>、<a href="http://hoverfly.io/en/latest/">Hoverfly</a> 等。还有小型、高性能、本地二进制的优点。但是，<code>error</code> 难以适应。 我希望我的推论是有道理的，而且一些方案和解决方法可能会有帮助。</p>
<p>via: <a href="https://opencredo.com/why-i-dont-like-error-handling-in-go">https://opencredo.com/why-i-dont-like-error-handling-in-go</a></p>
<p>作者：<a href="https://opencredo.com/author/andrew/">Andrew Morgan</a> 译者：<a href="https://github.com/geekpi">geekpi</a> 校对：<a href="https://github.com/jasminepeng">jasminepeng</a></p>
<p>本文由 <a href="https://github.com/LCTT/TranslateProject">LCTT</a> 原创编译，<a href="https://linux.cn/">Linux中国</a> 荣誉推出</p>
    </div><!-- /.entry-content -->

  </article>
</section>
        <section id="extras" class="body">
                <div class="blogroll">
                        <h2>links</h2>
                        <ul>
                            <li><a href="https://getpelican.com/">Pelican</a></li>
                            <li><a href="https://www.python.org/">Python.org</a></li>
                            <li><a href="https://palletsprojects.com/p/jinja/">Jinja2</a></li>
                            <li><a href="#">You can modify those links in your config file</a></li>
                        </ul>
                </div><!-- /.blogroll -->
                <div class="social">
                        <h2>social</h2>
                        <ul>

                            <li><a href="#">You can add links in your config file</a></li>
                            <li><a href="#">Another social link</a></li>
                        </ul>
                </div><!-- /.social -->
        </section><!-- /#extras -->

        <footer id="contentinfo" class="body">
                <address id="about" class="vcard body">
                Proudly powered by <a rel="nofollow" href="https://getpelican.com/">Pelican</a>, which takes great advantage of <a rel="nofollow" href="https://www.python.org/">Python</a>.
                </address><!-- /#about -->

                <p>The theme is by <a rel="nofollow" href="https://www.smashingmagazine.com/2009/08/designing-a-html-5-layout-from-scratch/">Smashing Magazine</a>, thanks!</p>
        </footer><!-- /#contentinfo -->

</body>
</html>